<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780471701460"
  data-publishers="Wiley"



  data-htmlfile-name="9780471701460_binary_search_trees.html"
  data-epub-title="Thinking Recursively with Java" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780471701460"
  data-publishers="Wiley"



  data-htmlfile-name="9780471701460_binary_search_trees.html"
  data-epub-title="Thinking Recursively with Java" data-debug=0 data-testing=0><!--<![endif]--><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="author" content="O'Reilly Media" /><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9780471701460"/><link rel="shortcut icon" href="https://www.oreilly.com/favicon.ico" /><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"/><meta property="twitter:account_id" content="4503599627559754" /><link rel="shortcut icon" href="https://learning.oreilly.com/favicon.ico" type="image/x-icon"><link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic' rel='stylesheet' type='text/css'><title>Binary Search Trees - Thinking Recursively with Java</title><link rel="stylesheet" href="https://learning.oreilly.com/static/CACHE/css/output.5bdb4fcb2aad.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://learning.oreilly.com/static/css/annotator.e3b0c44298fc.css"/><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book">
    #sbo-rt-content .center{margin-left:auto;margin-right:auto}#sbo-rt-content .absmiddle{vertical-align:middle}#sbo-rt-content .bgcolor_black{background-color:black}#sbo-rt-content .bgcolor_white{background-color:white}#sbo-rt-content hr.refentry{width:515px;height:3px;color:black;background-color:black;margin-left:0}
    </style><script> // <![CDATA[
    var g = {
      position_cache: {
        
          "chapter": "/api/v1/book/9780471701460/chapter/9780471701460_binary_search_trees.html",
          "book_id": "9780471701460",
          "chapter_uri": "9780471701460_binary_search_trees.html",
          "position": 0,
          "user_uuid": "ce47de5b-ce80-49f0-b5cd-c60d3d33b198",
          "next_chapter_uri": "/library/view/thinking-recursively-with/9780471701460/9780471701460_expression_trees.html"
        
      },
      title: "Thinking Recursively with Java",
      author_list: "Eric Roberts",
      format: "book",
      source: "application/epub+zip",
      is_system_book: true,
      is_public: false,
      loaded_from_server: true,
      allow_scripts: false,
      has_mathml: false
    };
    // ]]></script><script src="https://learning.oreilly.com/static/js/src/modernizr.8e35451ddb64.js"></script><script>
    
      

      
        
          window.PUBLIC_ANNOTATIONS = true;
        
      

      window.MOBILE_PUBLIC_ANNOTATIONS = false;

    

    
      window.PRIVACY_CONTROL_OVERRIDE = false;
    

      window.PRIVACY_CONTROL_SWITCH = true;

      window.PUBLISHER_PAGES = true;

      window.SBO = {
        "constants": {
          "SITB_ENDPOINT": "/api/v2/sitb/",
          "SEARCH_SELECT_ENDPOINT": "https://learning.oreilly.com/api/v2/search/select/",
        }
      };
  </script><link rel="canonical" href="9780471701460_binary_search_trees.html"/><meta name="description" content=" 10.2. Binary Search Trees The enormous difference in the performance of the sorting algorithms from Chapter 7 offers a vivid illustration of the importance of algorithmic efficiency. Even with the ... "><meta property="og:title" content="Binary Search Trees" /><meta itemprop="isPartOf" content="/library/view/thinking-recursively-with/9780471701460/" /><meta itemprop="name" content="Binary Search Trees" /><meta property="og:url" itemprop="url" content="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees.html" /><meta property="og:site_name" content="Safari" /><meta property="og:image" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9780471701460/" /><meta property="og:description" itemprop="description" content=" 10.2. Binary Search Trees The enormous difference in the performance of the sorting algorithms from Chapter 7 offers a vivid illustration of the importance of algorithmic efficiency. Even with the ... "><meta itemprop="inLanguage" content="en" /><meta itemprop="publisher" content="Wiley" /><meta property="og:type" content="book" /><meta property="og:book:isbn" itemprop="isbn" content="9780471701460" /><meta property="og:book:author" itemprop="author" content="Eric Roberts" /><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@OReillyMedia"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><noscript><meta http-equiv="refresh" content="0; URL=https://learning.oreilly.com/library/no-js/" /></noscript><script>
    var dataLayer = window.dataLayer || [];

    
      window.medalliaVsgUserIdentifier = 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198';
      dataLayer.push({userIdentifier: 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198'});
      dataLayer.push({loggedIn: 'yes'});

      
        window.medalliaVsgAccountIdentifier = '29964b7b-68d8-4532-9a9b-32e089689c1f';
        

        window.medalliaVsgIsIndividual = true;
        
          
          dataLayer.push({learningAccountType: 'free trial'});
          
        

        
      
    

    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5P4V6Z');
    (function () {
      var VERSION = 'V1.1';
      var AUTHOR = 'Awwad';
      if (!window.GtmHelper)
        window.GtmHelper = function () {
          var instance = this;
          var loc = document.location;
          this.version = VERSION;
          this.author = AUTHOR;
          this.readCookie = function (name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
              var c = ca[i];
              while (c.charAt(0) == ' ') c = c.substring(1, c.length);
              if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
          };
          this.createCookie = function (name, value, days, cookieDomain) {
            var domain = "";
            var expires = "";

            if (days) {
              var date = new Date();
              date.setTime(date.getTime() + Math.ceil(days * 24 * 60 * 60 * 1000));
              var expires = " expires=" + date.toGMTString() + ";";
            }

            if (typeof (cookieDomain) != 'undefined')
              domain = " domain=" + cookieDomain + "; ";

            document.cookie = name + "=" + value + ";" + expires + domain + "path=/";
          };

          this.isDuplicated = function (currentTransactionId) {
            // the previous transaction id:
            var previousTransIdValue = this.readCookie("previousTransId");

            if (currentTransactionId === previousTransIdValue) {
              return true; // Duplication
            } else {
              return false;
            }
          };
        }
    })()
  </script><script defer src="https://learning.oreilly.com/static/js/build/vendor.0eac897f11ed.js"></script><script defer src="https://learning.oreilly.com/static/js/build/reader.c745ea9296ac.js"></script></head>


<body class="reading sidenav nav-collapsed  scalefonts">

    
  <noscript> 
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
            height="0" width="0"
            style="display:none;visibility:hidden">
    </iframe>
  </noscript>



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        

  


<a href="9780471701460_binary_search_trees.html#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li><a href="https://learning.oreilly.com/home/" class="l0 nav-icn"><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.738 14H9.254v-3.676a.617.617 0 0 0-.621-.613H7.39a.617.617 0 0 0-.62.613V14H4.284a.617.617 0 0 1-.622-.613V10.22c0-.327.132-.64.367-.87l3.547-3.493a.627.627 0 0 1 .875 0l3.54 3.499c.234.229.366.54.367.864v3.167a.617.617 0 0 1-.62.613zM7.57 2.181a.625.625 0 0 1 .882 0l5.77 5.692-.93.92-5.28-5.209-5.28 5.208-.932-.919 5.77-5.692z" /></svg><span>Home</span></a></li><li class="search"><a href="9780471701460_binary_search_trees.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"/></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="9780471701460_binary_search_trees.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"/></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li class="flyout-parent"><a
                href="9780471701460_binary_search_trees.html#"
                class="l1 nav-icn "
                
              ><?xml version="1.0" encoding="UTF-8"?><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M8,8 C6.34321755,8 5.00013,6.65691245 5.00013,5.00013 C5.00013,3.34334755 6.34321755,2.00026001 8,2.00026001 C9.65678245,2.00026001 10.99987,3.34334755 10.99987,5.00013 C10.99987,6.65691245 9.65678245,8 8,8 Z M2.33024571,11.3523547 L2.33774538,11.3523547 C3.7622187,9.70968996 5.82947484,8.76608166 8.00374984,8.76608166 C10.1780248,8.76608166 12.245281,9.70968996 13.6697543,11.3523547 C13.8892083,11.6177474 14.0062813,11.9530021 13.99974,12.2973138 L13.99974,13.99974 L2.00026001,13.99974 L2.00026001,12.2973138 C1.99371867,11.9530021 2.11079172,11.6177474 2.33024571,11.3523547 Z" id="path-1"></path></svg><span>Your O&#39;Reilly</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/profile/"
                    class="l2 nav-icn"
                    
                  ><span>Profile</span></a></li><li><a
                    href="https://learning.oreilly.com/history/"
                    class="l2 nav-icn"
                    
                  ><span>History</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/"
                    class="l2 nav-icn"
                    
                  ><span>Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/u/ce47de5b-ce80-49f0-b5cd-c60d3d33b198/"
                    class="l2 nav-icn"
                    
                  ><span>Highlights</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/answers/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M2.31032699,3.75609006 C4.65421571,1.41371359 8.45302454,1.41472092 10.7955702,3.75860838 C13.1381158,6.10249583 13.1369405,9.90130261 10.7930518,12.243847 C8.44916311,14.5863913 4.65018639,14.5852161 2.30780867,12.2413286 C-0.0346204845,9.89749489 -0.0334929936,6.09853298 2.31032699,3.75609006 Z M8.8198605,4.98016308 C7.34193969,3.86924672 5.23410194,3.98609692 3.88914868,5.33104946 C3.12814393,6.09032122 2.72818176,7.13880077 2.79015179,8.21201133 C2.79115912,8.23064692 2.79233434,8.24928252 2.79350956,8.26791811 L2.79350956,8.26791811 C2.83179539,8.8307976 2.9944077,9.37404287 3.26947292,9.86201677 L3.26947292,9.86201677 L2.77621706,11.7027432 C2.7699968,11.7259241 2.77662063,11.7506624 2.79359185,11.7676337 C2.8105631,11.7846049 2.83530144,11.7912287 2.85848233,11.7850085 L2.85848233,11.7850085 L4.69400524,11.2922565 C5.26306363,11.6167344 5.90703177,11.786885 6.56209849,11.7858479 C8.64827865,11.7858479 10.3395879,10.094542 10.3395879,8.00836292 C10.3405204,6.84135608 9.80105674,5.73967784 8.87862141,5.02482134 L8.87862141,5.02482134 L8.82825492,4.98654283 Z M13.7933062,2 C14.7073496,2.00009863 15.4482759,2.74110484 15.4482759,3.65514822 C15.4482759,4.32460943 15.0449926,4.92814782 14.4264842,5.18432286 C13.8079757,5.44049789 13.096053,5.29885769 12.6226979,4.82545158 C12.1493429,4.35204547 12.0077795,3.64010743 12.2640213,3.02162665 C12.5202631,2.40314587 13.123845,1.99992776 13.7933062,2 Z"/></svg><span>Answers</span></a></li><li class="flyout-parent"><a
                href="9780471701460_binary_search_trees.html#"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z"/></g></svg><span>Explore</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/topics/"
                    class="l2 nav-icn"
                    
                  ><span>All Topics</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;formats=case%20study&amp;formats=learning%20path&amp;formats=live%20online%20training&amp;formats=notebook&amp;formats=oriole&amp;formats=video&amp;sort=popularity&amp;facet_json=true&amp;page=0&amp;collection_type=expert"
                    class="l2 nav-icn"
                    
                  ><span>Most Popular Titles</span></a></li><li><a
                    href="https://learning.oreilly.com/recommendations/"
                    class="l2 nav-icn"
                    
                  ><span>Recommended</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;sort=publication_date&amp;facet_json=true&amp;page=0"
                    class="l2 nav-icn"
                    
                  ><span>Early Releases</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/discover/"
                    class="l2 nav-icn"
                    
                  ><span>Shared Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/resource-centers/"
                    class="l2 nav-icn"
                    
                  ><span>Resource Centers</span></a></li></ul></li><li class="flyout-parent"><a
                href="9780471701460_binary_search_trees.html#"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M12.8 3.2A1.2 1.2 0 0 1 14 4.4v8.4a1.2 1.2 0 0 1-1.2 1.2H3.2A1.2 1.2 0 0 1 2 12.8V4.4a1.2 1.2 0 0 1 1.2-1.2h1.2V2h1.2v1.2h4.8V2h1.2v1.2h1.2zm-9.6 9.6h9.6V6.2H3.2v6.6zM8 9.5a1.35 1.35 0 1 1 0-2.7 1.35 1.35 0 0 1 0 2.7zm2.7 2.148v.552H5.3v-.552c0-.321.124-.634.355-.858a3.358 3.358 0 0 1 4.69 0c.23.224.355.537.355.858z" /></svg><span>Live Events</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/attend/"
                    class="l2 nav-icn"
                    
                  ><span>All Events</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/architectural-katas/"
                    class="l2 nav-icn"
                    
                  ><span>Architectural Katas</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/ai/"
                    class="l2 nav-icn"
                    
                  ><span>AI &amp; ML</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/strata/"
                    class="l2 nav-icn"
                    
                  ><span>Data Sci &amp; Eng</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/oscon/"
                    class="l2 nav-icn"
                    
                  ><span>Programming</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/infrastructure-ops/"
                    class="l2 nav-icn"
                    
                  ><span>Infra &amp; Ops</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/software-architecture/"
                    class="l2 nav-icn"
                    
                  ><span>Software Arch</span></a></li></ul></li><li class="flyout-parent"><a
                href="9780471701460_binary_search_trees.html#"
                class="l1 nav-icn "
                
              ><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.6467109,4.35328907 L14.7964612,7.51003884 C15.0678463,7.78304342 15.0678463,8.22395603 14.7964612,8.49696061 L11.6467109,11.6467109 L10.6597892,10.6597892 L13.3055794,8 L10.6597892,5.34021084 L11.6467109,4.35328907 Z M4.35328907,11.6467109 L1.20353875,8.48996116 C0.932153749,8.21695658 0.932153749,7.77604397 1.20353875,7.50303939 L4.35328907,4.35328907 L5.34021084,5.34021084 L2.69442057,8 L5.34021084,10.6597892 L4.35328907,11.6467109 Z M5.84417089,11.4997226 L8.67194674,4.50027742 L10.1838269,4.50027742 L7.35605105,11.4997226 L5.84417089,11.4997226 Z" id="Mask"></path></svg><span>Interactive</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=content-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Scenarios</span></a></li><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=sandbox-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Sandboxes</span></a></li><li><a
                    href="https://learning.oreilly.com/interactive/?classification=jupyter-notebook"
                    class="l2 nav-icn"
                    
                  ><span>Jupyter Notebooks</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/certifications/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M12.912 9.18L14 8.014l-1.088-1.18a.304.304 0 01-.075-.268L13.195 5l-1.535-.463a.313.313 0 01-.194-.194l-.462-1.537-1.565.358c-.09.03-.194 0-.269-.074L8.007 2 6.845 3.09a.303.303 0 01-.269.074l-1.565-.358-.462 1.537a.313.313 0 01-.194.194L2.82 5l.358 1.567a.26.26 0 01-.075.269L2 8.015l1.088 1.164c.075.075.09.18.075.269l-.358 1.567 1.535.463c.09.03.164.104.194.194l.462 1.537 1.565-.358c.015 0 .045-.015.075-.015.075 0 .15.03.209.074L8.007 14l1.163-1.09a.303.303 0 01.269-.074l1.565.358.462-1.537a.313.313 0 01.194-.194L13.195 11l-.358-1.567a.338.338 0 01.075-.254zm-6.046 1.37L4.41 8.26l1.16-1.244 1.767 1.649L10.4 5.6l1.202 1.202-4.242 4.243-.495-.495z"/></svg><span>Certifications</span></a></li><li ><a
                href="https://learning.oreilly.com/preferences/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"/></g></svg><span>Settings</span></a></li><li ><a
                href="https://learning.oreilly.com/public/support/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M7.363 6.656a2.692 2.692 0 0 1-2.681-2.703c0-1.493 1.2-2.703 2.681-2.703a2.692 2.692 0 0 1 2.682 2.703c0 1.493-1.2 2.703-2.682 2.703zm4.023 2.027c-1.852 0-3.352 1.513-3.352 3.379H2v-1.534c-.006-.31.099-.612.295-.852a6.666 6.666 0 0 1 9.09-.993zm-.543.676h1.12v.304c.003.284.16.543.408.676a.766.766 0 0 0 .77 0l.303-.176.556.966-.302.176a.772.772 0 0 0-.362.676v.08a.772.772 0 0 0 .362.677l.302.21-.556.965-.302-.175a.766.766 0 0 0-.771 0 .778.778 0 0 0-.409.675v.352h-1.106v-.372a.778.778 0 0 0-.409-.676.766.766 0 0 0-.77 0l-.303.176-.556-.912.302-.176a.772.772 0 0 0 .362-.676v-.04-.04a.772.772 0 0 0-.362-.676l-.302-.176.556-.966.289.155a.766.766 0 0 0 .77 0 .778.778 0 0 0 .41-.676V9.36zm1.562 2.703c0-.271-.108-.531-.3-.722a1.001 1.001 0 0 0-.72-.292 1.01 1.01 0 0 0-.992 1.023 1.01 1.01 0 0 0 1.01 1.004 1.01 1.01 0 0 0 1.002-1.013z" /></svg><span>Support</span></a></li><li ><a
                href="https://get.oreilly.com/email-signup.html"
                class="l1 nav-icn "
                target=&quot;_blank&quot;
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.564 2.263l2.172 2.174c.17.168.264.397.264.636V11a.6.6 0 0 1-.6.6h-.6V6.2h-6V2.6a.6.6 0 0 1 .6-.6h3.527c.239 0 .468.095.637.263zM2.6 14a.6.6 0 0 1-.6-.6V6.8a.6.6 0 0 1 .6-.6h1.903a1.2 1.2 0 0 1 .849.352L6.2 7.4H11a.6.6 0 0 1 .6.6v5.4a.6.6 0 0 1-.6.6H2.6zM11 5h1.8L11 3.2V5z" /></svg><span>Newsletters</span></a></li><li ><a
                href="https://learning.oreilly.com/accounts/logout/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.613 12.63A.607.607 0 0 1 2 12.03V3.602C2 3.269 2.274 3 2.613 3h5.515v1.204H3.226v7.223h4.902v1.203H2.613zM5.677 9.02V6.611h4.903V4.926a.301.301 0 0 1 .19-.274.31.31 0 0 1 .33.063l2.722 2.673a.594.594 0 0 1 0 .849L11.1 10.909a.31.31 0 0 1-.331.063.301.301 0 0 1-.19-.274V9.02H5.677z" /></svg><span>Sign Out</span></a></li></ul></div></li></ul></nav></header>



      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="9780471701460_binary_search_trees.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Thinking Recursively with Java
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="9780471701460_binary_search_trees.html#" title="Search in archive" class="js-search-controls search-controls" onclick="window.Appcues.track('SearchBook_HeronBook')"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9780471701460/chapter/9780471701460_binary_search_trees.html"><div class="js-collections-dropdown collections-dropdown menu-bit-cards" onclick="window.Appcues.track('AddPlaylist_HeronBook')"></div></div></li><li class="js-font-control-panel font-control-activator"><a href="9780471701460_binary_search_trees.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size" onclick="window.Appcues.track('ChangeFont_HeronBook')"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="9780471701460_binary_search_trees.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share" onclick="window.Appcues.track('Share_HeronBook')"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a
        class="twitter share-button t-twitter"
        target="_blank"
        aria-label="Share this section on Twitter"
        title="Share this section on Twitter"
      
        href="https://twitter.com/share?url=https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees.html&text=Thinking%20Recursively%20with%20Java&via=OReillyMedia"
      ><span>Twitter</span></a></li><li><a
        class="facebook share-button t-facebook"
        target="_blank"
        aria-label="Share this section on Facebook"
        title="Share this section on Facebook"
        href="https://www.facebook.com/sharer/sharer.php?u=https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees.html"
      ><span>Facebook</span></a></li><li><a
        class="googleplus share-button t-googleplus"
        target="_blank"
        aria-label="Share this secton on Google Plus"
        title="Share this secton on Google Plus"
        href="https://plus.google.com/share?url=https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees.html"
      ><span>Google Plus</span></a></li><li><a
        class="email share-button t-email"
        aria-label="Share this section via email"
        title="Share this section via email"
      
        href="mailto:?subject=Safari: Binary%20Search%20Trees&body=https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees.html%0D%0Afrom Thinking%20Recursively%20with%20Java%0D%0A"
      ><span>Email</span></a></li></ul></li><!-- endif request.user.is_authenticated -->
      </ul>
    </div>

      
          
      

    <section role="document">
        
        




  <script defer src="https://learning.oreilly.com/static/js/build/djangoMessagesPage.bfaca9fd8619.js"></script>


        <script src="https://fast.appcues.com/48743.js"></script>
<script>
  var userId = "ce47de5b-ce80-49f0-b5cd-c60d3d33b198";

  var userObject = {
    firstName: "Michael",
    segment: "Trial",
    admin: "False",
    profileCreatedOn: "2021-05-13",
    academic: ""
  };
  window.Appcues.identify(userId, userObject);
  window.Appcues.page();

  setTimeout(function () {
    window.Appcues.track('ViewingBook_HeronBook')
  }, 20000);
</script>


	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="9780471701460_representing_strings_as_linked_lists.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">Representing Strings as Linked Lists</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="9780471701460_expression_trees.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">Expression Trees</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div id="id9780471701460_binary_search_trees"><a id="binary_search_trees"></a>

<h3 class="docSection1Title">10.2. Binary Search Trees</h3>
<p class="docText">The enormous difference in the performance of the sorting algorithms from <a class="docLink" href="9780471701460_sorting.html#sorting">Chapter 7</a> offers a vivid illustration of the importance of algorithmic efficiency. Even with the best algorithms, however, sorting is time-consuming, especially when large amounts of data are involved. In many practical applications, it makes sense to avoid the cost of sorting a large list of items by making sure to insert each item into the correct position at the time you add it to the list. The cost of inserting an item in its proper sequence is larger than, for example, simply adding it to the end, but eliminating the need to sort the list at a later point offers a significant advantage. If nothing else, the cost of keeping the list sorted can be distributed over time, so that the program pays a little of that cost at each insertion rather than paying all at once the cost of sorting the entire list. Algorithms that distribute time-consuming activities over a series of individual operations are said to <span class="docEmphStrong">amortize</span> the cost of those operations.</p>
<p class="docText">The task of keeping a list in sorted order as you add new items can be broken down into two distinct operations. The first step is to find the correct position for the new item. This step constitutes the <span class="docEmphasis">search</span> phase of the algorithm. Once you have found the correct position, the next step consists of inserting the new item in that position. This step constitutes the <span class="docEmphasis">insert</span> phase. The efficiency of these two phases turns out to depend dramatically on the data structures used to represent the list. Moreover, a particular data structure may be very efficient for one phase of the operation and yet be highly inefficient for the other.</p>
<p class="docText">As an example, think about what happens if you store the items in a sorted array. The array representation makes it easy to implement the search phase efficiently, because the binary search algorithm from <a class="docLink" href="9780471701460_mathematical_preliminaries.html#mathematical_preliminaries">Chapter 2</a> makes it possible to locate the correct position in <span class="docEmphasis">O</span>(log <span class="docEmphasis">N</span>) time. By contrast, the insert phase in an array-based representation is extremely slow. To ensure that the array remains sorted, it is necessary to move the rest of the elements in the entire array one position to the right to make room for the new element. Because this phase of the operation could require moving every element if the new element occurred at the beginning of the array, the worst-case performance for the insert phase is <span class="docEmphasis">O</span>(<span class="docEmphasis">N</span>).</p>
<p class="docText">If you instead represent the sequence of values using a linked list, the situation is reversed in terms of the computational complexity of its steps. In a linked list, the insert phase of the operation—once you have located the correct position—can be performed in constant time. Unfortunately, the linked list representation makes it impossible to exploit the advantages of binary search, because there is no way to achieve the effect of dividing the list in two.</p>
<p class="docText">The computational complexity of the search and insert phases for the array and linked-list representations are summarized in the following table:</p>
<br><div class="center">
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image01.png" alt="" width="522" height="101">
</div><br>
<p class="docText">Because each of these representations leads to a <span class="docEmphasis">O</span>(<span class="docEmphasis">N</span>) combined time for the search-and-insert operation, neither data structure is ideal for the task of maintaining a sorted list. It would be wonderful if there were some data structure that combined the search properties of a sorted array with the insertion properties of a linked list. Such a structure does in fact exist. To figure out what it might look like, it helps to start with the linked-list arrangement and think about its shortcomings.</p>
<p class="docText">To give yourself a more concrete sense of the differences between the array and linked-list representations of a sorted collection of data, imagine that the collection you are working with consists of the names of the seven dwarves from Walt Disney's <span class="docEmphasis">Snow White</span>, and that you want to keep those names in alphabetical order. In an array, the names would be laid out like this:</p>
<br><div class="center">
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image02.png" alt="" width="549" height="53">
</div><br>
<p class="docText">In this array representation, binary search is easy to implement because you can find the index of the middle element by dividing the length of the array by 2. The situation, however, is different in the linked-list form, which has the following conceptual structure:</p>
<br><div class="center">
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image03.png" alt="" width="549" height="38">
</div><br>
<p class="docText">In this representation, there is no way to find the middle element except by following the links in the chain.</p>
<p class="docText">The problem with the linked-list representation—at least in terms of implementing the binary search operation—is that the list contains no reference pointer to the center element. But what if it did? As a thought experiment, try to imagine what happens if you change the representation of the linked list so that the reference pointer marks the middle of the list rather than its beginning. In this example, the reference pointer that represents the entire list would point to <tt><b>Grumpy</b></tt> instead of <tt><b>Bashful</b></tt>, like this:</p>
<br><div class="center">
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image04.png" alt="" width="549" height="39">
</div><br>
<p class="docText">In making this change, it is also necessary to reverse the direction of the first three arrows so that the elements <tt><b>Bashful</b></tt>, <tt><b>Doc</b></tt>, and <tt><b>Dopey</b></tt> remain connected to the structure. More significantly, the element representing <tt><b>Grumpy</b></tt> is now associated with <span class="docEmphasis">two</span> pointers, one that points to a list of the elements that come before <tt><b>Grumpy</b></tt> in the alphabet, and one that points to the list of names that follow it.</p>
<p class="docText">This strategy, while tantalizing in certain respects, only begins to solve the problem. In this diagram, it is now easy to find the center of the entire list, since the pointer has shifted to indicate the appropriate element. Binary search, however, is a recursive divide-and-conquer strategy that makes it necessary to find not only the central element of the original list, but the center of the sublists on each side. The solution to this problem is simply to apply this same transformation recursively, so that every sublist begins in the middle and proceeds in both directions. Applying this strategy to the list of the seven dwarves results in the structure<a id="IDX-CHP-10-0011"></a><a id="IDX-CHP-10-0012"></a><a id="IDX-CHP-10-0013"></a></p>
<br><div class="center">
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image05.png" alt="" width="549" height="100">
</div><br>
<p class="docText">At each level, this structure branches to form two smaller structures, which are in turn decomposed in precisely the same way. In computer science, this type of structure is called a <span class="docEmphStrong">binary tree</span>. In a binary tree such as the one represented here, each individual element is called a <span class="docEmphStrong">node</span>. The topmost node in a tree is called the <span class="docEmphStrong">root</span> of the tree. In the binary tree represented here, each node is associated with a string and a pair of object references indicating two subtrees: the subtree containing all the elements that come <span class="docEmphasis">before</span> the current node in alphabetical order and one containing the elements that come <span class="docEmphasis">after</span> this node. A binary tree that maintains this ordering property is called a <span class="docEmphStrong">binary search tree</span>.<a id="IDX-CHP-10-0014"></a><a id="IDX-CHP-10-0015"></a><a id="IDX-CHP-10-0016"></a><a id="IDX-CHP-10-0017"></a></p>
<p class="docText">Given that storing the names of dwarves does not seem particularly useful except as an example, it makes sense to extend the simple binary search tree in a way that enables it to be used in a more practical way. The <tt><b>java.util</b></tt> package contains several classes that implement the <tt><b>Map</b></tt> interface, which provides a general dictionary-like facility that allows clients to associate a pair of objects in such a way that supplying the first object, which is called the <span class="docEmphStrong">key</span>, makes it easy to find the second object, which represents the corresponding <span class="docEmphStrong">value</span>. This association of a key and a value is called a <span class="docEmphStrong">binding</span>.</p>
<p class="docText">The <tt><b>Map</b></tt> interface specifies quite a few methods, but the essence of a <tt><b>Map</b></tt> is defined by two methods:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList"><tt><b>put(key, value)</b></tt>, which creates a binding between <tt><b>key</b></tt> and <tt><b>value</b></tt></p></div></li><li><div style="font-weight:normal"><p class="docList"><tt><b>get(key)</b></tt>, which looks up the value associated with <tt><b>key</b></tt></p></div></li></ol></div>
<p class="docText">Binary search trees provide a useful representation for implementing the <tt><b>Map</b></tt> interface, although other strategies exist as well. If you've been coding in Java for any length of time, it is likely that you have run across the <tt><b>HashMap</b></tt> class (or its earlier incarnation as <tt><b>Hashtable</b></tt>), which uses an algorithm called <span class="docEmphasis">hashing</span> to create the internal association. Although it is used less often, the <tt><b>java.util</b></tt> package also includes a <tt><b>TreeMap</b></tt> class that provides the same functionality using an implementation based on a more sophisticated version of binary trees. The goal for the remainder of this section is to develop a <tt><b>BSTMap</b></tt> class that offers a partial implementation of the <tt><b>Map</b></tt> interface based on the simple formulation of binary search trees presented in the earlier paragraphs. The <tt><b>BSTMap</b></tt> class differs from the more general map class in two respects. First, it implements only the <tt><b>put</b></tt> and <tt><b>get</b></tt> methods and not the other methods specified by the <tt><b>Map</b></tt> interface. Second, it assumes that the keys in the map are always of type <tt><b>String</b></tt>. These changes reduce the generality of the class, but simplify the presentation considerably.</p>
<p class="docText">As in the implementation of the <tt><b>CLString</b></tt> class in the preceding section, the code for the <tt><b>BSTMap</b></tt> class must include an internal structure that permits recursive operations on the tree used to represent the map. That definition is similar to the definition of a <tt><b>CharCell</b></tt> in the earlier example, but differs in two important respects. The obvious difference is that the representation of an individual node in the binary tree must include two references to subtrees rather than the single reference that is sufficient for the linked list. The more subtle change arises from the fact that the intended semantics of a <tt><b>BSTMap</b></tt>—for reasons that will be outlined later in this section—are far easier to implement if the subtrees are represented using the <tt><b>BSTMap</b></tt> class itself, rather than the internal class used for an individual node. These considerations suggest the following definition for the private <tt><b>BSTNode</b></tt> class:<a id="IDX-CHP-10-0018"></a></p>
<pre><b>class BSTNode {</b>
   <b>String key;</b>
   <b>Object value;</b>
   <b>BSTMap left, right;</b>
<b>}</b></pre><br>

<p class="docText">Each <tt><b>BSTMap</b></tt> object includes a reference to a <tt><b>BSTNode</b></tt> that constitutes the root of that tree. That reference is maintained in an instance variable called <tt><b>root</b></tt>.</p>
<p class="docText">Although the primary goal of this section is to implement the methods <tt><b>put</b></tt> and <tt><b>get</b></tt>, it is useful to look first at a somewhat simpler method that offers some insight into how one might use recursion to manipulate a binary search tree. It would be convenient—for debugging reasons, if nothing else—to include as part of the definition of <tt><b>BSTMap</b></tt> a method</p>
<pre><b>public void listBindings(PrintStream out)</b></pre><br>

<p class="docText">that lists the bindings of keys and values that currently exist for the <tt><b>BSTMap</b></tt> to the <tt><b>PrintStream</b></tt> supplied as the argument <tt><b>out</b></tt>.</p>
<p class="docText">As a concrete illustration, imagine that you wanted to define a <tt><b>BSTMap</b></tt> that would translate the two-letter postal abbreviations of states into their full names. The following code creates such a map and sets up the abbreviations of the four states whose names begin with <tt><b>A</b></tt>:</p>
<pre><b>BSTMap map = new BSTMap();</b>
<b>map.put("AL", "Alabama");</b>
<b>map.put("AK", "Alaska");</b>
<b>map.put("AZ", "Arizona");</b>
<b>map.put("AR", "Arkansas");</b></pre><br>

<p class="docText">To test whether your <tt><b>BSTMap</b></tt> implementation is working, you could call</p>
<pre><b>map.listBindings(getWriter());</b></pre><br>

<p class="docText">where <tt><b>getWriter</b></tt> is a method that returns a <tt><b>PrintWriter</b></tt> to the program console. At this point you, would hope to see the following:</p>
<br><div class="center">
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image06.png" alt="" width="549" height="146">
</div><br>
<p class="docText">The output is sorted in alphabetical order by key, even though the entries were inserted into the tree in alphabetical order by the full name of the state.</p>
<p class="docText">The requirement that the output appear in alphabetical order may seem to represent a complication, particularly if you consider how this tree is represented internally. Inserting the four state abbreviations in the specified order results in a binary search tree with the following structure:</p>
<br><div class="center">
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image07.png" alt="" width="475" height="414">
</div><br>
<p class="docText">The first item to appear in the list of bindings is the binding of the abbreviation <tt><b>"AK"</b></tt> to <tt><b>"Alaska"</b></tt>, which does not occur at the root of the tree. How can the <tt><b>listBindings</b></tt> method know where to start?</p>
<p class="docText">The answer to this question lies in coding the <tt><b>listBindings</b></tt> method so that its structure parallels that of the data. To do so, it makes sense to start by observing that a binary search tree must be either</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList"><a id="with"></a>An empty tree with <tt><b>null</b></tt> as its root</p></div></li><li><div style="font-weight:normal"><p class="docList">A node preceded and followed by a binary search tree</p></div></li></ol></div>
<p class="docText">This definition closely parallels the informal recursive definition of a string from the preceding section, except, of course, that each node in the binary search tree contains two subtrees rather than a single recursive instance as in the case of strings.</p>
<p class="docText">The recursive definition of the binary search tree provides an outline for recursive operations on a tree, such as the <tt><b>listBindings</b></tt> method. If a tree is empty, there are no bindings to list. For any other tree, you can list the bindings in alphabetical order by using the following strategy:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Recursively listing the bindings in the left subtree</p></div></li><li><div style="font-weight:normal"><p class="docList">Listing the binding specified by the root node</p></div></li><li><div style="font-weight:normal"><p class="docList">Recursively listing the bindings in the right subtree</p></div></li></ol></div>
<p class="docText">Because the key in the root node is guaranteed to occur alphabetically after the keys in the left subtree and before the keys in the right subtree, this recursive strategy will produce a correctly ordered list of bindings. The code, moreover, follows directly from the recursive outline:</p>
<pre><b>public void listBindings(PrintStream out) {</b>
   <b>if (root != null) {</b>
      <b>root.left.listBindings(out);</b>
      <b>out.println(root.key + " = " + root.value);</b>
      <b>root.right.listBindings(out);</b>
   <b>}</b>
<b>}</b></pre><br>

<p class="docText">The <tt><b>get</b></tt><a id="the"></a> method for the <tt><b>BSTMap</b></tt> class uses a similar strategy. Consider the possibilities that arise when one calls <tt><b>get</b></tt> with a particular key. The first possibility is that the tree is empty, which means that the key is not present. According to its specification in the <tt><b>Map</b></tt> interface, <tt><b>get</b></tt> should return <tt><b>null</b></tt> in this case. But what if the tree has at least one node? In this case, there are three possibilities:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">The key you're looking for might match the key in the current node. In this case, <tt><b>get</b></tt> should return the value in that node.</p></div></li><li><div style="font-weight:normal"><p class="docList">The key you're looking for might come earlier in the alphabet than the key in the current node. In this case, the key—if it is present at all in the tree— must occur in the left subtree, where it can be found by recursion.</p></div></li><li><div style="font-weight:normal"><p class="docList">The key you're looking for might come later in the alphabet than the key in the current node. This case is symmetric to the previous one and again can be solved by recursion, this time using the right subtree.</p></div></li></ol></div>
<p class="docText">The code necessary to implement this three-case strategy looks like this:</p>
<pre><b>public Object get(String key) {</b>
   <b>if (root == null) {</b>
      <b>return null;</b>
   <b>} else {</b>
      <b>int cmp = key.compareTo(root.key);</b>
      <b>if (cmp == 0) {</b>
         <b>return root.value;</b>
      <b>} else if (cmp &lt; 0) {</b>
         <b>return root.left.get(key);</b>
      <b>} else {</b>
         <b>return root.right.get(key);</b>
      <b>}</b>
   <b>}</b>
<b>}</b></pre><br>

<p class="docText">The remaining method in the simplified implementation of <tt><b>BSTMap</b></tt> is <tt><b>put</b></tt>, which has almost the same form as the <tt><b>get</b></tt> method. The recursive part is completely analogous, since the process of finding the appropriate node in the tree is exactly the same for the two methods. The difference lies primarily in the simple case. When <tt><b>get</b></tt> encounters an empty tree—either initially or as part of the recursive subdivision—it simply returns <tt><b>null</b></tt> to indicate that the key is not present in the tree. The <tt><b>put</b></tt> method, on the other hand, must create such an entry if it is not there. Given the structure chosen to represent a <tt><b>BSTMap</b></tt>, handling the case of an empty tree is easy. If <tt><b>put</b></tt><a id="a"></a> is called on a <tt><b>BSTMap</b></tt> object whose root is <tt><b>null</b></tt>, all it needs to do is create a new node with the specified key and value and then make that node the new root of the tree. The complete code for the <tt><b>put</b></tt> method therefore looks like this:</p>
<pre><b>public void put(String key, Object value) {</b>
   <b>if (root == null) {</b>
      <b>root = new BSTNode();</b>
      <b>root.key = key;</b>
      <b>root.value = value;</b>
      <b>root.left = new BSTMap();</b>
      <b>root.right = new BSTMap();</b>
   <b>} else {</b>
      <b>int cmp = key.compareTo(root.key);</b>
      <b>if (cmp == 0) {</b>
         <b>root.value = value;</b>
      <b>} else if (cmp &lt; 0) {</b>
         <b>root.left.put(key, value);</b>
      <b>} else {</b>
         <b>root.right.put(key, value);</b>
      <b>}</b>
   <b>}</b>
<b>}</b></pre><br>

<p class="docText">This code is complicated enough to call for an example. Suppose that you wanted to add the next state abbreviation to an existing binary search tree containing entries for the four states whose names begin with <tt><b>A</b></tt>. The binary search tree at this point has the following internal structure:</p>
<br><div class="center">
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image08.png" alt="" width="475" height="414">
</div><br>
<p class="docText">What happens to this tree if you call <tt><b>map.put("CA", "California")</b></tt>?</p>
<p class="docText">The first step in the process is to compare the key <tt><b>"CA"</b></tt> to the key in the root node of the binary search tree. Because <tt><b>"CA"</b></tt> comes after <tt><b>"AL"</b></tt> in the alphabet, the node with <tt><b>"CA"</b></tt> as its key, if it exists, must be in the right subtree. Thus, the first recursive call repeats the <tt><b>put</b></tt> operation in the simpler subtree that looks like this:</p>
<br><div class="center">
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image09.png" alt="" width="259" height="310">
</div><br>
<p class="docText">As before, the initial step consists of comparing <tt><b>"CA"</b></tt> to the current key and finding that the node with <tt><b>"CA"</b></tt> as its key must again lie in the right subtree. Here, however, that right subtree is listed in the diagram as having the value <tt><b>null</b></tt>. Before tracing the next level of the recursion, however, it pays to be careful about the exact structure. The subtrees in the private class <tt><b>BSTNode</b></tt> were deliberately defined to be of type <tt><b>BSTMap</b></tt> rather than <tt><b>BSTNode</b></tt>, which means that an additional level of object reference is involved. The <tt><b>null</b></tt> that appears in the diagram is really the <tt><b>root</b></tt> field of a new <tt><b>BSTNode</b></tt>, which makes it possible to replace that value with a new node containing the new key and value. After the new node has been inserted, the updated tree looks like this:</p>
<br><div class="center">
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image10.png" alt="" width="549" height="389">
</div><br>
<p class="docText">Stepping through the code for <tt><b>put</b></tt> makes it clear why the definition of a <tt><b>BSTNode</b></tt> had to include the additional level of object reference. If <tt><b>BSTNode</b></tt> had been defined analogously to <tt><b>CharCell</b></tt> in the <tt><b>CLString</b></tt> example from the preceding section, it would be impossible to implement the simple case of the <tt><b>put</b></tt> method in the straightforward way shown in the code. The <tt><b>null</b></tt> reference suffices to indicate the absence of a node at some point in the tree but provides no data field to which one could assign a new value. Defining the subtrees using <tt><b>BSTMap</b></tt> ensures that the simple case has a place to store the new node.</p>
<p class="docText">The discovery that the binary search tree mechanism requires an additional level of object reference brings up an interesting question: why was that additional level of reference not needed in the case of the <tt><b>CLString</b></tt> class? The answer lies in the fact that the two classes differ in an important respect. The <tt><b>CLString</b></tt> class, like the <tt><b>String</b></tt> class that it seeks to emulate, is immutable in the sense that no methods in the class change the internal structure. The <tt><b>BSTMap</b></tt> class, by contrast, does not share this property. The <tt><b>put</b></tt> method is useful only if it can change the underlying structure of the tree.</p>
<p class="docText">So that you can see how the pieces of the implementation fit together, the complete code for the <tt><b>BSTMap</b></tt> class appears in <a class="docLink" href="9780471701460_binary_search_trees.html#the_bstmap_class">Figure 10-2</a>.<a id="IDX-CHP-10-0019"></a><a id="IDX-CHP-10-0020"></a><a id="IDX-CHP-10-0021"></a><a id="IDX-CHP-10-0022"></a></p>
<a id="the_bstmap_class"></a><p></p><div class="center">
<h5 class="docFigureTitle">Figure 10-2. The BSTMap class</h5>
<img src="https://learning.oreilly.com/library/view/thinking-recursively-with/9780471701460/9780471701460_binary_search_trees_image11.png" alt="" width="549" height="1562">
</div><br>
</div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="9780471701460_representing_strings_as_linked_lists.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">Representing Strings as Linked Lists</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="9780471701460_expression_trees.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">Expression Trees</div>
        </a>
    
  
  </div>


        
    </section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag">
        
        
          <p class="usage-data">Find answers on the fly, or master something new. Subscribe today. <a href="https://learning.oreilly.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
        

        
        

      </div>

    
    



        
      </div>
      
        

<footer class="pagefoot t-pagefoot">
  <a href="9780471701460_binary_search_trees.html#" class="icon-up" onclick="window.Appcues.track('JumpTop_HeronBook')"><div class="visuallyhidden">Back to top</div></a>
  <ul class='js-footer-nav'>
  
    
    <li><a href="https://learning.oreilly.com/public/support/">Support</a></li>
    
    <li><a href="https://learning.oreilly.com/accounts/logout/">Sign Out</a></li>
    
  
  
  </ul>
  <span class="copyright">&#169; 2021 <a href="https://learning.oreilly.com/" target="_blank">O'Reilly Media, Inc</a>.</span>
  
    
    <a href="https://www.oreilly.com/terms/">Terms of Service</a> 
     / 
    
    <a href="https://learning.oreilly.com/privacy">Privacy Policy</a> 
    
    
  
</footer>

      
    
    <script src="https://learning.oreilly.com/jsi18n/web/" charset="utf-8"></script>
    <script src="https://learning.oreilly.com/library/jsi18n/appcache/" charset="utf-8"></script>
  </body>
</html>
