<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch04.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch04.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch04.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch04.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><!--<![endif]--><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="author" content="O'Reilly Media" /><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9780470069172"/><link rel="shortcut icon" href="https://www.oreilly.com/favicon.ico" /><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"/><meta property="twitter:account_id" content="4503599627559754" /><link rel="shortcut icon" href="https://learning.oreilly.com/favicon.ico" type="image/x-icon"><link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic' rel='stylesheet' type='text/css'><title>4. Working with Tables - Beginning Lua Programming</title><link rel="stylesheet" href="https://learning.oreilly.com/static/CACHE/css/output.5bdb4fcb2aad.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://learning.oreilly.com/static/css/annotator.e3b0c44298fc.css"/><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book"></style><script> // <![CDATA[
    var g = {
      position_cache: {
        
          "chapter": "/api/v1/book/9780470069172/chapter/ch04.html",
          "book_id": "9780470069172",
          "chapter_uri": "ch04.html",
          "position": 0,
          "user_uuid": "ce47de5b-ce80-49f0-b5cd-c60d3d33b198",
          "next_chapter_uri": "/library/view/beginning-lua-programming/9780470069172/ch05.html"
        
      },
      title: "Beginning Lua Programming",
      author_list: "Aaron Brown, Kurt Jung",
      format: "book",
      source: "application/epub+zip",
      is_system_book: true,
      is_public: false,
      loaded_from_server: true,
      allow_scripts: false,
      has_mathml: false
    };
    // ]]></script><script src="https://learning.oreilly.com/static/js/src/modernizr.8e35451ddb64.js"></script><script>
    
      

      
        
          window.PUBLIC_ANNOTATIONS = true;
        
      

      window.MOBILE_PUBLIC_ANNOTATIONS = false;

    

    
      window.PRIVACY_CONTROL_OVERRIDE = false;
    

      window.PRIVACY_CONTROL_SWITCH = true;

      window.PUBLISHER_PAGES = true;

      window.SBO = {
        "constants": {
          "SITB_ENDPOINT": "/api/v2/sitb/",
          "SEARCH_SELECT_ENDPOINT": "https://learning.oreilly.com/api/v2/search/select/",
        }
      };
  </script><link rel="canonical" href="ch04.html"/><meta name="description" content="Chapter 4. Working with Tables This chapter explores a new data type called a table. It&#39;s a data structure, which means that it lets you combine other values. ... "><meta property="og:title" content="4. Working with Tables" /><meta itemprop="isPartOf" content="/library/view/beginning-lua-programming/9780470069172/" /><meta itemprop="name" content="4. Working with Tables" /><meta property="og:url" itemprop="url" content="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch04.html" /><meta property="og:site_name" content="Safari" /><meta property="og:image" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9780470069172/" /><meta property="og:description" itemprop="description" content="Chapter 4. Working with Tables This chapter explores a new data type called a table. It&#39;s a data structure, which means that it lets you combine other values. ... "><meta itemprop="inLanguage" content="en" /><meta itemprop="publisher" content="Wrox" /><meta property="og:type" content="book" /><meta property="og:book:isbn" itemprop="isbn" content="9780470069172" /><meta property="og:book:author" itemprop="author" content="Aaron Brown" /><meta property="og:book:author" itemprop="author" content="Kurt Jung" /><meta property="og:book:tag" itemprop="about" content="Core Programming" /><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@OReillyMedia"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><noscript><meta http-equiv="refresh" content="0; URL=https://learning.oreilly.com/library/no-js/" /></noscript><script>
    var dataLayer = window.dataLayer || [];

    
      window.medalliaVsgUserIdentifier = 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198';
      dataLayer.push({userIdentifier: 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198'});
      dataLayer.push({loggedIn: 'yes'});

      
        window.medalliaVsgAccountIdentifier = '29964b7b-68d8-4532-9a9b-32e089689c1f';
        

        window.medalliaVsgIsIndividual = true;
        
          
          dataLayer.push({learningAccountType: 'free trial'});
          
        

        
      
    

    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5P4V6Z');
    (function () {
      var VERSION = 'V1.1';
      var AUTHOR = 'Awwad';
      if (!window.GtmHelper)
        window.GtmHelper = function () {
          var instance = this;
          var loc = document.location;
          this.version = VERSION;
          this.author = AUTHOR;
          this.readCookie = function (name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
              var c = ca[i];
              while (c.charAt(0) == ' ') c = c.substring(1, c.length);
              if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
          };
          this.createCookie = function (name, value, days, cookieDomain) {
            var domain = "";
            var expires = "";

            if (days) {
              var date = new Date();
              date.setTime(date.getTime() + Math.ceil(days * 24 * 60 * 60 * 1000));
              var expires = " expires=" + date.toGMTString() + ";";
            }

            if (typeof (cookieDomain) != 'undefined')
              domain = " domain=" + cookieDomain + "; ";

            document.cookie = name + "=" + value + ";" + expires + domain + "path=/";
          };

          this.isDuplicated = function (currentTransactionId) {
            // the previous transaction id:
            var previousTransIdValue = this.readCookie("previousTransId");

            if (currentTransactionId === previousTransIdValue) {
              return true; // Duplication
            } else {
              return false;
            }
          };
        }
    })()
  </script><script defer src="https://learning.oreilly.com/static/js/build/vendor.0eac897f11ed.js"></script><script defer src="https://learning.oreilly.com/static/js/build/reader.c745ea9296ac.js"></script></head>


<body class="reading sidenav nav-collapsed  scalefonts">

    
  <noscript> 
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
            height="0" width="0"
            style="display:none;visibility:hidden">
    </iframe>
  </noscript>



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        

  


<a href="ch04.html#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li><a href="https://learning.oreilly.com/home/" class="l0 nav-icn"><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.738 14H9.254v-3.676a.617.617 0 0 0-.621-.613H7.39a.617.617 0 0 0-.62.613V14H4.284a.617.617 0 0 1-.622-.613V10.22c0-.327.132-.64.367-.87l3.547-3.493a.627.627 0 0 1 .875 0l3.54 3.499c.234.229.366.54.367.864v3.167a.617.617 0 0 1-.62.613zM7.57 2.181a.625.625 0 0 1 .882 0l5.77 5.692-.93.92-5.28-5.209-5.28 5.208-.932-.919 5.77-5.692z" /></svg><span>Home</span></a></li><li class="search"><a href="ch04.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"/></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="ch04.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"/></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li class="flyout-parent"><a
                href="ch04.html#"
                class="l1 nav-icn "
                
              ><?xml version="1.0" encoding="UTF-8"?><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M8,8 C6.34321755,8 5.00013,6.65691245 5.00013,5.00013 C5.00013,3.34334755 6.34321755,2.00026001 8,2.00026001 C9.65678245,2.00026001 10.99987,3.34334755 10.99987,5.00013 C10.99987,6.65691245 9.65678245,8 8,8 Z M2.33024571,11.3523547 L2.33774538,11.3523547 C3.7622187,9.70968996 5.82947484,8.76608166 8.00374984,8.76608166 C10.1780248,8.76608166 12.245281,9.70968996 13.6697543,11.3523547 C13.8892083,11.6177474 14.0062813,11.9530021 13.99974,12.2973138 L13.99974,13.99974 L2.00026001,13.99974 L2.00026001,12.2973138 C1.99371867,11.9530021 2.11079172,11.6177474 2.33024571,11.3523547 Z" id="path-1"></path></svg><span>Your O&#39;Reilly</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/profile/"
                    class="l2 nav-icn"
                    
                  ><span>Profile</span></a></li><li><a
                    href="https://learning.oreilly.com/history/"
                    class="l2 nav-icn"
                    
                  ><span>History</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/"
                    class="l2 nav-icn"
                    
                  ><span>Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/u/ce47de5b-ce80-49f0-b5cd-c60d3d33b198/"
                    class="l2 nav-icn"
                    
                  ><span>Highlights</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/answers/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M2.31032699,3.75609006 C4.65421571,1.41371359 8.45302454,1.41472092 10.7955702,3.75860838 C13.1381158,6.10249583 13.1369405,9.90130261 10.7930518,12.243847 C8.44916311,14.5863913 4.65018639,14.5852161 2.30780867,12.2413286 C-0.0346204845,9.89749489 -0.0334929936,6.09853298 2.31032699,3.75609006 Z M8.8198605,4.98016308 C7.34193969,3.86924672 5.23410194,3.98609692 3.88914868,5.33104946 C3.12814393,6.09032122 2.72818176,7.13880077 2.79015179,8.21201133 C2.79115912,8.23064692 2.79233434,8.24928252 2.79350956,8.26791811 L2.79350956,8.26791811 C2.83179539,8.8307976 2.9944077,9.37404287 3.26947292,9.86201677 L3.26947292,9.86201677 L2.77621706,11.7027432 C2.7699968,11.7259241 2.77662063,11.7506624 2.79359185,11.7676337 C2.8105631,11.7846049 2.83530144,11.7912287 2.85848233,11.7850085 L2.85848233,11.7850085 L4.69400524,11.2922565 C5.26306363,11.6167344 5.90703177,11.786885 6.56209849,11.7858479 C8.64827865,11.7858479 10.3395879,10.094542 10.3395879,8.00836292 C10.3405204,6.84135608 9.80105674,5.73967784 8.87862141,5.02482134 L8.87862141,5.02482134 L8.82825492,4.98654283 Z M13.7933062,2 C14.7073496,2.00009863 15.4482759,2.74110484 15.4482759,3.65514822 C15.4482759,4.32460943 15.0449926,4.92814782 14.4264842,5.18432286 C13.8079757,5.44049789 13.096053,5.29885769 12.6226979,4.82545158 C12.1493429,4.35204547 12.0077795,3.64010743 12.2640213,3.02162665 C12.5202631,2.40314587 13.123845,1.99992776 13.7933062,2 Z"/></svg><span>Answers</span></a></li><li class="flyout-parent"><a
                href="ch04.html#"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z"/></g></svg><span>Explore</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/topics/"
                    class="l2 nav-icn"
                    
                  ><span>All Topics</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;formats=case%20study&amp;formats=learning%20path&amp;formats=live%20online%20training&amp;formats=notebook&amp;formats=oriole&amp;formats=video&amp;sort=popularity&amp;facet_json=true&amp;page=0&amp;collection_type=expert"
                    class="l2 nav-icn"
                    
                  ><span>Most Popular Titles</span></a></li><li><a
                    href="https://learning.oreilly.com/recommendations/"
                    class="l2 nav-icn"
                    
                  ><span>Recommended</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;sort=publication_date&amp;facet_json=true&amp;page=0"
                    class="l2 nav-icn"
                    
                  ><span>Early Releases</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/discover/"
                    class="l2 nav-icn"
                    
                  ><span>Shared Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/resource-centers/"
                    class="l2 nav-icn"
                    
                  ><span>Resource Centers</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch04.html#"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M12.8 3.2A1.2 1.2 0 0 1 14 4.4v8.4a1.2 1.2 0 0 1-1.2 1.2H3.2A1.2 1.2 0 0 1 2 12.8V4.4a1.2 1.2 0 0 1 1.2-1.2h1.2V2h1.2v1.2h4.8V2h1.2v1.2h1.2zm-9.6 9.6h9.6V6.2H3.2v6.6zM8 9.5a1.35 1.35 0 1 1 0-2.7 1.35 1.35 0 0 1 0 2.7zm2.7 2.148v.552H5.3v-.552c0-.321.124-.634.355-.858a3.358 3.358 0 0 1 4.69 0c.23.224.355.537.355.858z" /></svg><span>Live Events</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/attend/"
                    class="l2 nav-icn"
                    
                  ><span>All Events</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/architectural-katas/"
                    class="l2 nav-icn"
                    
                  ><span>Architectural Katas</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/ai/"
                    class="l2 nav-icn"
                    
                  ><span>AI &amp; ML</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/strata/"
                    class="l2 nav-icn"
                    
                  ><span>Data Sci &amp; Eng</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/oscon/"
                    class="l2 nav-icn"
                    
                  ><span>Programming</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/infrastructure-ops/"
                    class="l2 nav-icn"
                    
                  ><span>Infra &amp; Ops</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/software-architecture/"
                    class="l2 nav-icn"
                    
                  ><span>Software Arch</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch04.html#"
                class="l1 nav-icn "
                
              ><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.6467109,4.35328907 L14.7964612,7.51003884 C15.0678463,7.78304342 15.0678463,8.22395603 14.7964612,8.49696061 L11.6467109,11.6467109 L10.6597892,10.6597892 L13.3055794,8 L10.6597892,5.34021084 L11.6467109,4.35328907 Z M4.35328907,11.6467109 L1.20353875,8.48996116 C0.932153749,8.21695658 0.932153749,7.77604397 1.20353875,7.50303939 L4.35328907,4.35328907 L5.34021084,5.34021084 L2.69442057,8 L5.34021084,10.6597892 L4.35328907,11.6467109 Z M5.84417089,11.4997226 L8.67194674,4.50027742 L10.1838269,4.50027742 L7.35605105,11.4997226 L5.84417089,11.4997226 Z" id="Mask"></path></svg><span>Interactive</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=content-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Scenarios</span></a></li><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=sandbox-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Sandboxes</span></a></li><li><a
                    href="https://learning.oreilly.com/interactive/?classification=jupyter-notebook"
                    class="l2 nav-icn"
                    
                  ><span>Jupyter Notebooks</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/certifications/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M12.912 9.18L14 8.014l-1.088-1.18a.304.304 0 01-.075-.268L13.195 5l-1.535-.463a.313.313 0 01-.194-.194l-.462-1.537-1.565.358c-.09.03-.194 0-.269-.074L8.007 2 6.845 3.09a.303.303 0 01-.269.074l-1.565-.358-.462 1.537a.313.313 0 01-.194.194L2.82 5l.358 1.567a.26.26 0 01-.075.269L2 8.015l1.088 1.164c.075.075.09.18.075.269l-.358 1.567 1.535.463c.09.03.164.104.194.194l.462 1.537 1.565-.358c.015 0 .045-.015.075-.015.075 0 .15.03.209.074L8.007 14l1.163-1.09a.303.303 0 01.269-.074l1.565.358.462-1.537a.313.313 0 01.194-.194L13.195 11l-.358-1.567a.338.338 0 01.075-.254zm-6.046 1.37L4.41 8.26l1.16-1.244 1.767 1.649L10.4 5.6l1.202 1.202-4.242 4.243-.495-.495z"/></svg><span>Certifications</span></a></li><li ><a
                href="https://learning.oreilly.com/preferences/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"/></g></svg><span>Settings</span></a></li><li ><a
                href="https://learning.oreilly.com/public/support/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M7.363 6.656a2.692 2.692 0 0 1-2.681-2.703c0-1.493 1.2-2.703 2.681-2.703a2.692 2.692 0 0 1 2.682 2.703c0 1.493-1.2 2.703-2.682 2.703zm4.023 2.027c-1.852 0-3.352 1.513-3.352 3.379H2v-1.534c-.006-.31.099-.612.295-.852a6.666 6.666 0 0 1 9.09-.993zm-.543.676h1.12v.304c.003.284.16.543.408.676a.766.766 0 0 0 .77 0l.303-.176.556.966-.302.176a.772.772 0 0 0-.362.676v.08a.772.772 0 0 0 .362.677l.302.21-.556.965-.302-.175a.766.766 0 0 0-.771 0 .778.778 0 0 0-.409.675v.352h-1.106v-.372a.778.778 0 0 0-.409-.676.766.766 0 0 0-.77 0l-.303.176-.556-.912.302-.176a.772.772 0 0 0 .362-.676v-.04-.04a.772.772 0 0 0-.362-.676l-.302-.176.556-.966.289.155a.766.766 0 0 0 .77 0 .778.778 0 0 0 .41-.676V9.36zm1.562 2.703c0-.271-.108-.531-.3-.722a1.001 1.001 0 0 0-.72-.292 1.01 1.01 0 0 0-.992 1.023 1.01 1.01 0 0 0 1.01 1.004 1.01 1.01 0 0 0 1.002-1.013z" /></svg><span>Support</span></a></li><li ><a
                href="https://get.oreilly.com/email-signup.html"
                class="l1 nav-icn "
                target=&quot;_blank&quot;
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.564 2.263l2.172 2.174c.17.168.264.397.264.636V11a.6.6 0 0 1-.6.6h-.6V6.2h-6V2.6a.6.6 0 0 1 .6-.6h3.527c.239 0 .468.095.637.263zM2.6 14a.6.6 0 0 1-.6-.6V6.8a.6.6 0 0 1 .6-.6h1.903a1.2 1.2 0 0 1 .849.352L6.2 7.4H11a.6.6 0 0 1 .6.6v5.4a.6.6 0 0 1-.6.6H2.6zM11 5h1.8L11 3.2V5z" /></svg><span>Newsletters</span></a></li><li ><a
                href="https://learning.oreilly.com/accounts/logout/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.613 12.63A.607.607 0 0 1 2 12.03V3.602C2 3.269 2.274 3 2.613 3h5.515v1.204H3.226v7.223h4.902v1.203H2.613zM5.677 9.02V6.611h4.903V4.926a.301.301 0 0 1 .19-.274.31.31 0 0 1 .33.063l2.722 2.673a.594.594 0 0 1 0 .849L11.1 10.909a.31.31 0 0 1-.331.063.301.301 0 0 1-.19-.274V9.02H5.677z" /></svg><span>Sign Out</span></a></li></ul></div></li></ul></nav></header>



      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="ch04.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Beginning Lua Programming
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="ch04.html#" title="Search in archive" class="js-search-controls search-controls" onclick="window.Appcues.track('SearchBook_HeronBook')"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9780470069172/chapter/ch04.html"><div class="js-collections-dropdown collections-dropdown menu-bit-cards" onclick="window.Appcues.track('AddPlaylist_HeronBook')"></div></div></li><li class="js-font-control-panel font-control-activator"><a href="ch04.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size" onclick="window.Appcues.track('ChangeFont_HeronBook')"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="ch04.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share" onclick="window.Appcues.track('Share_HeronBook')"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a
        class="twitter share-button t-twitter"
        target="_blank"
        aria-label="Share this section on Twitter"
        title="Share this section on Twitter"
      
        href="https://twitter.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch04.html&text=Beginning%20Lua%20Programming&via=OReillyMedia"
      ><span>Twitter</span></a></li><li><a
        class="facebook share-button t-facebook"
        target="_blank"
        aria-label="Share this section on Facebook"
        title="Share this section on Facebook"
        href="https://www.facebook.com/sharer/sharer.php?u=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch04.html"
      ><span>Facebook</span></a></li><li><a
        class="googleplus share-button t-googleplus"
        target="_blank"
        aria-label="Share this secton on Google Plus"
        title="Share this secton on Google Plus"
        href="https://plus.google.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch04.html"
      ><span>Google Plus</span></a></li><li><a
        class="email share-button t-email"
        aria-label="Share this section via email"
        title="Share this section via email"
      
        href="mailto:?subject=Safari: 4.%20Working%20with%20Tables&body=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch04.html%0D%0Afrom Beginning%20Lua%20Programming%0D%0A"
      ><span>Email</span></a></li></ul></li><!-- endif request.user.is_authenticated -->
      </ul>
    </div>

      
          
      

    <section role="document">
        
        




  <script defer src="https://learning.oreilly.com/static/js/build/djangoMessagesPage.bfaca9fd8619.js"></script>


        <script src="https://fast.appcues.com/48743.js"></script>
<script>
  var userId = "ce47de5b-ce80-49f0-b5cd-c60d3d33b198";

  var userObject = {
    firstName: "Michael",
    segment: "Trial",
    admin: "False",
    profileCreatedOn: "2021-05-13",
    academic: ""
  };
  window.Appcues.identify(userId, userObject);
  window.Appcues.page();

  setTimeout(function () {
    window.Appcues.track('ViewingBook_HeronBook')
  }, 20000);
</script>


	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="ch03.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">3. Extending Lua with Functions</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="ch05.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">5. Using Strings</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="working_with_tables"></a>Chapter 4. Working with Tables</h1></div></div></div><p>This chapter explores a new data type called a <span class="emphasis"><em>table</em></span>. It's a <span class="emphasis"><em>data structure</em></span>, which means that it lets you combine other values. Because of its flexibility, it is Lua's only data structure. (It is possible to create other, special-purpose data structures in C.)<a id="IDX-CHP-4-0001" class="indexterm"></a><a id="IDX-CHP-4-0002" class="indexterm"></a><a id="IDX-CHP-4-0003" class="indexterm"></a></p><p>In this chapter, you learn how to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Create and modify tables</p></li><li class="listitem"><p>Loop through the elements of tables</p></li><li class="listitem"><p>Use Lua's built-in table library</p></li><li class="listitem"><p>Write programs in an object-oriented style</p></li><li class="listitem"><p>Write functions that take variable numbers of arguments</p></li></ul></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="tables_introduced"></a>Tables Introduced</h1></div></div></div><p>The following example creates a table and assigns it to the variable <code class="literal">NameToInstr</code>, and then looks around inside the table:</p><pre class="programlisting">&gt; <strong class="userinput"><code>NameToInstr = {["John"] = "rhythm guitar",</code></strong>
&gt;&gt;   <strong class="userinput"><code>["Paul"] = "bass guitar",</code></strong>
&gt;&gt;   <strong class="userinput"><code>["George"] = "lead guitar",</code></strong>
&gt;&gt;   <strong class="userinput"><code>["Ringo"] = "drumkit"}</code></strong>
&gt; <strong class="userinput"><code>print(NameToInstr["Paul"])</code></strong>
bass guitar
&gt; <strong class="userinput"><code>A = "Ringo"</code></strong>
&gt; <strong class="userinput"><code>print(NameToInstr[A])</code></strong>
drumkit
&gt; <strong class="userinput"><code>print(NameToInstr["Mick"])</code></strong>
nil</pre><p>A table is a collection of <span class="emphasis"><em>key-value pairs</em></span>. In this example, the expression that starts and ends with <code class="literal">{</code> and <code class="literal">}</code> (curly braces) is a <span class="emphasis"><em>table constructor</em></span> that creates a table that associates the key <code class="literal">"John"</code> with the value <code class="literal">"rhythm guitar"</code>, the key <code class="literal">"Paul"</code> with the value <code class="literal">"bass guitar"</code>, and so on. Each key is surrounded in <code class="literal">[</code> and <code class="literal">]</code> (square brackets) and is separated from its value by an equal sign. The key-value pairs are separated from each other by commas.<a id="IDX-CHP-4-0004" class="indexterm"></a><a id="IDX-CHP-4-0005" class="indexterm"></a><a id="IDX-CHP-4-0006" class="indexterm"></a></p><p>After the table is created and assigned to <code class="literal">NameToInstr</code>, square brackets are used to retrieve the values for particular keys. When <code class="literal">NameToInstr["Paul"]</code> is evaluated, the result is <code class="literal">"bass guitar"</code>, which is the value associated with the key <code class="literal">"Paul"</code> in the <code class="literal">NameToInstr</code> table.</p><div class="blockquote"><blockquote class="blockquote"><p>The term "value" is used here to mean "the second half of a key-value pair." Both this sense and the broader sense used in <a class="link" href="ch02.html" title="Chapter 2. First Steps">Chapters 2</a> and <a class="link" href="ch03.html" title="Chapter 3. Extending Lua with Functions">3</a> are used in this chapter; which sense is intended should be clear from the context. A "key" is a value in the broader (but not the narrower) sense.</p></blockquote></div><p>As the line with <code class="literal">NameToInstr[A]</code> shows, the expression in between the square brackets doesn't have to be a literal string. Here it is a variable, but it can be any expression. (This also applies to the square brackets inside table constructors—if an expression inside square brackets is a function call, it is adjusted to one value.)</p><p>If you ask a table for the value of a key it doesn't contain, it gives you <code class="literal">nil</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(NameToInstr["Mick"])</code></strong>
nil</pre><p>This means that <code class="literal">nil</code> cannot be a value in a table. Another way of saying this is that there is no difference between a key not existing in a table, and that key existing but having <code class="literal">nil</code> as its value. Keys cannot be <code class="literal">nil</code>, although if the value of a <code class="literal">nil</code> key is asked for, the result will be <code class="literal">nil</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Tbl = {}</code></strong>
&gt; <strong class="userinput"><code>print(Tbl[nil])</code></strong>
nil</pre><p>Both keys and values can be any type other than <code class="literal">nil</code>. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {[print] = "The print function",</code></strong>
&gt;&gt;  <strong class="userinput"><code>["print"] = print,</code></strong>
&gt;&gt;  <strong class="userinput"><code>[0.1] = 0.2}</code></strong>
&gt; <strong class="userinput"><code>print(T[print]) -- Function key, string value.</code></strong>
The print function
&gt; <strong class="userinput"><code>print(T["print"]) -- String key, function value.</code></strong>
function: 0x481720
&gt; <strong class="userinput"><code>print(T[0.1]) -- Number key, number value.</code></strong>
0.2</pre><p>The association between a key and a value is one-way. <code class="literal">NameToInstr["Ringo"]</code> is <code class="literal">"drumkit"</code>, but <code class="literal">NameToInstr["drumkit"]</code> is <code class="literal">nil</code>. A given value can be associated with multiple keys, but a given key can only have one value at a time. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {["a"] = "duplicate value",</code></strong>
&gt;&gt;  <strong class="userinput"><code>["b"] = "duplicate value",</code></strong>
&gt;&gt;  <strong class="userinput"><code>["duplicate key"] = "y",</code></strong></pre><pre class="programlisting">&gt;&gt;  <strong class="userinput"><code>["duplicate key"] = "z"}</code></strong>
&gt; <strong class="userinput"><code>print(T["a"])</code></strong>
duplicate value
&gt; <strong class="userinput"><code>print(T["b"])</code></strong>
duplicate value
&gt; <strong class="userinput"><code>print(T["duplicate key"])</code></strong>
z</pre><p>Keys follow the same equality rules as other values, so (in the following example, <code class="literal">1</code> and <code class="literal">"1"</code> are two distinct keys:<a id="IDX-CHP-4-0007" class="indexterm"></a><a id="IDX-CHP-4-0008" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {[1] = "number", ["1"] = "string"}</code></strong>
&gt; <strong class="userinput"><code>print(T[1], T["1"])</code></strong>
number string</pre></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="a_shorter_way_to_write_some_keys"></a>A Shorter Way to Write Some Keys</h1></div></div></div><p>A key is often called an <span class="emphasis"><em>index</em></span> to a table, and accessing a key's value (like <code class="literal">T[X]</code>) is called <span class="emphasis"><em>indexing</em></span> the table.</p><div class="blockquote"><blockquote class="blockquote"><p>The word "index" has other uses too. For example, getting the nth character of a string is "indexing" that string, and a loop variable, particularly one with an integer value, can be called an index (which is why some of the loop variables in this book are named <code class="literal">I</code>).</p></blockquote></div><p>The value of a particular index of a particular table is often called a <span class="emphasis"><em>field</em></span>, and the index itself is called a <span class="emphasis"><em>field name</em></span>. This terminology is used especially when the field name is a valid identifier. If a field name is a valid identifier, you can use it in a table constructor without the square brackets or quotes. The following is another way to write the constructor for <code class="literal">NameToInstr</code>:</p><pre class="programlisting">NameToInstr = {John = "rhythm guitar",
      Paul = "bass guitar",
      George = "lead guitar",
      Ringo = "drumkit"}</pre><p>That doesn't work with any of the following tables, because none of the keys are valid identifiers (notice that the error messages are different, because the keys are invalid identifiers for different reasons):</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {1st = "test"}</code></strong>
stdin:1: malformed number near '1st'
&gt; <strong class="userinput"><code>T = {two words = "test"}</code></strong>
stdin:1: '}' expected near 'words'
&gt; <strong class="userinput"><code>T = {and = "test"}</code></strong>
stdin:1: unexpected symbol near 'and'</pre><p>You can also access fields in an existing table (if the field names are valid identifiers) by using <code class="literal">.</code> (a dot) instead of square brackets and quotes, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(NameToInstr.George)</code></strong>
lead guitar</pre><p>You can index a table within a table in one step, as follows:<a id="IDX-CHP-4-0009" class="indexterm"></a><a id="IDX-CHP-4-0010" class="indexterm"></a><a id="IDX-CHP-4-0011" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Tbl1 = {Tbl2 = {Bool = true}}</code></strong>
&gt; <strong class="userinput"><code>print(Tbl1.Tbl2.Bool)</code></strong>
true
&gt; <strong class="userinput"><code>print(Tbl1["Tbl2"].Bool)</code></strong>
true
&gt; <strong class="userinput"><code>print(Tbl1.Tbl2["Bool"])</code></strong>
true
&gt; <strong class="userinput"><code>print(Tbl1["Tbl2"]["Bool"])</code></strong>
true</pre><p>This works for tables within tables within tables, as deep as you want to go. If there are enough nested tables, then <code class="literal">Tbl.Think.Thank.Thunk.Thenk.Thonk</code> is perfectly valid.</p><p>Don't let the flexibility of tables and the variety of methods for accessing them confuse you. In particular, remember that <code class="literal">NameToInstr["John"]</code> and <code class="literal">NameToInstr.John</code> both mean "get the value for the <code class="literal">"John"</code> key," and <code class="literal">NameToInstr[John]</code> means "get the value for whatever key is in the variable <code class="literal">John</code>." If you find yourself getting a <code class="literal">nil</code> when you don't expect to, make sure you're not mixing these up.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="altering_a_table_apostrophy_s_contents"></a>Altering a Table's Contents</h1></div></div></div><p>After you create a table, you can modify or remove the values already in it, and you can add new values to it. You do these things with the assignment statement.</p><div class="sidebar"><a id="try_it_out_colon_assigning_to_table_inde"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Assigning to Table Indexes</strong></p></div></div></div><p>Type the following into the Lua interpreter:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Potluck = {John = "chips", Jane = "lemonade",</code></strong>
&gt;&gt; <strong class="userinput"><code>Jolene = "egg salad"}</code></strong>
&gt; <strong class="userinput"><code>Potluck.Jolene = "fruit salad" -- A change.</code></strong>
&gt; <strong class="userinput"><code>Potluck.Jayesh = "lettuce wraps" -- An addition.</code></strong>
&gt; <strong class="userinput"><code>Potluck.John = nil -- A removal.</code></strong>
&gt; <strong class="userinput"><code>print(Potluck.John, Potluck.Jane, Potluck.Jolene,</code></strong>
&gt;&gt;   <strong class="userinput"><code>Potluck.Jayesh)</code></strong></pre><p>Here's the result:</p><pre class="programlisting">nil  lemonade  fruit salad  lettuce wraps</pre><p><span class="strong"><strong>How It Works</strong></span></p><p>In this exercise, you create a table with three people and their foods. You then use assignment to change one person's food, to add a new person-food pair to the table, and to remove an existing person-food pair.</p><p><code class="literal">Potluck.Jolene = "fruit salad"</code> overwrites the previous value of <code class="literal">Potluck.Jolene</code> (<code class="literal">"egg salad"</code>).</p><p><code class="literal">Potluck.Jayesh = "lettuce wraps"</code> adds a new key (and its value) to the table. The value of <code class="literal">Potluck.Jayesh</code> before this line would have been <code class="literal">nil</code>.</p><p><code class="literal">Potluck.John = nil</code> overwrites the previous value of <code class="literal">Potluck.John</code> with <code class="literal">nil</code>. This is another way of saying that it removes the key <code class="literal">"John"</code> from the table (because there's no difference between a <code class="literal">nil</code>-valued key and a nonexistent key).<a id="IDX-CHP-4-0012" class="indexterm"></a><a id="IDX-CHP-4-0013" class="indexterm"></a></p><p>Notice that, except in the line with the table constructor, the variable <code class="literal">Potluck</code> is never assigned to. Rather, individual fields of the table in <code class="literal">Potluck</code> are being assigned to. This is called <span class="emphasis"><em>indexing assignment</em></span>.</p><div class="blockquote"><blockquote class="blockquote"><p>The Lua reference manual actually calls table fields a third type of variable (after globals and locals). This usage makes some things clearer, but it isn't widespread, so it isn't followed in this book.<a id="IDX-CHP-4-0014" class="indexterm"></a></p></blockquote></div></div><p>Often the most convenient way to populate a table is to start with an empty table and add things to it one at a time. Here's an example of creating a table of the first five perfect squares and then printing it:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Squares = {}</code></strong> -- A table constructor can be empty.
&gt; <strong class="userinput"><code>for I = 1, 5 do</code></strong>
&gt;&gt;   <strong class="userinput"><code>Squares[I] = I ^ 2</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>for I = 1, 5 do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(I .. " squared is " .. Squares[I])</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
1 squared is 1
2 squared is 4
3 squared is 9
4 squared is 16
5 squared is 25</pre><p>You can assign to nested tables in one step, as in <code class="literal">Tbl.Think[Thank].Thunk = true</code>.</p><p>Here are a couple of other table constructor tidbits. You can optionally follow the final value in a table constructor by a comma: <code class="literal">{A = 1, B = 2, C = 3,}</code>. This is convenient for automatically generated table constructors, and for frequently edited ones (so you don't have to always make sure to delete a comma if a value becomes the last one). And instead of commas, you can use semicolons (or a mixture of commas and semicolons): <code class="literal">{A = 1; B = 2; C = 3}</code>.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="tables_as_arrays"></a>Tables as Arrays</h1></div></div></div><p>It's common for the keys of a table to be consecutive integers, starting at <code class="literal">1</code>. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Months = {[1] = "January", [2] = "February", [3] = "March",</code></strong>
&gt;&gt;   <strong class="userinput"><code>[4] = "April", [5] = "May", [6] = "June", [7] = "July",</code></strong>
&gt;&gt;   <strong class="userinput"><code>[8] = "August", [9] = "September", [10] = "October",</code></strong>
&gt;&gt;   <strong class="userinput"><code>[11] = "November", [12] = "December"}</code></strong>
&gt; <strong class="userinput"><code>print(Months[11])</code></strong>
November</pre><p>A table used in this way is sometimes called an <span class="emphasis"><em>array</em></span> (or a <span class="emphasis"><em>list</em></span>). To emphasize that a table is <span class="emphasis"><em>not</em></span> being used as an array, it can be called an <span class="emphasis"><em>associative table</em></span>.<a id="IDX-CHP-4-0015" class="indexterm"></a><a id="IDX-CHP-4-0016" class="indexterm"></a></p><p>You can write table constructors that build arrays in a more concise, less error-prone way that doesn't require writing out each integer key. For example:<a id="IDX-CHP-4-0017" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Months = {"January", "February", "March", "April", "May",</code></strong>
&gt;&gt;   <strong class="userinput"><code>"June", "July", "August", "September", "October",</code></strong>
&gt;&gt;   <strong class="userinput"><code>"November", "December"}</code></strong>
&gt; <strong class="userinput"><code>print(Months[11])</code></strong>
November</pre><p>Inside a table constructor, the first value that doesn't have a key (and an equal sign) in front of it is associated with the key <code class="literal">1</code>. Any subsequent such values are given a key one higher than that given to the previous such value. This rule applies even if key-value pairs with equal signs are intermixed, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {A = "x", "one", B = "y", "two", C = "z", "three"}</code></strong>
&gt; <strong class="userinput"><code>print(T[1], T[2], T[3])</code></strong>
one  two  three</pre><p>Usually this sort of mixed table constructor is easier to read if the consecutive-integer values are all together and the other key-value pairs are all together.</p><p>If a function call is used as the value of an explicit key (<code class="literal">{K = F()}</code>, for example), it's adjusted to one return value. If it's used as the value of an implicit integer key, it's only adjusted to one return value if it's not the last thing in the table constructor; if it is the last thing, no adjustment is made:</p><pre class="programlisting">&gt; <strong class="userinput"><code>function ReturnNothing()</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>function ReturnThreeVals()</code></strong>
&gt;&gt;   <strong class="userinput"><code>return "x", "y", "z"</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>TblA = {ReturnThreeVals(), ReturnThreeVals()}</code></strong>
&gt; <strong class="userinput"><code>print(TblA[1], TblA[2], TblA[3], TblA[4])</code></strong>
x       x       y       z
&gt; <strong class="userinput"><code>TblB = {ReturnNothing(), ReturnThreeVals()}</code></strong>
&gt; <strong class="userinput"><code>-- The following nil is the result of adjustment:</code></strong>
&gt; <strong class="userinput"><code>print(TblB[1], TblB[2], TblB[3], TblB[4])</code></strong>
nil     x       y       z
&gt; <strong class="userinput"><code>TblC = {ReturnThreeVals(), ReturnNothing()}</code></strong>
&gt; <strong class="userinput"><code>-- The following three nils are not the result of adjustment;</code></strong>
&gt; <strong class="userinput"><code>-- they're there because TblC[2] through TblC[4] were not</code></strong>
&gt; <strong class="userinput"><code>-- given values in the constructor:</code></strong>
&gt; <strong class="userinput"><code>print(TblC[1], TblC[2], TblC[3], TblC[4])</code></strong>
x       nil     nil     nil
&gt; <strong class="userinput"><code>TblD = {ReturnNothing(), ReturnNothing()}</code></strong>
&gt; <strong class="userinput"><code>-- The first nil that follows is the result of adjustment; the</code></strong>
&gt; <strong class="userinput"><code>-- second is there because TblD[2] was not given a value</code></strong>
&gt; <strong class="userinput"><code>-- in the constructor:</code></strong>
&gt; <strong class="userinput"><code>print(TblD[1], TblD[2])</code></strong>
nil     nil</pre></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="array_length"></a>Array Length</h1></div></div></div><p>The <code class="literal">#</code> (length) operator can be used to measure the length of an array. Normally, this number is also the index of the last element in the array, as in the following example:<a id="IDX-CHP-4-0018" class="indexterm"></a><a id="IDX-CHP-4-0019" class="indexterm"></a><a id="IDX-CHP-4-0020" class="indexterm"></a><a id="IDX-CHP-4-0021" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Empty = {}</code></strong>
&gt; <strong class="userinput"><code>One = {"a"}</code></strong>
&gt; <strong class="userinput"><code>Three = {"a", "b", "c"}</code></strong>
&gt; <strong class="userinput"><code>print(#Empty, #One, #Three)</code></strong>
0       1       3</pre><p>Apart from arrays with gaps (discussed shortly), the length operator gives the same result whether a table got the way it is purely because of its constructor (as previously shown) or because of assignments made to it after it was created like this:<a id="IDX-CHP-4-0022" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Empty = {"Delete me!"}</code></strong>
&gt; <strong class="userinput"><code>Empty[1] = nil</code></strong>
&gt; <strong class="userinput"><code>Three = {"a"}</code></strong>
&gt; <strong class="userinput"><code>Three[2], Three[3] = "b", "c"</code></strong>
&gt; <strong class="userinput"><code>print(#Empty, #Three)</code></strong>
0       3</pre><p>It also doesn't matter whether the constructor uses implicit or explicit integer indexing, as shown here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(#{[1] = "a", [2] = "b"})</code></strong>
2</pre><p>Noninteger indexes (or nonpositive integer indexes, for that matter) do not count—the length operator measures the length of a table as an array as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Two = {"a", "b", Ignored = true, [0.5] = true}</code></strong>
&gt; <strong class="userinput"><code>print(#Two)</code></strong>
2</pre><p>An array is said to have a <span class="emphasis"><em>gap</em></span> if there are is a <code class="literal">nil</code> somewhere between element <code class="literal">1</code> and the highest positive integer element with a value that is not <code class="literal">nil</code>. Here is an example of a gap in an array:</p><pre class="programlisting">T1 = {nil, "b", "c"} -- Gap between beginning and
     -- element 2.
T2 = {"a", "b", nil, nil, "e"} -- Gap between element 2 and
     -- element 5.
T3 = {"a", "b", "c", nil} -- No gap! (Element 3 is the last
     -- element in the array.)</pre><p>Arrays with gaps cause the length operator to behave unpredictably. The only thing you can be sure of is that it will always return the index of a non-<code class="literal">nil</code> value that is followed by a <code class="literal">nil</code>, or possibly <code class="literal">0</code> if element <code class="literal">1</code> of the array is <code class="literal">nil</code>. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {"a", "b", "c", nil, "e"}</code></strong>
&gt; <strong class="userinput"><code>print(#T)</code></strong>
5</pre><pre class="programlisting">&gt; <strong class="userinput"><code>-- Equivalent table; different result:</code></strong>
&gt; <strong class="userinput"><code>T = {}</code></strong>
&gt; <strong class="userinput"><code>T[1], T[2], T[3], T[4], T[5] = "a", "b", "c", nil, "e"</code></strong>
&gt; <strong class="userinput"><code>print(#T)</code></strong>
3</pre><p>For this reason, it's generally a good idea to avoid having gaps in your arrays. However, an array is just a table used in a certain way, not a separate datatype, so this warning about avoiding gaps only applies if you're planning to use a table as an array. This means there's nothing wrong with the following table:<a id="IDX-CHP-4-0023" class="indexterm"></a><a id="IDX-CHP-4-0024" class="indexterm"></a></p><pre class="programlisting">-- Considered as an array, this would have gaps, but it's
-- obviously intended as an associative table:
AustenEvents = {[1775] = "born",
  [1811] = "Sense and Sensibility published",
  [1813] = "Pride and Prejudice published",
  [1814] = "Mansfield Park published",
  [1816] = "Emma published",
  [1817] = "died",
  [1818] = "Northanger Abbey and Persuasion published"}</pre><div class="blockquote"><blockquote class="blockquote"><p>You can define <code class="literal">#</code> operator to always give either the first element followed by <code class="literal">nil</code> or the last, but both of these approaches require searches through the table much more time-consuming than the way that <code class="literal">#</code> actually works.</p><p>Lua 5.0 dealt with array length differently. In addition to the nonexistence of the <code class="literal">#</code> operator, the main differences were that the functions <code class="literal">table.getn</code> and <code class="literal">table.setn</code> were used to get and set the length of an array, and a table's <code class="literal">"n"</code> field could be used to store its array length.</p></blockquote></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="looping_through_tables"></a>Looping through Tables</h1></div></div></div><p>Printing a table gives similar results to printing a function:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print({})</code></strong>
table: 0x493bc0</pre><p>This means that to see what's inside a table, you need to look at each key-value pair in turn. In the previous <code class="literal">Squares</code> example, this was done with a <code class="literal">for</code> loop hardcoded to run to <code class="literal">5</code> (the length of <code class="literal">Squares</code>). You could improve this by using the <code class="literal">#</code> operator, so that if the array's length is changed, you only need to it in one place:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Squares = {}</code></strong>
&gt; <strong class="userinput"><code>for I = 1, 5 do</code></strong>
&gt;&gt;   <strong class="userinput"><code>Squares[I] = I ^ 2</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>for I = 1, #Squares do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(I .. " squared is " .. Squares[I])</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
1 squared is 1
2 squared is 4
3 squared is 9
4 squared is 16
5 squared is 25</pre><p>This is better, but there's an even better way to loop through an array, as you'll see in the following Try It Out.</p><div class="sidebar"><a id="try_it_out_colon_using_ipairs_to_loop_th"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Using ipairs to Loop through an Array</strong></p></div></div></div><p>Type the following into the interpreter. The first of the two loops is the <code class="literal">for</code> loop you already know from <a class="link" href="ch02.html" title="Chapter 2. First Steps">Chapter 2</a>. The second is still a <code class="literal">for</code> loop, but it looks and works a bit differently.</p><pre class="programlisting">&gt; <strong class="userinput"><code>Squares = {}</code></strong>
&gt; <strong class="userinput"><code>for I = 1, 5 do</code></strong>
&gt;&gt;   <strong class="userinput"><code>Squares[I] = I ^ 2</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>for I, Square in ipairs(Squares) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(I .. " squared is " .. Square)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
1 squared is 1
2 squared is 4
3 squared is 9
4 squared is 16
5 squared is 25</pre><p><span class="strong"><strong>How It Works</strong></span></p><p>The first <code class="literal">for</code> loop in this example loops through a series of numbers. The second one is a new type of <code class="literal">for</code> loop that loops (in this case) through an array. It's called the <span class="emphasis"><em>generic</em></span> <code class="literal">for</code> loop because, as you will see soon, it is able to iterate through anything at all (including tables that aren't arrays and even things other than tables). The <code class="literal">for</code> loop you learned about in <a class="link" href="ch02.html" title="Chapter 2. First Steps">Chapter 2</a> is called the <span class="emphasis"><em>numeric</em></span> <code class="literal">for</code> loop. You can tell the difference between them because the generic <code class="literal">for</code> will always include the keyword <code class="literal">in</code>.</p><p>The thing that makes this example's generic <code class="literal">for</code> treat <code class="literal">Squares</code> as an array is the use of the function <code class="literal">ipairs</code> in the line:</p><pre class="programlisting">for I, Square in ipairs(Squares) do</pre><p>This line means "loop (in order) through each key-value pair in the array <code class="literal">Squares</code>, assigning the key and value to (respectively) the loop variables <code class="literal">I</code> and <code class="literal">Square</code>." To write your own similar loop, replace <code class="literal">Squares</code> with the array you want to loop through, and replace <code class="literal">I</code> and <code class="literal">Square</code> with the names you want to give to its keys and values. (As you'll soon see, <code class="literal">ipairs</code> can be replaced when you don't want to treat the thing being looped through as an array.)</p><p><code class="literal">Squares</code> itself never needs to be indexed in the body of the loop, because <code class="literal">Square</code> is available.</p></div><p>If you use a generic <code class="literal">for</code> loop with <code class="literal">ipairs</code> to loop through an array that has gaps, it will stop when it reaches the first gap, as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>for Number, Word in ipairs({"one", "two", nil, "four"}) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(Number, Word)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
1  one
2  two</pre><p>That means that, if an array has gaps, looping through it with a generic <code class="literal">for</code> and <code class="literal">ipairs</code> will not necessarily give the same results as looping through it with a numeric <code class="literal">for</code> whose end value is the length of the array.</p><p>A generic <code class="literal">for</code> loop that uses <code class="literal">ipairs</code> after the <code class="literal">in</code> keyword is often called an <span class="emphasis"><em>ipairs loop</em></span> for short. If <code class="literal">pairs</code> is used instead of <code class="literal">ipairs</code>, then all key-value pairs, not just the array ones, are looped through.</p><p>A <code class="literal">pairs</code> loop has the same form as an <code class="literal">ipairs</code> loop:</p><pre class="programlisting">for Key, Val in ipairs(Tbl) do

for Key, Val in pairs(Tbl) do</pre><p>Try this <code class="literal">pairs</code> loop:</p><pre class="programlisting">&gt; <strong class="userinput"><code>NameToInstr = {John = "rhythm guitar",</code></strong>
&gt;&gt;   <strong class="userinput"><code>Paul = "bass guitar",</code></strong>
&gt;&gt;   <strong class="userinput"><code>George = "lead guitar",</code></strong>
&gt;&gt;   <strong class="userinput"><code>Ringo = "drumkit"}</code></strong>
&gt; <strong class="userinput"><code>for Name, Instr in pairs(NameToInstr) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(Name .. " played " .. Instr)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
Ringo played drumkit
George played lead guitar
John played rhythm guitar
Paul played bass guitar</pre><p>This is similar to an <code class="literal">ipairs</code> loop in that on each iteration, the first loop variable (<code class="literal">Name</code>) is set to a key in the table given to <code class="literal">pairs</code>, and the second loop variable (<code class="literal">Instr</code>) is set to that key's value. One difference is that the first value no longer has to be a positive integer (although it could be, if there happened to be any positive integer keys in <code class="literal">NameToInstr</code>).</p><p>The second difference is that the key-value pairs are looped through <span class="emphasis"><em>in an arbitrary order</em></span>. The order in which pairs occur in the table constructor does not matter. Nor is there any significance to the order in which keys are added or removed after a table is constructed. The only guarantee is that each pair will be visited once and only once. Tables in general have no intrinsic order (other than the arbitrary order shown by a <code class="literal">pairs</code> loop). Even the order shown by an <code class="literal">ipairs</code> loop is only a result of adding <code class="literal">1</code> to each index to get the next one. <code class="literal">pairs</code> often visits integer keys all together and in the correct order, but it's not guaranteed to do so. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {A = "a", B = "b", C = "c"}</code></strong>
&gt; <strong class="userinput"><code>T[1], T[2], T[3] = "one", "two", "three"</code></strong>
&gt; <strong class="userinput"><code>for K, V in pairs(T) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(K, V)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
A  a
1  one
C  c
B  b
3  three
2  two</pre><div class="blockquote"><blockquote class="blockquote"><p>Both <code class="literal">ipairs</code> loops and <code class="literal">pairs</code> loops have the property that neither loop variable is ever <code class="literal">nil</code>. (This can be deduced from what has been said about <code class="literal">nil</code> keys and <code class="literal">nil</code> values.)</p></blockquote></div><p>Like the loop variable in a numeric <code class="literal">for</code>, the loop variables in a generic <code class="literal">for</code> are local to each iteration. They can be assigned to, although because of their limited scope, there's seldom a reason to do this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {Gleep = true, Glarg = false}</code></strong>
&gt; <strong class="userinput"><code>for Fuzzy, Wuzzy in pairs(T) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>Fuzzy, Wuzzy = Fuzzy .. "ing", #tostring(Wuzzy)</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(Fuzzy, Wuzzy)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
Gleeping  4
Glarging  5
&gt; <strong class="userinput"><code>-- The table itself is unchanged:</code></strong>
&gt; <strong class="userinput"><code>print(T.Gleep, T.Glarg)</code></strong>
true false
&gt; <strong class="userinput"><code>print(T.Gleeping, T.Glarging)</code></strong>
nil     nil</pre><p>Because the assignments are made to the loop variables, and not to fields in the table itself, they do not alter the table's contents. If you do want to alter the table's contents, do an indexing assignment on the table itself, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {"apple", "banana", "kiwi"}</code></strong>
&gt; <strong class="userinput"><code>for I, Fruit in ipairs(T) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>T[I] = Fruit .. "s"</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>print(T[2])</code></strong>
bananas</pre><p>Adding a previously nonexistent key to a table while looping over it with <code class="literal">pairs</code> has undefined results. If you need to do this, save a list of the changes you need to make in another table and apply them after the loop is over. You can remove a key (by setting its value to <code class="literal">nil</code>) and change a key's value during a <code class="literal">pairs</code> loop.</p><p>You can use loop variables as upvalues to closures. As shown in the previous chapter (with a numeric <code class="literal">for</code>), each iteration means a new upvalue:</p><pre class="programlisting">&gt; -- <strong class="userinput"><code>A table that maps numbers to their English names:</code></strong>
&gt; <strong class="userinput"><code>Numbers = {"one", "two", "three"}</code></strong>
&gt; <strong class="userinput"><code>-- A table that will contain functions:</code></strong>
&gt; <strong class="userinput"><code>PrependNumber = {}</code></strong>
&gt; <strong class="userinput"><code>for Num, NumName in ipairs(Numbers) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>-- Add a function to PrependNumber that prepends NumName</code></strong>
&gt;&gt;   <strong class="userinput"><code>-- to its argument:</code></strong>
&gt;&gt; <strong class="userinput"><code>PrependNumber[Num] = function(Str)</code></strong>
&gt;&gt;  <strong class="userinput"><code>return NumName .. ": " .. Str</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>-- Call the second and third functions in PrependNumber:</code></strong>
&gt; <strong class="userinput"><code>print(PrependNumber[2]("is company"))</code></strong>
two: is company
&gt; <strong class="userinput"><code>print(PrependNumber[3]("is a crowd"))</code></strong>
three: is a crowd</pre><p>In this example, each time the loop iterates, a new function is created that <span class="emphasis"><em>prepends</em></span> (appends to the front) a spelled-out number name to its argument and returns the result. These functions are placed, by number, into the <code class="literal">PrependNumber</code> table, so that when, for example, <code class="literal">PrependNumber[2]</code> is called, it prepends <code class="literal">"two: "</code> to its argument.<a id="IDX-CHP-4-0025" class="indexterm"></a><a id="IDX-CHP-4-0026" class="indexterm"></a><a id="IDX-CHP-4-0027" class="indexterm"></a><a id="IDX-CHP-4-0028" class="indexterm"></a><a id="IDX-CHP-4-0029" class="indexterm"></a></p><div class="blockquote"><blockquote class="blockquote"><p>The notes about Lua 5.0's numeric <code class="literal">for</code> in the previous chapter also apply to the generic <code class="literal">for</code>. Assigning to the first (that is, leftmost) loop variable has undefined results, and the scope of the loop variables extends over the entire loop (not each individual iteration). This means that if you tried the <code class="literal">PrependNumber</code> example on Lua 5.0, you would get "<code class="literal">attempt to concatenate a nil value</code>" errors because both loop variables are set to <code class="literal">nil</code> when the end of the table is reached.</p></blockquote></div><p>To loop through a table in a way not supported by either <code class="literal">ipairs</code> or <code class="literal">pairs</code>, use either <code class="literal">while</code> or the numeric <code class="literal">for</code> (along with some extra bookkeeping), or structure your data differently. An example of the latter is the following loop, which is a rewrite of the earlier <code class="literal">pairs</code> loop through <code class="literal">NameToInstr</code> that goes in the order specified by the table (it also serves as an example of tables within tables):</p><pre class="programlisting">&gt; <strong class="userinput"><code>NamesAndInstrs = {</code></strong>
&gt;&gt;   <strong class="userinput"><code>{Name = "<sup>John</sup>", Instr = "rhythm guitar"},</code></strong>
&gt;&gt;   <strong class="userinput"><code>{Name = "Paul", Instr = "bass guitar"},</code></strong>
&gt;&gt;   <strong class="userinput"><code>{Name = "George", Instr = "lead guitar"},</code></strong>
&gt;&gt;   <strong class="userinput"><code>{Name = "Ringo", Instr = "drumkit"}}</code></strong>
&gt; <strong class="userinput"><code>for _, NameInstr in ipairs(NamesAndInstrs) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(NameInstr.Name .. " played " .. NameInstr.Instr)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
John played rhythm guitar
Paul played bass guitar
George played lead guitar
Ringo played drumkit</pre><p>Yet another option is to write your own function to use instead of <code class="literal">ipairs</code> or <code class="literal">pairs</code>. This is covered later in this chapter.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="tables_of_functions"></a>Tables of Functions</h1></div></div></div><p>Using tables that contain functions is a handy way to organize functions, and Lua keeps many of its built-in functions in tables, indexed by strings. For example, the table found in the global variable <code class="literal">table</code> contains functions useful for working with tables. If you assign another value to <code class="literal">table</code>, or to one of the other global variables used to store built-in functions, the functions won't be available anymore unless you put them somewhere else beforehand. If you do this accidentally, just restart the interpreter.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="the_table_library"></a>The Table Library</h2></div></div></div><p>The functions contained in <code class="literal">table</code> are known collectively as the <span class="emphasis"><em>table library</em></span>.<a id="IDX-CHP-4-0030" class="indexterm"></a></p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="table.sort"></a>table.sort</h3></div></div></div><p>One function in the table library is <code class="literal">table.sort</code>. Here is an example of how you use this function:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Names = {"Scarlatti", "Telemann", "Corelli", "Purcell",</code></strong>
&gt;&gt;   <strong class="userinput"><code>"Vivaldi", "Handel", "Bach"}</code></strong></pre><pre class="programlisting">&gt; <strong class="userinput"><code>table.sort(Names)</code></strong>
&gt; <strong class="userinput"><code>for I, Name in ipairs(Names) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(I, Name)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
1  Bach
2  Corelli
3  Handel
4  Purcell
5  Scarlatti
6  Telemann
7  Vivaldi</pre><p>The <code class="literal">table.sort</code> function takes an array and sorts it <span class="emphasis"><em>in place</em></span>. This means that, rather than returning a new array that's a sorted version of the one given to it, <code class="literal">table.sort</code> uses indexing assignment (a side effect) on the given array itself to move its values to different keys. (See <a class="link" href="ch03.html" title="Chapter 3. Extending Lua with Functions">Chapter 3</a> for an explanation of side effects.)</p><p><code class="literal">table.sort</code> uses the <code class="literal">&lt;</code> operator to decide whether an element of the array should come before another element. To override this behavior, give a <span class="emphasis"><em>comparison function</em></span> as a second argument to <code class="literal">table.sort</code>. A comparison function takes two arguments and returns a true result if and only if its first argument should come before its second argument.</p><p><code class="literal">table.sort</code> only looks at a table as an array. It ignores any noninteger keys and any integer keys less than 1 or greater than the table's array length. To sort a table that isn't an array, you need to put its contents into an array and sort that array. The following Try It Out demonstrates this, as well as the use of a comparison function.</p><div class="sidebar"><a id="try_it_out_colon_sorting_the_contents_of"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Sorting the Contents of an Associative Table</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Save the following as <span class="strong"><strong>sortednametoinstr.lua</strong></span>:</p><pre class="programlisting">-- A demonstration of sorting an associative table.

NameToInstr = {John = "rhythm guitar",
  Paul = "bass guitar",
  George = "lead guitar",
  Ringo = "drumkit"}
-- Transfer the associative table NameToInstr to the
-- array Sorted:
Sorted = {}
for Name, Instr in pairs(NameToInstr) do
  table.insert(Sorted, {Name = Name, Instr = Instr})
end
-- The comparison function sorts by Name:
table.sort(Sorted, function(A, B) return A.Name &lt; B.Name end)
-- Output:
for _, NameInstr in ipairs(Sorted) do
  print(NameInstr.Name .. " played " .. NameInstr.Instr)
end</pre></li><li class="listitem"><p>Run <code class="literal">sortednametoinstr.lua</code> by typing <code class="literal">lua sortednametoinstr.lua</code> into your shell.</p><p>The output is as follows (in alphabetical order by the player's name):</p><pre class="programlisting">George played lead guitar
John played rhythm guitar
Paul played bass guitar
Ringo played drumkit</pre></li></ol></div><p><span class="strong"><strong>How It Works</strong></span><a id="IDX-CHP-4-0031" class="indexterm"></a><a id="IDX-CHP-4-0032" class="indexterm"></a></p><p>The contents of <code class="literal">NameToInstr</code> are transferred, one-by-one, into <code class="literal">Sorted</code> using the <code class="literal">table.insert</code> function. This function, like <code class="literal">table.sort</code>, works by side-effecting the table given to it rather than by returning a value. Specifically, it puts its second argument at the end of the array given as the first argument. For example, if the first argument is a fifteen-element array, it will be given a sixteenth element (the second argument). Take a look at the following argument:</p><pre class="programlisting">table.insert(Arr, Val)</pre><p>This has the same effect as the following:</p><pre class="programlisting">Arr[#Arr + 1] = Val</pre><div class="blockquote"><blockquote class="blockquote"><p>Both <code class="literal">table.sort</code> and <code class="literal">table.insert</code> could be rewritten to have no side effect on the tables they are given, but they would then need to spend time making independent copies of those tables to return.</p></blockquote></div><p>After <code class="literal">Sorted</code> has been populated, it can be passed to <code class="literal">table.sort</code>, but because each of its elements is itself a table, a comparison function needs to be given as well (otherwise <code class="literal">table.sort</code> would use <code class="literal">&lt;</code> to compare the subtables, which would cause an error). The comparison function is quite simple. It just asks whether the <code class="literal">Name</code> element of its first argument is less than that of its second argument. It would be very easy to change it to sort by <code class="literal">Instr</code> instead, or (by using <code class="literal">&gt;</code>) to have it sort in reverse order.</p><p>The comparison function accepted by <code class="literal">table.sort</code> is an example of a <span class="emphasis"><em>callback</em></span>. A callback is a function that you write to be called by a library function. It gets its name from the fact that it allows a library to call back into code you have written (reversing the normal situation, in which you call a function in the library).<a id="IDX-CHP-4-0033" class="indexterm"></a></p></div><p>For efficiency, <code class="literal">table.sort</code> performs an <span class="emphasis"><em>unstable</em></span> sort, which means that two elements that are considered equal by the comparison function may end up in a different order than they started in.</p><div class="blockquote"><blockquote class="blockquote"><p>If you need a stable sort, one solution is to record all the elements' original positions and have the comparison function use that as a tiebreaker.</p></blockquote></div><p>If you're using <code class="literal">table.sort</code> with a comparison function, and you're getting errors that you can't make sense of within your comparison function or within <code class="literal">table.sort</code> itself, your comparison function may be at fault. <code class="literal">table.sort</code> relies on a comparison function having consistent results—it should always return false for things that it considers equal, it should never say that <code class="literal">A</code> is less than <code class="literal">B</code> if it's already said that <code class="literal">B</code> is less than <code class="literal">A</code>, it should say that <code class="literal">A</code> is less than <code class="literal">C</code> if it's already said that <code class="literal">A</code> is less than <code class="literal">B</code> and <code class="literal">B</code> is less than <code class="literal">C</code>, and so on.</p><p>In the following example, the comparison function returns inconsistent results. It says that, for sorting purposes, <code class="literal">5</code> is less than <code class="literal">5</code>. This confuses <code class="literal">table.sort</code>, hence the following error:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {5, 5, 10, 15}</code></strong>
&gt; <strong class="userinput"><code>table.sort(T,</code></strong></pre><pre class="programlisting">&gt;&gt; <strong class="userinput"><code>function(A, B)</code></strong>
&gt;&gt;    <strong class="userinput"><code>return not (A &lt; B) -- BAD COMPARISON FUNCTION!</code></strong>
&gt;&gt; <strong class="userinput"><code>end)</code></strong>
stdin:3: attempt to compare nil with number
stack traceback:
        stdin:3: in function &lt;stdin:2&gt;
        [C]: in function 'sort'
        stdin:1: in main chunk
        [C]: ?</pre><p>The desired effect of <code class="literal">not (A &lt; B)</code> was presumably to sort in reverse order. Either <code class="literal">A &gt; B</code> or <code class="literal">B &lt; A</code> would have had that effect.<a id="IDX-CHP-4-0034" class="indexterm"></a><a id="IDX-CHP-4-0035" class="indexterm"></a></p></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="table.concat"></a>table.concat</h3></div></div></div><p>The function <code class="literal">table.concat</code> takes an array of strings (or numbers) and concatenates them all into one string, as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(table.concat({"a", "bc", "d"}))</code></strong>
abcd</pre><p>If given a second argument, it puts it in between the elements of the array like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- Returns a string showing an array's elements separated by</code></strong>
&gt; <strong class="userinput"><code>-- commas (and spaces):</code></strong>
&gt; <strong class="userinput"><code>function CommaSeparate(Arr)</code></strong>
&gt;&gt;   <strong class="userinput"><code>return table.concat(Arr, ", ")</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>print(CommaSeparate({"a", "bc", "d"}))</code></strong>
a, bc, d</pre><p>Normally, all elements from the first to the last will be concatenated. To start concatenating at a different element, give its index as the third argument of <code class="literal">table.concat</code>; to stop concatenating at a different element, give its index as the fourth argument of <code class="literal">table.concat</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Tbl = {"a", "b", "c", "d"}</code></strong>
&gt; <strong class="userinput"><code>-- Concatenate the second through last elements:</code></strong>
&gt; <strong class="userinput"><code>print(table.concat(Tbl, "", 2))</code></strong>
bcd
&gt; <strong class="userinput"><code>-- Concatenate the second through third elements:</code></strong>
&gt; <strong class="userinput"><code>print(table.concat(Tbl, "", 2, 3))</code></strong>
bc</pre><p>If any of the second through fourth arguments are <code class="literal">nil</code>, the defaults of (respectively) the empty string, <code class="literal">1</code>, and the length of the array are used, as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(table.concat(Tbl, nil, nil, 3))</code></strong>
abc</pre><p>If the third argument is greater than the fourth argument, the empty string is returned, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(table.concat(Tbl, "-", 4, 1) == "")</code></strong>
true</pre></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="table.remove"></a>table.remove</h3></div></div></div><p>The <code class="literal">table.insert</code> function (seen in the most recent Try It Out) has a counterpart that removes elements from an array, <code class="literal">table.remove</code>. By default, both work on the last element of the array (or the top element when viewing the array as a stack). <code class="literal">table.remove</code> works by side effect like <code class="literal">table.insert</code> does, but it also returns a useful value—the element it just removed—as follows:<a id="IDX-CHP-4-0036" class="indexterm"></a><a id="IDX-CHP-4-0037" class="indexterm"></a><a id="IDX-CHP-4-0038" class="indexterm"></a><a id="IDX-CHP-4-0039" class="indexterm"></a><a id="IDX-CHP-4-0040" class="indexterm"></a></p><div class="blockquote"><blockquote class="blockquote"><p>The following examples use the <code class="literal">CommaSeparate</code> function defined in the previous example.</p></blockquote></div><pre class="programlisting">&gt; <strong class="userinput"><code>T = {}</code></strong>
&gt; <strong class="userinput"><code>table.insert(T, "a")</code></strong>
&gt; <strong class="userinput"><code>table.insert(T, "b")</code></strong>
&gt; <strong class="userinput"><code>table.insert(T, "c")</code></strong>
&gt; <strong class="userinput"><code>print(CommaSeparate(T))</code></strong>
a, b, c
&gt; <strong class="userinput"><code>print(table.remove(T))</code></strong>
c
&gt; <strong class="userinput"><code>print(CommaSeparate(T))</code></strong>
a, b
&gt; <strong class="userinput"><code>print(table.remove(T))</code></strong>
b
&gt; <strong class="userinput"><code>print(CommaSeparate(T))</code></strong>
a
&gt; <strong class="userinput"><code>print(table.remove(T))</code></strong>
a
&gt; <strong class="userinput"><code>-- T is now empty again:</code></strong>
&gt; <strong class="userinput"><code>print(#T)</code></strong>
0</pre><p>Both of these functions take an optional second argument that specifies the position at which to insert or remove an element. (In the case of <code class="literal">table.insert</code>, this means that the thing to be inserted is either the second or the third argument, depending on whether a position argument is given.) Any elements above that inserted or removed are shifted up or down to compensate, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {"a", "b", "c"}</code></strong>
&gt; <strong class="userinput"><code>table.insert(T, 2, "X")</code></strong>
&gt; <strong class="userinput"><code>-- C is now the fourth element:</code></strong>
&gt; <strong class="userinput"><code>print(CommaSeparate(T))</code></strong>
a, X, b, c
&gt; <strong class="userinput"><code>print(table.remove(T, 2))</code></strong>
X
&gt; <strong class="userinput"><code>-- C is the third element again:</code></strong>
&gt; <strong class="userinput"><code>print(CommaSeparate(T))</code></strong>
a, b, c</pre></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="table.maxn"></a>table.maxn</h3></div></div></div><p>The function <code class="literal">table.maxn</code> looks at every single key-value pair in a table and returns the highest positive number used as a key, or <code class="literal">0</code> if there are no positive numbers used as keys. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(table.maxn({"a", nil, nil, "c"}))</code></strong>
4
&gt; <strong class="userinput"><code>print(table.maxn({[1.5] = true}))</code></strong>
1.5</pre><pre class="programlisting">&gt; <strong class="userinput"><code>print(table.maxn({["1.5"] = true}))</code></strong>
0</pre><p>One possible use for <code class="literal">table.maxn</code> is to find the length of arrays with gaps, but keep in mind both that it is time-consuming in proportion to the size of the table (including nonnumeric keys) and that it considers fractional keys as well as integers.<a id="IDX-CHP-4-0041" class="indexterm"></a></p><p>That covers all the functions in Lua's built-in table library. Among Lua's other built-in libraries are the string library (whose functions are found in the <code class="literal">string</code> table), the mathematical library (in the <code class="literal">math</code> table), the input/output library (in the <code class="literal">io</code> table), and the basic or base library (functions like <code class="literal">print, tostring</code>, and <code class="literal">pairs</code>). You'll learn about these and other built-in libraries throughout the book. In particular, the next chapter will discuss the string library in detail.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="object-oriented_programming_with_tables"></a>Object-Oriented Programming with Tables</h2></div></div></div><p>Another use for tables is in what is known as <span class="emphasis"><em>object-oriented programming</em></span>. In this style of programming, functions that deal with a particular type of value are themselves part of that value. Such a value is called an <span class="emphasis"><em>object</em></span>, and its functions are called <span class="emphasis"><em>methods</em></span>.<a id="IDX-CHP-4-0042" class="indexterm"></a></p><div class="blockquote"><blockquote class="blockquote"><p>The term "object" is also sometimes used in a more general sense, to mean a value (such as a table or function) that is not equal to any other value created at a different time.</p></blockquote></div><p>It's quite easy to rewrite the <code class="literal">MakeGetAndInc</code> example from <a class="link" href="ch03.html" title="Chapter 3. Extending Lua with Functions">Chapter 3</a> to return a two-method object rather than two functions. Here's how:</p><pre class="programlisting">-- Returns a table of two functions: a function that gets
-- N's value, and a function that increments N by its
-- argument.
function MakeGetAndInc(N)
  -- Returns N:
  local function Get()
    return N
  end

  -- Increments N by M:
  local function Inc(M)
    N = N + M
  end

  return {Get = Get, Inc = Inc}
end</pre><p>An object is created and used like so:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- Create an object:</code></strong>
&gt; <strong class="userinput"><code>A = MakeGetAndInc(50)</code></strong>
&gt; <strong class="userinput"><code>-- Try out its methods:</code></strong>
&gt; <strong class="userinput"><code>print(A.Get())</code></strong>
50
&gt; <strong class="userinput"><code>A.Inc(2)</code></strong>
&gt; <strong class="userinput"><code>print(A.Get())</code></strong>
52</pre><p>This is an improvement on the previous technique in that only the newly created object needs to be given a name (rather than both functions), and in that the functions are bundled up into an object (so that the whole object can be passed around the program as a unit).<a id="IDX-CHP-4-0043" class="indexterm"></a><a id="IDX-CHP-4-0044" class="indexterm"></a><a id="IDX-CHP-4-0045" class="indexterm"></a></p><p>Both of these advantages are greater the more methods there are, and this is an acceptable way of implementing objects. But it has two disadvantages: each time an object is created (or <span class="emphasis"><em>instantiated</em></span>), a closure needs to be created for each method, and an object's state is stored in multiple places (as an upvalue in each method) rather than in one place.</p><p>The creation of a closure for each method is really only a disadvantage for efficiency reasons. In a program that instantiates several new multiple-method objects a second, creating all those closures could have a noticeable speed impact.</p><p>The second point, about state being stored as an upvalue within each method, means that you can use a method apart from its object, as shown here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>A = MakeGetAndInc(50)</code></strong>
&gt; <strong class="userinput"><code>Inc, Get = A.Inc, A.Get</code></strong>
&gt; <strong class="userinput"><code>A = nil</code></strong>
&gt; <strong class="userinput"><code>-- The methods are still usable even though A is no longer</code></strong>
&gt; <strong class="userinput"><code>-- accessible:</code></strong>
&gt; <strong class="userinput"><code>Inc(2)</code></strong>
&gt; <strong class="userinput"><code>print(Get())</code></strong>
52</pre><p>This might occasionally be convenient, but it's usually just confusing.</p><p>A technique that avoids these problems is to store the object's state in the object (table) itself, and have the methods be, rather than closures, just regular functions that take the object as an argument:</p><pre class="programlisting">-- Returns Obj.N:
function Get(Obj)
  return Obj.N
end

-- Increments Obj.N by M:
function Inc(Obj, M)
  Obj.N = Obj.N + M
end

-- Creates an object:
function MakeGetAndInc(N)
  return {N = N}
end</pre><p>The <code class="literal">Inc</code> method of an object <code class="literal">A</code> would then be called like <code class="literal">Inc(A, 5)</code>, which means you'd need to keep track of which methods go with which objects. You wouldn't need to keep track of this if the methods were (as in an earlier example) fields of their objects, but you'd still need to type the object's name twice: <span class="strong"><strong>A.Inc(A, 5)</strong></span>.</p><p>To get around this problem, Lua offers a bit of <span class="emphasis"><em>syntactic sugar. Syntax</em></span> just means grammar—the rules of how operators, variable names, parentheses, curly braces, and so on can fit together to make a valid Lua program. And syntactic sugar just means an extension to Lua's syntax that doesn't give Lua any new powers, but does make programs easier to type or read. For example, the equivalence between a <code class="literal">function</code> statement and an assignment statement with a <code class="literal">function</code> expression as a value (which you learned about in the previous chapter) is due to the former being syntactic sugar for the latter.</p><p>Similarly, when Lua sees something that looks like <code class="literal">A:Inc(5)</code> (note the colon), it treats it as though it were <code class="literal">A.Inc(A, 5). A</code> is used both as the source for the <code class="literal">Inc</code> function and as the first argument to that function. Because the methods in the previous example are written to expect their first argument to be the object, the only change you need to make in order to use colon syntax is to include <code class="literal">Get</code> and <code class="literal">Inc</code> in the object that <code class="literal">MakeGetAndInc</code> returns. (<code class="literal">Get</code> and <code class="literal">Inc</code> are also made local below this, because they no longer need to be used anywhere but inside <code class="literal">MakeGetAndInc</code>.) Now the methods are called right from the object, just as in the example at the beginning of this section, but with a colon substituted for the dot:</p><pre class="programlisting">&gt; do -- Local scope for Get and Inc.
&gt;&gt;   -- Returns Obj.N:
&gt;&gt;   local function Get(Obj)
&gt;&gt;     return Obj.N
&gt;&gt;   end
&gt;&gt;
&gt;&gt;   -- Increments Obj.N by M:
&gt;&gt;   local function Inc(Obj, M)
&gt;&gt;     Obj.N = Obj.N + M
&gt;&gt;   end
&gt;&gt;
&gt;&gt;   -- Creates an object:
&gt;&gt;   function MakeGetAndInc(N)
&gt;&gt;     return {N = N, Get = Get, Inc = Inc}
&gt;&gt;   end
&gt;&gt; end
&gt;
&gt; -- Create an object:
&gt; A = MakeGetAndInc(50)
&gt; -- Try out its methods:
&gt; print(A:Get())
50
&gt; A:Inc(2)
&gt; print(A:Get())
52</pre><p>There's also syntactic sugar for defining methods: <code class="literal">function T:F(X)</code> is equivalent to <code class="literal">function T.F(self, X)</code>, which itself is equivalent to <code class="literal">T.F = function(self, X)</code>. You can rewrite the preceding example to use this if you make a table in which you can put <code class="literal">Get</code> and <code class="literal">Inc</code>, and if you have them use <code class="literal">self</code> instead of <code class="literal">Obj</code> as a name for their (now implicit) first argument. Here's how:<a id="IDX-CHP-4-0046" class="indexterm"></a><a id="IDX-CHP-4-0047" class="indexterm"></a><a id="IDX-CHP-4-0048" class="indexterm"></a><a id="IDX-CHP-4-0049" class="indexterm"></a><a id="IDX-CHP-4-0050" class="indexterm"></a></p><pre class="programlisting">do -- Local scope for T.
    -- A table in which to define Get and Inc:
    local T = {}

    -- Returns self.N:
    function T:Get()
      return self.N
    end

    -- Increments self.N by M:</pre><pre class="programlisting">function T:Inc(M)
      self.N = self.N + M
    end

    -- Creates an object:
    function MakeGetAndInc(N)
      return {N = N, Get = T.Get, Inc = T.Inc}
    end
  end</pre><p>Note the following about this example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the colon syntax is used to define a function, Lua itself will take care of inserting the formal <code class="literal">self</code> argument. If you forget this and try do to it yourself by typing <span class="strong"><strong>function T:Get(self)</strong></span>, then Lua will treat that as though it were <code class="literal">function T.Get(self, self)</code>, which is not what you want.<a id="IDX-CHP-4-0051" class="indexterm"></a><a id="IDX-CHP-4-0052" class="indexterm"></a></p></li><li class="listitem"><p><code class="literal">Get</code> and <code class="literal">Inc</code> are neither local nor global—they are fields of a (local) table. <code class="literal">local function T:Get()</code> would be wrong for the same reason that <code class="literal">local T.Get = function(self)</code> would be wrong—the <code class="literal">local</code> keyword is for creating new local variables, but <code class="literal">T.Get</code> is not a variable name (it's the name of a table field).<a id="IDX-CHP-4-0053" class="indexterm"></a></p></li><li class="listitem"><p>Because the colon syntaxes for function calls and function definitions are just syntactic sugar, you can mix and match them. You can use the dot syntax to call a function defined with the colon syntax, and you can use the colon syntax to call a function defined with the dot syntax (assuming, of course, that the actual arguments correspond with the formal arguments after translating from colon syntax to dot syntax).</p></li><li class="listitem"><p><code class="literal">T</code> is only used as a container for <code class="literal">Get</code> and <code class="literal">Inc</code> up to the point they're put into a real object. If there were something else that all objects needed to have in common (for instance, a default value for <code class="literal">N</code>), <code class="literal">T</code> would be a good place to put it.</p></li></ul></div><p>Later in this chapter, you'll see an extended example that uses the colon syntax for something more interesting than incrementing numbers.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="functions_with_variable_numbers_of_argum"></a>Functions with Variable Numbers of Arguments</h1></div></div></div><p>Functions that accept variable numbers of arguments are called <span class="emphasis"><em>vararg</em></span> functions and, as promised in the previous chapter, you'll now learn how to write them.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="defining_vararg_functions"></a>Defining Vararg Functions</h2></div></div></div><p>The <code class="literal">Average</code> function returns the average of all its arguments. It also introduces the built-in function <code class="literal">assert</code>, which does nothing if its first argument is true and triggers an error if it's false. (The second argument is used as the error message.) Here's an example of how you use the <code class="literal">Average</code> function:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- Returns the average of all its arguments:</code></strong>
&gt; <strong class="userinput"><code>function Average(...)</code></strong>
&gt;&gt;     <strong class="userinput"><code>local Ret, Count = 0, 0</code></strong>
&gt;&gt;     <strong class="userinput"><code>for _, Num in ipairs({...}) do</code></strong></pre><pre class="programlisting">&gt;&gt;    <strong class="userinput"><code>Ret = Ret + Num</code></strong>
&gt;&gt;     <strong class="userinput"><code>Count = Count + 1</code></strong>
&gt;&gt;   <strong class="userinput"><code>end</code></strong>
&gt;&gt;   <strong class="userinput"><code>assert(Count &gt; 0, "Attempted to average zero numbers")</code></strong>
&gt;&gt;   <strong class="userinput"><code>return Ret / Count</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>print(Average(1))</code></strong>
1
&gt; <strong class="userinput"><code>print(Average(41, 43))</code></strong>
42
&gt; <strong class="userinput"><code>print(Average(31, −41, 59, −26, 53))</code></strong>
15.2
&gt; <strong class="userinput"><code>print(Average())</code></strong>
stdin:7: Attempted to average zero numbers
stack traceback:
        [C]: in function 'assert'
        stdin:7: in function 'Average'
        stdin:1: in main chunk
        [C]: ?</pre><p>The <code class="literal">Average</code> function's formal argument list consists only of <code class="literal">...</code> (three dots), which tells Lua that <code class="literal">Average</code> is a vararg function. Within a vararg function, three dots can be used as an expression, which is called a <span class="emphasis"><em>vararg expression</em></span>. A vararg expression, like a function call, can evaluate to zero or more values. The vararg expression in <code class="literal">Average</code> is inside a table constructor. When <code class="literal">Average</code> is called with <code class="literal">1</code> as an argument, it is as though the table constructor looked like <code class="literal">{1}</code>. When it's called with <code class="literal">41</code> and <code class="literal">43</code> as arguments, it's as though the table constructor looked like <code class="literal">{41, 43}</code>. When it's called with <code class="literal">31, −41, 59, −26</code>, and <code class="literal">53</code> as arguments, it's as though the table constructor looked like <code class="literal">{31, −41, 59, −26, 53}</code>. And when it's called with no arguments, it's as though the table constructor looked like <code class="literal">{}</code>.<a id="IDX-CHP-4-0054" class="indexterm"></a><a id="IDX-CHP-4-0055" class="indexterm"></a></p><p>You can use a vararg expression anywhere any other expression can be used. It follows exactly the same adjustment rules as a function call. For example, the vararg expression in the following assignment would be adjusted to two values:</p><pre class="programlisting">Var1, Var2 = ...</pre><p>Both vararg expressions in the following return statement would be adjusted to one value:</p><pre class="programlisting">return ..., (...)</pre><p>And the one in the following function call would not be adjusted at all—all of its zero or more values would be passed along to <code class="literal">print</code>:</p><pre class="programlisting">print("args here:", ...)</pre><p>A vararg expression includes any <code class="literal">nil</code> passed to the function, as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>function F(...)</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(...)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>F(nil, "b", nil, nil)</code></strong>
nil     b       nil      nil</pre><p>A vararg function can also have regular (named) formal arguments, in which case the three dots come last and catch any actual arguments that are left over after the leftmost ones are assigned to the named formal arguments. Here's an example that makes that clearer:</p><pre class="programlisting">&gt; <strong class="userinput"><code>function F(Arg1, Arg2, ...)</code></strong>
&gt;&gt;   <strong class="userinput"><code>print("Arg1 and Arg2:", Arg1, Arg2)</code></strong>
&gt;&gt;   <strong class="userinput"><code>print("The rest:", ...)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>F()</code></strong>
Arg1 and Arg2: nil  nil
The rest:
&gt; <strong class="userinput"><code>F("a")</code></strong>
Arg1 and Arg2: a  nil
The rest:
&gt; <strong class="userinput"><code>F("a", "b")</code></strong>
Arg1 and Arg2: a  b
The rest:
&gt; <strong class="userinput"><code>-- Now there will be arguments left over after Arg1 and</code></strong>
&gt; <strong class="userinput"><code>-- Arg2 have been taken care of:</code></strong>
&gt; <strong class="userinput"><code>F("a", "b", "c")</code></strong>
Arg1 and Arg2: a  b
The rest:      c
&gt; <strong class="userinput"><code>F("a", "b", "c", "d")</code></strong>
Arg1 and Arg2:  a       b
The rest:       c       d</pre><p>A vararg expression cannot be used as an upvalue. Again, this will make more sense with an example. Let's say you want to write a <code class="literal">MakePrinter</code> function. <code class="literal">MakePrinter</code> will return a function that takes no arguments and prints all the arguments given to <code class="literal">MakePrinter</code>. The obvious way to write this is like this:</p><pre class="programlisting">function MakePrinter(...)
  return function()
    print(...) -- THIS DOESN'T WORK!
  end
end</pre><p>But if you type that in, Lua will complain partway through:</p><pre class="programlisting">&gt; <strong class="userinput"><code>function MakePrinter(...)</code></strong>
&gt;&gt;   <strong class="userinput"><code>return function()</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(...) -- THIS DOESN'T WORK!</code></strong>
stdin:3: cannot use '...' outside a vararg function near '...'</pre><p>The anonymous function is not a vararg function. The vararg expression used in it is local to <code class="literal">MakePrinter</code>, which makes it an upvalue in the anonymous function, and because vararg expressions can't be used as upvalues, another way needs to be found to make the <code class="literal">MakePrinter</code> arguments available inside the anonymous function. That part is actually quite easy—just put the vararg expression inside a table constructor, and use the variable holding that table as the upvalue. The hard part is calling <code class="literal">print</code> with each of the table's values as arguments. That's easy to do with the <code class="literal">unpack</code> function, which takes an array as its first argument and returns, in order, all of the elements of that array (up to the array's length). For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>function MakePrinter(...)</code></strong>
&gt;&gt;   <strong class="userinput"><code>local Args = {...}</code></strong>
&gt;&gt;   <strong class="userinput"><code>return function()</code></strong>
&gt;&gt;     <strong class="userinput"><code>print(unpack(Args))</code></strong>
&gt;&gt;   <strong class="userinput"><code>end</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>Printer = MakePrinter("a", "b", "c")</code></strong>
&gt; <strong class="userinput"><code>Printer()</code></strong>
a     b     c</pre><p>Because <code class="literal">unpack</code> uses its argument's length, it may not act right with an array that has gaps, which <code class="literal">Args</code> will if <code class="literal">MakePrinter</code> is given any <code class="literal">nil</code> arguments. The fix for this involves extra arguments to <code class="literal">unpack</code>, as well as a new built-in function, <code class="literal">select</code>.<a id="IDX-CHP-4-0056" class="indexterm"></a><a id="IDX-CHP-4-0057" class="indexterm"></a></p><p>The first <code class="literal">select</code> argument is a positive integer. If it's <code class="literal">1, select</code> will return all its additional arguments; if it's <code class="literal">2</code>, select will return all its additional arguments except for the first; and so on:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(select(1, "a", "b", "c"))</code></strong>
a       b       c
&gt; <strong class="userinput"><code>print(select(2, "a", "b", "c"))</code></strong>
b       c
&gt; <strong class="userinput"><code>print(select(3, "a", "b", "c"))</code></strong>
c
&gt; <strong class="userinput"><code>-- This returns nothing:</code></strong>
&gt; <strong class="userinput"><code>print(select(4, "a", "b", "c"))</code></strong>

&gt;</pre><p>As a special case, if the first <code class="literal">select</code> argument is the string <code class="literal">"#"</code>, then it returns how many additional arguments it received, as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(select("#"))</code></strong>
0
&gt; <strong class="userinput"><code>print(select("#", "a"))</code></strong>
1
&gt; <strong class="userinput"><code>print(select("#", "a", "b"))</code></strong>
2
&gt; <strong class="userinput"><code>print(select("#", "a", "b", "c"))</code></strong>
3</pre><p>It's this <code class="literal">"#"</code> usage that lets you find out how many values (including <code class="literal">nil</code>s) are in a vararg expression (or in any expression that can have multiple values, for that matter):</p><pre class="programlisting">&gt; <strong class="userinput"><code>function F(...)</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(select("#", ...))</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>F(nil, "b", nil, nil)</code></strong>
4</pre><div class="blockquote"><blockquote class="blockquote"><p>You might think that <code class="literal">#...</code> would get the length of a vararg expression, but all it really does is get the length of the first element of the vararg expression (which, being used as an operand, is not eligible for multiple-value treatment and so is adjusted to one value).</p></blockquote></div><p><code class="literal">unpack</code> takes a second and third argument specifying where it starts and stops, getting values out of the table given to it:<a id="IDX-CHP-4-0058" class="indexterm"></a><a id="IDX-CHP-4-0059" class="indexterm"></a></p><div class="blockquote"><blockquote class="blockquote"><p>If these arguments are not given, they default to <code class="literal">1</code> and the length of the table.</p></blockquote></div><pre class="programlisting">&gt; <strong class="userinput"><code>-- Get elements 2 through 4 (inclusive):</code></strong>
&gt; <strong class="userinput"><code>print(unpack({"a", "b", "c", "d", "e"}, 2, 4))</code></strong>
b       c       d</pre><p>Here's the rewritten version of <code class="literal">MakePrinter</code> that handles <code class="literal">nil</code>s properly. It uses <code class="literal">select("#", ...)</code> to count <code class="literal">MakePrinter</code>'s arguments, and when it calls <code class="literal">unpack</code>, it unpacks all elements from the first up to however many arguments it counted:</p><pre class="programlisting">&gt; <strong class="userinput"><code>function MakePrinter(...)</code></strong>
&gt;&gt;   <strong class="userinput"><code>local Args = {...}</code></strong>
&gt;&gt;   <strong class="userinput"><code>local ArgCount = select("#", ...)</code></strong>
&gt;&gt;   <strong class="userinput"><code>return function()</code></strong>
&gt;&gt;     <strong class="userinput"><code>print(unpack(Args, 1, ArgCount))</code></strong>
&gt;&gt;   <strong class="userinput"><code>end</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>Printer = MakePrinter(nil, "b", nil, nil)</code></strong>
&gt; <strong class="userinput"><code>Printer()</code></strong>
nil     b         nil         nil</pre><p>If a vararg function doesn't contain any vararg expressions, then a local <code class="literal">arg</code> variable is created and initialized to a table of all the extra arguments. <code class="literal">arg.n</code> is the number of extra arguments. It is as though the first lines of the function were as follows:</p><pre class="programlisting">local arg = {...}
arg.n = select("#", ...)</pre><p>This is done so that vararg functions written for Lua 5.0 will run on Lua 5.1. Lua 5.0 had no vararg expression, so vararg arguments were always put in such an <code class="literal">arg</code> table.</p><div class="blockquote"><blockquote class="blockquote"><p>In addition to the lack of the vararg expression and use of <code class="literal">arg</code>, Lua 5.0 did not have the <code class="literal">select</code> function, and its <code class="literal">unpack</code> function took only one argument.</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="scripts_as_vararg_functions"></a>Scripts as Vararg Functions</h2></div></div></div><p>You already know that chunks are functions. In this section, you'll see that they are vararg functions. In particular, Lua scripts are vararg functions and they can be given arguments on the command line.</p><div class="sidebar"><a id="try_it_out_colon_creating_command-line_a"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Creating Command-Line Arguments</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Save the following as <span class="strong"><strong>cmdlineargs.lua</strong></span>:</p><pre class="programlisting">-- This script lists (by number) all arguments given to it
-- on the command line.

local Count = select("#", ...)
if Count &gt; 0 then</pre><pre class="programlisting">print("Command-line arguments:")
for I = 1, Count do
  print(I, (select(I, ...))) -- The parentheses adjust
    -- select to one value.
  end
else
  print("No command-line arguments given.")
end</pre></li><li class="listitem"><p>Run it by typing the following into your shell:</p><pre class="programlisting">lua cmdlineargs.lua this is a test</pre><p>The output should be as follows:</p><pre class="programlisting">Command-line arguments:
1      this
2      is
3      a
4      test</pre></li></ol></div><p><span class="strong"><strong>How It Works</strong></span></p><p>When you type the name of a program (<code class="literal">lua</code>) into the shell, the words that come after it are called <span class="emphasis"><em>command-line arguments</em></span>. The shell passes these arguments along to the program. In this case, <code class="literal">lua</code> treats the first command-line argument, <code class="literal">cmdlineargs.lua</code>, as the name of a program. It compiles that program into a function, and calls the function with the remaining command-line arguments (the strings <code class="literal">"this", "is", "a"</code>, and <code class="literal">"test"</code>).<a id="IDX-CHP-4-0060" class="indexterm"></a></p><p>This example also shows how you can use <code class="literal">select</code> to access arguments without putting them into a table first.</p></div><p>The shell gives special meaning to some characters. For example, it treats spaces as argument separators. If you want to include a special character in an argument, you need to escape it or quote it. The exact rules for escaping or quoting characters vary from shell to shell, but something like the following:</p><pre class="programlisting">lua cmdlineargs.lua "this is a test" "" "&lt;*&gt;"</pre><p>generally results in this:</p><pre class="programlisting">Command-line arguments:
1      this is a test
2
3      &lt;*&gt;</pre><p>The second argument is the empty string.</p><p>Command-line arguments are always strings, which means you don't have to worry about a gap caused by a <code class="literal">nil</code>.</p><p><code class="literal">lua</code> treats some of its command-line arguments specially. These are called <span class="emphasis"><em>options</em></span>, and they all start with a hyphen. The following table lists the <code class="literal">lua</code> options:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"><col class="col2"></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Option</p></th><th style="text-align: left" valign="bottom"><p>Action</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">-e</code></p></td><td style="text-align: left" valign="top"><p>Executes the following command-line argument as Lua code.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-l</code></p></td><td style="text-align: left" valign="top"><p>Uses the <code class="literal">require</code> function on the library named by the following command-line argument. (You'll learn about <code class="literal">require</code> in <a class="link" href="ch07.html" title="Chapter 7. Using Modules">Chapter 7</a>.)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-i</code></p></td><td style="text-align: left" valign="top"><p>Enters interactive mode after running the script named after all the options (or executing any <code class="literal">-e</code> arguments).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-v</code></p></td><td style="text-align: left" valign="top"><p>Prints version information.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">--</code></p></td><td style="text-align: left" valign="top"><p>Stops handling options (this is useful if you want to run a script whose name starts with "<code class="literal">-</code>").</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-</code></p></td><td style="text-align: left" valign="top"><p>Stops handling options and executes <code class="literal">lua</code>'s input as a single chunk.</p></td></tr></tbody></table></div><p>Here are a couple examples. Starting <code class="literal">lua</code> like this</p><pre class="programlisting">lua -e "print('Hello')"</pre><p>prints "<code class="literal">Hello</code>", but does not enter interactive mode (the Lua interpreter). Starting it like this:</p><pre class="programlisting">lua -i sortednametoinstr.lua</pre><p>runs <code class="literal">sortednametoinstr.lua</code> and then enters interactive mode, where you have access to any global variables it created (which in this case are <code class="literal">NameToInstr</code> and <code class="literal">Sorted</code>):</p><pre class="programlisting">Lua 5.1.1 Copyright (C) 1994-2006 Lua.org, PUC-Rio
George played lead guitar
John played rhythm guitar
Paul played bass guitar
Ringo played drumkit
&gt; <strong class="userinput"><code>print(NameToInstr.John)</code></strong>
rhythm guitar
&gt; <strong class="userinput"><code>print(Sorted[4].Name)</code></strong>
Ringo</pre><p>The options <code class="literal">-e</code> and <code class="literal">-l</code> can be combined with the command-line arguments immediately following them. The following example of <code class="literal">-e</code> does exactly the same thing as the one given earlier:</p><pre class="programlisting">lua "-eprint('Hello')"</pre><p>A script's command-line arguments are also available in the global table <code class="literal">arg</code>, even if a vararg expression is used in the script. This is done to give access to the script's name (found at <code class="literal">arg[0]</code>) and the interpreter's name and any options (found at negative indexes). If <code class="literal">lua</code> is started with the following:</p><pre class="programlisting">lua -i cmdlineargs.lua this is a test</pre><p>then this is the <code class="literal">arg</code>:</p><pre class="programlisting">{[-2] = "lua",
[-1] = "-i",</pre><pre class="programlisting">[0] = "cmdlineargs.lua",
[1] = "this",
[2] = "is",
[3] = "a",
[4] = "test"}</pre><p>Notice that, unlike the <code class="literal">arg</code> described in the previous section, this one doesn't have its length in <code class="literal">arg.n</code>. The length is easy enough to find out, though (for instance, with <code class="literal">#arg</code>, or with a loop if you want to count the nonpositive indexes).<a id="IDX-CHP-4-0061" class="indexterm"></a></p></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="keyword_arguments"></a>Keyword Arguments</h1></div></div></div><p>In the previous chapter, you saw that a function call whose sole argument is a literal string doesn't require parentheses. The same applies to table constructors. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print {}</code></strong>
table: 0x493760
&gt; <strong class="userinput"><code>print{}</code></strong>
table: 0x493978</pre><p>This can be used to simulate <span class="emphasis"><em>keyword arguments</em></span>—arguments that are identified not by their position, but by being associated with an identifier. In all three of the following examples, a function called <code class="literal">Sort</code> is being called with its <code class="literal">Arr</code> keyword argument set to <code class="literal">T</code> and its <code class="literal">CompFnc</code> keyword argument set to <code class="literal">F</code> (the last example reveals that all that's really going on is that an associative table is being passed to <code class="literal">Sort</code>):<a id="IDX-CHP-4-0062" class="indexterm"></a><a id="IDX-CHP-4-0063" class="indexterm"></a></p><pre class="programlisting">Sort{Arr = T, CompFnc = F}

Sort{CompFnc = F, Arr = T}

Sort({Arr = T, CompFnc = F})</pre><p>There is no special syntax for defining functions with keyword arguments—they're just defined to take a single table as an argument. For example, you could define <code class="literal">Sort</code> as follows:</p><pre class="programlisting">-- A wrapper for table.sort that takes keyword arguments:
function Sort(KeyArgs)
  local Arr = KeyArgs.Arr -- The array to be sorted.
  local CompFnc = KeyArgs.CompFnc -- Comparison function.
    or function(A, B) return A &lt; B end -- Default.
  if KeyArgs.Reverse then
    -- Reverse the sense of the comparison function:
    local OrigCompFnc = CompFnc
    CompFnc = function(A, B)
      return OrigCompFnc(B, A)
    end
  end
  table.sort(Arr, CompFnc)
  return Arr
end</pre><p>The <code class="literal">Reverse</code> argument reverses the sense of the comparison function. When no <code class="literal">CompFnc</code> is given, but <code class="literal">Reverse</code> is set to <code class="literal">true</code>, the sense of the default comparison function is reversed, which sorts the table in reverse order:<a id="IDX-CHP-4-0064" class="indexterm"></a><a id="IDX-CHP-4-0065" class="indexterm"></a><a id="IDX-CHP-4-0066" class="indexterm"></a><a id="IDX-CHP-4-0067" class="indexterm"></a><a id="IDX-CHP-4-0068" class="indexterm"></a><a id="IDX-CHP-4-0069" class="indexterm"></a><a id="IDX-CHP-4-0070" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Letters = {"a", "b", "c"}</code></strong>
&gt; <strong class="userinput"><code>Sort{Reverse = true, Arr = Letters}</code></strong>
&gt; <strong class="userinput"><code>print(table.concat(Letters))</code></strong>
cba</pre><p>The usual reasons for writing a function to take keyword arguments are that it has a lot of optional arguments, or that it has so many arguments that it's hard to remember what order they go in.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="different_but_the_same"></a>Different but the Same</h1></div></div></div><p>A common problem in understanding how Lua works comes from the fact that tables are <span class="emphasis"><em>mutable</em></span>, which means they can be changed. Side-effecting a table—changing it using indexing assignment—is called <span class="emphasis"><em>mutating</em></span> the table. There's no way to mutate a string (or a number, Boolean, or <code class="literal">nil</code>)—it can only be replaced with a different value. (Strings, numbers, Booleans, and <code class="literal">nil</code> are therefore said to be <span class="emphasis"><em>immutable</em></span>.) But a table can be mutated, and afterward it will have different content, but it will still be the same table.<a id="IDX-CHP-4-0071" class="indexterm"></a></p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="table_equality"></a>Table Equality</h2></div></div></div><p>Because tables are mutable, there needs to be a way to tell whether two tables are really the same table or not (so that you can tell if a mutation of one will be visible in the other). You do this with the <code class="literal">==</code> (equality) operator. When two tables are tested for equality, their contents are not looked at. Rather, they are considered equal if and only if they were created by the same table constructor at the same time (and are therefore the same table). In the following example, <code class="literal">A</code> and <code class="literal">B</code> are equal because they were created by the same table constructor at the same time:</p><pre class="programlisting">&gt; <strong class="userinput"><code>A = {}</code></strong>
&gt; <strong class="userinput"><code>B = A</code></strong>
&gt; <strong class="userinput"><code>print(A == B)</code></strong>
true</pre><p>In the next example, <code class="literal">C</code> and <code class="literal">D</code> are unequal because they were created by two different table constructors, and <code class="literal">E</code> and <code class="literal">F</code> are unequal because they were created by the same table constructor at different times:</p><pre class="programlisting">&gt; <strong class="userinput"><code>C, D = {}, {}</code></strong>
&gt; <strong class="userinput"><code>print(C == D)</code></strong>
false
&gt;
&gt; <strong class="userinput"><code>function CreateTbl()</code></strong>
&gt;&gt;   <strong class="userinput"><code>return {}</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>E, F = CreateTbl(), CreateTbl()</code></strong>
&gt; <strong class="userinput"><code>print(E == F)</code></strong>
false</pre><p>Functions follow the same equality rule as tables: Two functions are equal if and only if they were created by the same <code class="literal">function</code> expression (or <code class="literal">function</code> statement) at the same time. This is because both table constructors and <code class="literal">function</code> expressions <span class="emphasis"><em>create new objects</em></span> (using the term "object" in the broad sense).<a id="IDX-CHP-4-0072" class="indexterm"></a><a id="IDX-CHP-4-0073" class="indexterm"></a></p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="avoiding_bugs_by_understanding_mutabilit"></a>Avoiding Bugs by Understanding Mutability</h2></div></div></div><p>Among other things, you can use mutability to model things in the real world, most of which are mutable. For example, this book would still be the same book if you "mutated" it by writing your name in it. But mutability can also be a source of bugs, if you don't keep track of what's what. In the real world, you would never confuse having both hands on the same book with having each hand on a different book. But in Programming Land, it's not too tough to forget that two variables (or two table fields, or a variable and a table field) both contain the same table.</p><p>For example, imagine the following variant of <code class="literal">table.sort</code>, which still sorts its first argument in place but also returns it:</p><pre class="programlisting">function TableSort(Arr, CompFnc)
  table.sort(Arr, CompFnc)
  return Arr
end</pre><p>This would be convenient in some cases, letting you sort an array and pass it to another function in one statement like this:</p><pre class="programlisting">SomeFnc(TableSort(SomeArr))</pre><p>instead of in two statements like this:</p><pre class="programlisting">table.sort(SomeArr)
SomeFnc(SomeArr)</pre><p>But it might also imply <code class="literal">Sorted</code> is sorted and <code class="literal">SomeArr</code> is unsorted after the following line:</p><pre class="programlisting">local Sorted = TableSort(SomeArr)</pre><p>If you write a function that side-effects a table given to it, make sure that's clear in any documentation you write for the function. If you're using a function that someone else wrote, make sure you know if the function causes side effects in any tables given to it.</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="variables_and_mutable_values"></a>Variables and Mutable Values</h2></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. First Steps">Chapter 2</a>, you saw an illustration of the cubbyhole model (shown in <a class="link" href="ch04.html#figure_4-1" title="Figure 4.1. Figure 4-1">Figure 4-1</a>) and the arrow model (shown in <a class="link" href="ch04.html#figure_4-2" title="Figure 4.2. Figure 4-2">Figure 4-2</a>) of the association between variables and their values.</p><div class="figure"><a id="figure_4-1"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0401.png" height="110" alt="Figure 4-1" width="502"></div></div><p class="title"><strong>Figure 4.1. Figure 4-1</strong></p></div><div class="figure"><a id="figure_4-2"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0402.png" height="142" alt="Figure 4-2" width="419"></div></div><p class="title"><strong>Figure 4.2. Figure 4-2</strong></p></div><p>Both of these models are accurate for immutable values (ignoring memory usage). But the cubbyhole model doesn't work for mutable values. Consider the following code:</p><pre class="programlisting">&gt; <strong class="userinput"><code>A, B = {}, {}</code></strong>
&gt; <strong class="userinput"><code>C = B</code></strong>
&gt; <strong class="userinput"><code>-- Before</code></strong>
&gt; <strong class="userinput"><code>B.Test = "test"</code></strong>
&gt; <strong class="userinput"><code>-- After</code></strong>
&gt; <strong class="userinput"><code>print(C.Test)</code></strong>
test</pre><p>An arrow diagram of the variables as of the <code class="literal">Before</code> comment (shown in <a class="link" href="ch04.html#figure_4-3" title="Figure 4.3. Figure 4-3">Figure 4-3</a>) reflects the fact that <code class="literal">B</code> and <code class="literal">C</code> are the same table.</p><div class="figure"><a id="figure_4-3"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0403.png" height="137" alt="Figure 4-3" width="419"></div></div><p class="title"><strong>Figure 4.3. Figure 4-3</strong></p></div><p>It's an easy step from there to an accurate arrow diagram of the variables as of the <code class="literal">After</code> comment, as shown in <a class="link" href="ch04.html#figure_4-4" title="Figure 4.4. Figure 4-4">Figure 4-4</a>.</p><div class="figure"><a id="figure_4-4"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0404.png" height="137" alt="Figure 4-4" width="419"></div></div><p class="title"><strong>Figure 4.4. Figure 4-4</strong></p></div><p>A cubbyhole diagram as of the <code class="literal">Before</code> comment (see <a class="link" href="ch04.html#figure_4-5" title="Figure 4.5. Figure 4-5">Figure 4-5</a>) does not show that <code class="literal">B</code> and <code class="literal">C</code> are the same table.<a id="IDX-CHP-4-0074" class="indexterm"></a></p><div class="figure"><a id="figure_4-5"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0405.png" height="84" alt="Figure 4-5" width="250"></div></div><p class="title"><strong>Figure 4.5. Figure 4-5</strong></p></div><p>It thus could lead to an <span class="emphasis"><em>incorrect</em></span> diagram as of the <code class="literal">After</code> comment, as shown in <a class="link" href="ch04.html#figure_4-6" title="Figure 4.6. Figure 4-6">Figure 4-6</a>):</p><div class="figure"><a id="figure_4-6"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0406.png" height="179" alt="Figure 4-6" width="375"></div></div><p class="title"><strong>Figure 4.6. Figure 4-6</strong></p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="tables_and_functions"></a>Tables and Functions</h2></div></div></div><p>You saw earlier that functions follow the same equality rule as tables. Another thing that functions have in common with tables is mutability. Closure functions can be mutated by calling them, as is done with <code class="literal">Counter</code> in the following example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>do</code></strong>
&gt;&gt;   <strong class="userinput"><code>local Count = 0</code></strong>
&gt;&gt;
&gt;&gt;   <strong class="userinput"><code>function Counter()</code></strong>
&gt;&gt;     <strong class="userinput"><code>Count = Count + 1</code></strong>
&gt;&gt;     <strong class="userinput"><code>return Count</code></strong>
&gt;&gt;   <strong class="userinput"><code>end</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>print(Counter())</code></strong>
1
&gt; <strong class="userinput"><code>print(Counter())</code></strong>
2
&gt; <strong class="userinput"><code>print(Counter())</code></strong>
3</pre><p>A difference between tables and functions is that tables do not have upvalues. A local variable inside a function is evaluated every time the function is called, but a local variable inside a table constructor is evaluated only once, while the table is being constructed. That's why, in the following code, <code class="literal">Tbl.Str</code> is still <code class="literal">"before"</code> even after <code class="literal">Str</code> has been set to <code class="literal">"after"</code>:<a id="IDX-CHP-4-0075" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>do</code></strong>
&gt;&gt;   <strong class="userinput"><code>local Str = "before"</code></strong>
&gt;&gt;   <strong class="userinput"><code>Fnc = function() return Str end</code></strong></pre><pre class="programlisting">&gt;&gt;   <strong class="userinput"><code>Tbl = {Str = Str}</code></strong>
&gt;&gt;   <strong class="userinput"><code>Str = "after"</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>print(Fnc())</code></strong>
after
&gt; <strong class="userinput"><code>print(Tbl.Str)</code></strong>
before</pre><p>It's easy to get an upvalue-like effect by assigning to a table field instead of a local, like this:<a id="IDX-CHP-4-0076" class="indexterm"></a><a id="IDX-CHP-4-0077" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>do</code></strong>
&gt;&gt;   <strong class="userinput"><code>local Str = "before"</code></strong>
&gt;&gt;   <strong class="userinput"><code>Tbl = {Str = Str}</code></strong>
&gt;&gt;   <strong class="userinput"><code>Tbl.Str = "after"</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>print(Tbl.Str)</code></strong>
after</pre><p>If you want multiple tables to share state, have them share a subtable, as <code class="literal">Tbl1</code> and <code class="literal">Tbl2</code> share <code class="literal">SubTbl</code> here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>do</code></strong>
&gt;&gt;   <strong class="userinput"><code>local SubTbl = {Str = "before"}</code></strong>
&gt;&gt;   <strong class="userinput"><code>Tbl1 = {SubTbl = SubTbl}</code></strong>
&gt;&gt;   <strong class="userinput"><code>Tbl2 = {SubTbl = SubTbl}</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>Tbl1.SubTbl.Str = "after"</code></strong>
&gt; <strong class="userinput"><code>print(Tbl2.SubTbl.Str)</code></strong>
after</pre><div class="blockquote"><blockquote class="blockquote"><p>If you're familiar with the distinction between pass by value and pass by reference, you may think that Lua passes immutable values by value and mutable values by reference, but that isn't true—arguments are always passed by value. A function's caller can tell whether the function did an indexing assignment to a table the caller gave it, but not whether the function did a regular assignment to one of its arguments.</p><p>If you absolutely needed to use the language of values versus references to describe Lua's treatment of mutable values, you could say that mutable values themselves are references.</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="copying_tables"></a>Copying Tables</h2></div></div></div><p>Sometimes you need to make a copy of a table. For example, if you want to sort a table without altering the unsorted table, you need to make a copy and sort that. The simplest way (which is all you need in many circumstances) is to make a <span class="emphasis"><em>shallow copy</em></span>:<a id="IDX-CHP-4-0078" class="indexterm"></a></p><pre class="programlisting">-- Makes a shallow copy of a table:
function ShallowCopy(Src)
  local Dest = {}
  for Key, Val in pairs(Src) do
    Dest[Key] = Val
  end
  return Dest
end</pre><p>In this example, <code class="literal">ShallowCopy</code> creates a fresh table (<code class="literal">Dest</code>) and then loops through all key-value pairs in <code class="literal">Src</code>, putting each value into <code class="literal">Dest</code> at the appropriate key. (<code class="literal">Src</code> and <code class="literal">Dest</code> stand for "source" and "destination.") This is called a shallow copy because it doesn't burrow deep into <code class="literal">Src</code>—if any of <code class="literal">Src</code>'s values or keys are tables, those very tables will be put into <code class="literal">Dest</code>, not copies of them. Copying subtables as well as the top level of a table is called making a <span class="emphasis"><em>deep copy</em></span>. You can change a <code class="literal">ShallowCopy</code> to make a deep copy by adding the following two lines (and the name, of course):<a id="IDX-CHP-4-0079" class="indexterm"></a></p><pre class="programlisting">-- Makes a deep copy of a table. Doesn't properly handle
-- duplicate subtables.
function DeepCopy(Src)
  local Dest = {}
  for Key, Val in pairs(Src) do
    Key = type(Key) == "table" and DeepCopy(Key) or Key
    Val = type(Val) == "table" and DeepCopy(Val) or Val
    Dest[Key] = Val
  end
  return Dest
end</pre><p>The new lines test whether a key or value is a table. If it is, they call <code class="literal">DeepCopy</code> recursively to make a deep copy of it. Unlike <code class="literal">ShallowCopy</code>, a copy made by <code class="literal">DeepCopy</code> will never have any subtables in common with the original, which means that the copy can have side effects without affecting the original. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Body1 = {Head = {"Eyes", "Nose", "Mouth", "Ears"},</code></strong>
&gt;&gt;   <strong class="userinput"><code>Arms = {Hands = {"Fingers"}},</code></strong>
&gt;&gt;   <strong class="userinput"><code>Legs = {Feet = {"Toes"}}}</code></strong>
&gt; <strong class="userinput"><code>Body2 = DeepCopy(Body1)</code></strong>
&gt; <strong class="userinput"><code>print(Body1.Legs.Feet[1], Body2.Legs.Feet[1])</code></strong>
Toes Toes
&gt; <strong class="userinput"><code>Body2.Legs.Feet[1] = "Piggies"</code></strong>
&gt; <strong class="userinput"><code>-- If ShallowCopy had been used, this would print</code></strong>
&gt; <strong class="userinput"><code>-- Piggies Piggies:</code></strong>
&gt; <strong class="userinput"><code>print(Body1.Legs.Feet[1], Body2.Legs.Feet[1])</code></strong>
Toes    Piggies
&gt;</pre><p>There are two problems with this version of <code class="literal">DeepCopy</code>. One is that it treats functions the same as it treats anything else that isn't a table—it doesn't make copies of them. There are ways to copy functions, but none of them is completely general, unless you use an add-on library such as Pluto. (A general solution needs to treat upvalues correctly, including upvalues shared between functions.) Copying functions is seldom necessary, though, so you can ignore this problem here.</p><div class="blockquote"><blockquote class="blockquote"><p>Pluto is a persistence library, which means that it allows arbitrary Lua values to be saved to disk and reloaded later, even after Lua has been restarted. It's available at <code class="literal">luaforge.net</code>.</p></blockquote></div><p>The other problem is more serious. If a table appears more than once within the table being copied, it shows up as different tables in the copy. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>SubTbl = {}</code></strong>
&gt; <strong class="userinput"><code>Orig = {SubTbl, SubTbl, SubTbl}</code></strong>
&gt; <strong class="userinput"><code>Copy = DeepCopy(Orig)</code></strong>
&gt; <strong class="userinput"><code>-- Orig contains the same table three times:</code></strong></pre><pre class="programlisting">&gt; <strong class="userinput"><code>for I, SubTbl in ipairs(Orig) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(I, SubTbl)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
1  table: 0x4a0538
2  table: 0x4a0538
3  table: 0x4a0538
&gt; <strong class="userinput"><code>-- Copy contains three different tables:</code></strong>
&gt; <strong class="userinput"><code>for I, SubTbl in ipairs(Copy) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(I, SubTbl)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
1  table: 0x4a0a08
2  table: 0x4a0a48
3  table: 0x4a0a98</pre><p>Something even more interesting happens when you pass <code class="literal">DeepCopy</code> a table that has a <span class="emphasis"><em>cycle</em></span>. A table is said to have a cycle if it contains any table (including itself) that directly or indirectly contains itself. In the following example, <code class="literal">T</code> is such a table; to copy it, <code class="literal">DeepCopy</code> first needs to copy <code class="literal">T.T</code>, but to copy that, it needs to copy <code class="literal">T.T.T</code>, and so on. Because these are all the same table, <code class="literal">DeepCopy</code> keeps recursing until it runs out of stack space or you interrupt it:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {}</code></strong>
&gt; <strong class="userinput"><code>T.T = T</code></strong>
&gt; <strong class="userinput"><code>-- The same table, within itself:</code></strong>
&gt; <strong class="userinput"><code>print(T, T.T.T.T.T.T.T)</code></strong>
table: 0x495478 table: 0x495478
&gt; <strong class="userinput"><code>T2 = DeepCopy(T)</code></strong>
stdin:3: stack overflow
stack traceback:
       stdin:3: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       ...
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:5: in function 'DeepCopy'
       stdin:1: in main chunk
       [C]: ?</pre><p>There is a general solution to this problem, and it involves keeping track of what tables have already been copied. You use it in the following Try It Out.</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_copying_subtables_corre"></a>Try It Out: Copying Subtables Correctly</h3></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Enter this version of <code class="literal">DeepCopy</code> into an interpreter session:</p><pre class="programlisting">-- Makes a deep copy of a table. This version of DeepCopy
-- properly handles duplicate subtables, including cycles.
-- (The Seen argument is only for recursive calls.)
function DeepCopy(Src, Seen)
  local Dest
  if Seen then
    -- This will only set Dest if Src has been seen before:
    Dest = Seen[Src]
  else
    -- Top-level call; create the Seen table:
    Seen = {}
  end
  -- If Src is new, copy it into Dest:
  if not Dest then
    -- Make a fresh table and record it as seen:
    Dest = {}
    Seen[Src] = Dest
    for Key, Val in pairs(Src) do
      Key = type(Key) == "table" and DeepCopy(Key, Seen) or Key
      Val = type(Val) == "table" and DeepCopy(Val, Seen) or Val
      Dest[Key] = Val
    end
  end
  return Dest
end</pre></li><li class="listitem"><p>Now test it with a particularly hairy case—a table that contains itself as both a key and a value:</p><pre class="programlisting">&gt; <strong class="userinput"><code>T = {}</code></strong>
&gt; <strong class="userinput"><code>T[T] = T</code></strong>
&gt; <strong class="userinput"><code>T2 = DeepCopy(T)</code></strong>
&gt; <strong class="userinput"><code>-- T2 really is cyclical:</code></strong>
&gt; <strong class="userinput"><code>print(T2[T2][T2][T2][T2][T2][T2])</code></strong>
table: 0x703198
&gt; <strong class="userinput"><code>-- And a side effect to it isn't visible in the source</code></strong>
&gt; <strong class="userinput"><code>-- table:</code></strong>
&gt; <strong class="userinput"><code>T2.Test = "test"</code></strong>
&gt; <strong class="userinput"><code>print(T2[T2][T2][T2].Test)</code></strong>
test
&gt; <strong class="userinput"><code>print(T[T][T][T].Test)</code></strong>
nil</pre></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-009"></a>How It Works</h3></div></div></div><p>This version of <code class="literal">DeepCopy</code> works by storing every copy it makes as a value in an associative table, the key being that copy's source table. That lets it avoid making more than one copy of a given table. This mapping between already seen source and destination tables is in the second argument of <code class="literal">DeepCopy</code>, which is <code class="literal">Seen</code>.</p><p>When you called <code class="literal">DeepCopy</code>, you gave it only one argument. It saw that <code class="literal">Seen</code> was <code class="literal">nil</code> and initialized it to an empty table. It then saw that <code class="literal">Dest</code> was <code class="literal">nil</code> (because it hadn't been found in <code class="literal">Seen</code>), so it created a fresh destination table, assigned it to <code class="literal">Dest</code>, and established an association between the source table and the destination table in <code class="literal">Seen</code>. Then it looped through <code class="literal">Src</code>. This part of <code class="literal">DeepCopy</code> is almost the same as the previous version. The only difference is that recursive calls pass the <code class="literal">Seen</code> argument. When the first recursive call (for <code class="literal">Key</code>) was made, that call saw that <code class="literal">Seen</code> was set, so it assigned <code class="literal">Seen[Src]</code> to <code class="literal">Dest</code>. If <code class="literal">Src</code> had not been seen yet, that assignment would have done nothing, and the loop inside the next <code class="literal">if</code> statement would have been entered. But in this case, a table got assigned to <code class="literal">Dest</code>, so the loop was skipped. The same happened with the second recursive call (for <code class="literal">Val</code>).<a id="IDX-CHP-4-0080" class="indexterm"></a></p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="building_other_data_structures_from_tabl"></a>Building Other Data Structures from Tables</h1></div></div></div><p>In Lua, tables serve the same purposes as what other languages call tables, dictionaries, associative arrays, or hash tables, such as the following:</p><pre class="programlisting">Potluck = {John = "chips", Jane = "lemonade",
     Jolene = "egg salad"}</pre><p>and what other languages call arrays or vectors, such as these:</p><pre class="programlisting">Days = {"Monday", "Tuesday", "Wednesday", "Thursday",
     "Friday", "Saturday", "Sunday"}</pre><p>You can build other data structures out of tables as well. For example, you can use <code class="literal">table.insert</code> and <code class="literal">table.remove</code> to treat a table as a stack, and use tables within tables to represent tree-structured data—data that branches out like a tree, as shown in <a class="link" href="ch04.html#figure_4-7" title="Figure 4.7. Figure 4-7">Figure 4-7</a>.</p><div class="figure"><a id="figure_4-7"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0407.png" height="307" alt="Figure 4-7" width="546"></div></div><p class="title"><strong>Figure 4.7. Figure 4-7</strong></p></div><p>The diagram in the figure could be represented as follows:</p><pre class="programlisting">{Person = {
         Living = {"Roberto Ierusalimschy", "Gary Larson"},</pre><pre class="programlisting">Dead = {"Jane Austen", "Archimedes"}},
Place = {"Rio de Janeiro", "The North Pole"}}</pre><p>Special-purpose data structures like these can be accessed and manipulated like ordinary tables, but if they behave differently enough from tables, you can write special-purpose functions that work with them. It may be convenient to use the colon syntax to attach such functions to the data structures themselves. The following Try It Out is an example of this. It's an implementation of a <span class="emphasis"><em>ring</em></span>, a data structure that is something like a stack, except the top (referred to in the exercise as the current element) can be moved, and the top and bottom act like they're hooked onto each other.<a id="IDX-CHP-4-0081" class="indexterm"></a></p><div class="sidebar"><a id="try_it_out_colon_using_a_table_as_a_ring"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Using a Table as a Ring</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Save the following file as <code class="literal">ring.lua</code>:</p><pre class="programlisting">-- A ring data structure:

-- Returns X mod Y, but one-based: the return value will
-- never be less than 1 or greater than Y. (Y is assumed to
-- be positive.)
local function OneMod(X, Y)
  return (X - 1) % Y + 1
end

-- A table in which to create the methods:
local Methods = {}

-- Inserts a new element into self:
function Methods:Push(Elem)
  table.insert(self, self.Pos, Elem)
end

-- Removes the current element from self; returns nil if
-- self is empty:
function Methods:Pop()
  local Ret
  if #self &gt; 0 then
    Ret = table.remove(self, self.Pos)
    -- Keep self.Pos from pointing outside the array by
    -- wrapping it around:
    if self.Pos &gt; #self then
      self.Pos = 1
    end
  end
  return Ret
end

-- Rotates self to the left:
function Methods:RotateL()
  if #self &gt; 0 then
    self.Pos = OneMod(self.Pos + 1, #self)
  end
end

-- Rotates self to the right:</pre><pre class="programlisting">function Methods:RotateR()
  if #self &gt; 0 then
    self.Pos = OneMod(self.Pos - 1, #self)
  end
end

-- Returns the ring's size:
function Methods:Size()
  return #self
end

-- Returns a string representation of self:
function Methods:ToString()
  -- Convert the parts of self to the left and to the right
  -- of self.Pos to strings:
  local LeftPart = table.concat(self, ", ", 1, self.Pos - 1)
  local RightPart = table.concat(self, ", ", self.Pos, #self)
  -- Only put a separator between them if neither is the
  -- empty string:
  local Sep
  if LeftPart == "" or RightPart == "" then
    Sep = ""
  else
    Sep = ", "
  end
  -- RightPart's first element is self.Pos, so put it first:
  return RightPart .. Sep .. LeftPart
end

-- Instantiates a ring:
function MakeRing(Ring)
  -- Make an empty ring if an array of initial ring values
  -- wasn't passed in:
  Ring = Ring or {}
  -- Ring.Pos is the position of the current element of the
  -- ring; initialize it to 1 (all methods that expect
  -- there to be a current element first make sure the ring
  -- isn't empty):
  Ring.Pos = 1
  -- Give the ring methods and return it:
  for Name, Fnc in pairs(Methods) do
    Ring[Name] = Fnc
  end
  return Ring
end</pre></li><li class="listitem"><p>Start <code class="literal">lua</code> as follows (this will run <code class="literal">ring.lua</code> and then enter interactive mode):</p><pre class="programlisting">lua -i ring.lua</pre></li><li class="listitem"><p>Within interactive mode, use the function <code class="literal">MakeRing</code> to create a ring, and use that ring's methods to manipulate it:</p><pre class="programlisting">&gt; <strong class="userinput"><code>R = MakeRing{"the", "time", "has", "come"} -- Another use</code></strong>
&gt; <strong class="userinput"><code>-- for the syntax from the "<a class="link" href="ch04.html#keyword_arguments" title="Keyword Arguments">Keyword Arguments</a>" section.</code></strong>
&gt; <strong class="userinput"><code>print(R:ToString())</code></strong>
the, time, has, come
&gt; <strong class="userinput"><code>print(R:Pop())</code></strong>
the
&gt; <strong class="userinput"><code>R:Push("today")</code></strong>
&gt; <strong class="userinput"><code>print(R:ToString())</code></strong>
today, time, has, come
&gt; <strong class="userinput"><code>R:RotateL()</code></strong>
&gt; <strong class="userinput"><code>print(R:ToString())</code></strong>
time, has, come, today
&gt; <strong class="userinput"><code>print(R:Pop(), R:Pop(), R:Pop())</code></strong>
time    has     come
&gt; <strong class="userinput"><code>R:Push("here")</code></strong>
&gt; <strong class="userinput"><code>print(R:ToString(), R:Size())</code></strong>
here, today     2
&gt; <strong class="userinput"><code>R:Push("tomorrow")</code></strong>
&gt; <strong class="userinput"><code>R:Push("gone")</code></strong>
&gt; <strong class="userinput"><code>print(R:ToString())</code></strong>
gone,   tomorrow,   here,   today
&gt; <strong class="userinput"><code>R:RotateR()</code></strong>
&gt; <strong class="userinput"><code>print(R:ToString())</code></strong>
today,  gone,       tomorrow,   here
&gt; <strong class="userinput"><code>R:RotateR()</code></strong>
&gt; print(R:ToString())
here, today, gone, tomorrow</pre></li></ol></div><p><span class="strong"><strong>How It Works</strong></span></p><p><code class="literal">MakeRing</code> instantiates a new ring. If you call it with no argument, it makes an empty ring, but if you call it with an array, it uses that array's elements as the elements of the ring (the first element is the initial current element). A ring has the following six methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">Push</code>—Adds a new element to the ring.</p></li><li class="listitem"><p><code class="literal">Pop</code>—Removes the current element from the ring and returns it.</p></li><li class="listitem"><p><code class="literal">RotateL</code>—Rotates the ring left by one element.</p></li><li class="listitem"><p><code class="literal">RotateR</code>—Rotates the ring right by one element.</p></li><li class="listitem"><p><code class="literal">Size</code>—Returns the size of the ring.</p></li><li class="listitem"><p><code class="literal">ToString</code>—Returns a string listing all elements of the ring, with the current one first.</p></li></ul></div><div class="blockquote"><blockquote class="blockquote"><p>When used in the context of stacks and related structures, <code class="literal">Push</code> and <code class="literal">Pop</code> mean insert and remove.</p></blockquote></div><p>A ring is represented as an array with a <code class="literal">Pos</code> field that points to its current element. For example, take a look at the ring in <a class="link" href="ch04.html#figure_4-8" title="Figure 4.8. Figure 4-8">Figure 4-8</a>.<a id="IDX-CHP-4-0082" class="indexterm"></a><a id="IDX-CHP-4-0083" class="indexterm"></a><a id="IDX-CHP-4-0084" class="indexterm"></a></p><div class="figure"><a id="figure_4-8"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0408.png" width="459" alt="Figure 4-8" height="403"></div></div><p class="title"><strong>Figure 4.8. Figure 4-8</strong></p></div><p>This ring could be represented as any of the following (the methods are left out for clarity):</p><pre class="programlisting">{"the", "time", "has", "come", Pos = 1}

{"come", "the", "time", "has", Pos = 2}

{"has", "come", "the", "time", Pos = 3}

{"time", "has", "come", "the", Pos = 4}</pre></div><p>Rotatinsg a ring takes the same amount of time no matter how big the ring is. But pushing or popping an element can take an amount of time proportional to the size of the ring. More specifically, it takes an amount of time proportional to the number of elements from <code class="literal">Pos</code> to the end of the array. That's because when <code class="literal">table.insert</code> and <code class="literal">table.remove</code> insert or remove an item into or from the middle of an array, they need to go through every element between there and the end of the array and shift them up or down to compensate. This implementation of rings was written that way because it's simple and easy to understand, and the time that it takes to push or pop is not even noticeable in most circumstances.</p><p>If pushing and popping does consume a problematic amount of time, either because of the sheer size of a ring, or because a bunch of pushes or pops were being done in a time-critical section of code, then you could <span class="emphasis"><em>optimize</em></span> the rings—reimplementing them in a more efficient way using a different representation. One simple optimization would be to arrange for <code class="literal">Pos</code> to go up on pushes and down on pops. This way, when <code class="literal">Pos</code> hits the sweet spot at the end of the array, it would stay at the end unless the ring was rotated.</p><p>Another optimization would be to represent each element as a table with a <code class="literal">Val</code> field (that element's value), and <code class="literal">Left</code> and <code class="literal">Right</code> fields (the tables of the elements counterclockwise and clockwise from that element). Doing it that way has the advantage of making pushes and pops take the same amount of time no matter how big the ring is. It's more complicated, though, because pushes and pops have to do the correct relinking of the <code class="literal">Left</code> and <code class="literal">Right</code> fields of the element in question, and those of its two neighbors. Additionally, each push creates a new table, which takes more time than simply inserting a value sufficiently close to the end of an array, so for rings with less than 50 or 60 elements, this approach is actually slower than the worst case of the version given in <code class="literal">ring.lua</code>.<a id="IDX-CHP-4-0085" class="indexterm"></a></p><p>A good rule of thumb is to first write something in as simple and clear a way as possible, test it to make sure it's correct, and then <span class="emphasis"><em>don't</em></span> optimize it—unless it's slowing the whole program down enough to detract from the program's usability.</p><p>Here are a few more comments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Other than <code class="literal">ToString</code>, which expects everything in the ring to be a string or a number, <code class="literal">ring.lua</code>'s rings can hold any value—except for <code class="literal">nil</code>. There are (at least) a couple ways to fix this. One is to replace <code class="literal">table.insert</code> and <code class="literal">table.remove</code> with code that can handle a <code class="literal">nil</code>, and use a field in <code class="literal">self</code> to keep track of the size instead of <code class="literal">#</code>. The other is to create a value that won't be equal to any other value that might be pushed into the ring, and use that value to represent <code class="literal">nil</code>. So <code class="literal">Push</code>, when given a <code class="literal">nil</code>, would push that value instead, and <code class="literal">Pop</code>, when popping that value, would return <code class="literal">nil</code>. You can use a do-nothing function or an empty table for the value.<a id="IDX-CHP-4-0086" class="indexterm"></a></p></li><li class="listitem"><p>The size of the ring is measurable with the <code class="literal">#</code> operator, but that might no longer be true if the implementation were changed. That's why there's a <code class="literal">Size</code> method: it hides the details of how the size is kept track of.</p></li><li class="listitem"><p>The only global variable set by <code class="literal">ring.lua</code> is <code class="literal">MakeRing</code> because it's the only thing needed to create a ring.</p></li><li class="listitem"><p>The local function <code class="literal">OneMod</code> is there to make the rotation methods easier to read by abstracting away a bit of arithmetic.</p></li><li class="listitem"><p>You can use <code class="literal">lua -i filename</code> to write, test, and debug code. If you make a change in the file, and you don't want to exit the interpreter just to reload it, call <code class="literal">dofile</code> with the filename, such as <code class="literal">dofile("ring.lua")</code>. If you want to test a local function (such as <code class="literal">OneMod</code>), you can make it global for long enough to test it and then relocalize it.</p></li><li class="listitem"><p>The guts of this implementation are not hidden, which means that goofy fiddling like <code class="literal">R.Pos = −1</code> can be done. This is fine in a prototype, but you want to prevent it in code intended for serious use. One way would be to put nothing but methods in the tables returned by <code class="literal">MakeRing</code>. There would be an upvalue containing a table whose keys would be the tables returned by <code class="literal">MakeRing</code>, and whose values would be tables with <code class="literal">Pos</code> and the contents of the corresponding ring. Only <code class="literal">MakeRing</code> and the methods would have access to that upvalue. When a method wanted to get at the contents or position of its ring, it would index the upvalue with <code class="literal">self</code>. Another way of protecting an object's guts from fiddling is described in <a class="link" href="ch11.html" title="Chapter 11. Exploring Lua's Libraries">Chapter 11</a>.</p></li></ul></div><p>Because of tables' flexibility, you often don't need a customized data structure. Just ask yourself how you most often want to access your data—usually an associative table or an array will do the job. For instance, the task of finding a user's information based on his or her username is obviously suited to an associative table whose keys are usernames and whose values are tables of information about each user. The task of displaying all users in alphabetical order by username is suited to a sorted array. It's common to create ad hoc tables to do something that the main table you're using can't do. If you were working with an associative table like the one described previously, keyed by usernames, but you wanted to do something that grouped users by last name, you could create a table like the following, with last names as keys and arrays of users as values:<a id="IDX-CHP-4-0087" class="indexterm"></a><a id="IDX-CHP-4-0088" class="indexterm"></a><a id="IDX-CHP-4-0089" class="indexterm"></a><a id="IDX-CHP-4-0090" class="indexterm"></a></p><pre class="programlisting">local LastUsers = {} -- Keys: last names; vals: arrays of
    -- UserInfos.
for Username, UserInfo in pairs(Users) do
   -- If this last name hasn't been seen yet, make an empty array:
   LastUsers[UserInfo.LastName] = LastUsers[UserInfo.LastName] or {}
   table.insert(LastUsers[UserInfo.LastName], UserInfo)
end</pre></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="custom-made_loops"></a>Custom-Made Loops</h1></div></div></div><p>Most times when you want to loop through a table, <code class="literal">pairs</code> or <code class="literal">ipairs</code> is appropriate, but if neither is, you can instead write and use your own function. Here, for example, is a function similar to <code class="literal">ipairs</code>, but it goes through the array given to it in reverse order:</p><pre class="programlisting">-- An iterator factory -- like ipairs, but goes through the
-- array in reverse order:
function ReverseIpairs(Arr)
    local I = #Arr

    local function Iter()
        local Ret1, Ret2
        if I &gt; 0 then
           Ret1, Ret2 = I, Arr[I]
           I = I - 1
        end
        return Ret1, Ret2
    end

    return Iter
end

for I, Str in ReverseIpairs({"one", "two", "three"}) do
    print(I, Str)
end</pre><p>The output is as follows:</p><pre class="programlisting">3  three
2  two
1  one</pre><p>The <code class="literal">Iter</code> function is what is known in the Lua world as an <span class="emphasis"><em>iterator</em></span>. In the simplest terms, an iterator is a function that, each time you call it, returns the next element or elements from the thing you're looping through. The generic <code class="literal">for</code> expects to find an iterator to the right of the keyword <code class="literal">in. ReverseIpairs</code> is not an iterator—it, like <code class="literal">ipairs</code> and <code class="literal">pairs</code>, is an <span class="emphasis"><em>iterator factory</em></span>—a function that returns an iterator.<a id="IDX-CHP-4-0091" class="indexterm"></a><a id="IDX-CHP-4-0092" class="indexterm"></a><a id="IDX-CHP-4-0093" class="indexterm"></a></p><p>(This book follows that terminological distinction, but elsewhere, you may see iterator factories referred to as iterators, when the context makes it clear what's being talked about.) In this example, the <code class="literal">for</code> does not find <code class="literal">ReverseIpairs</code> to the right of the <code class="literal">in</code>, but <code class="literal">Iter</code>, because that's what the call to <code class="literal">ReverseIpairs</code> returns. The <code class="literal">for</code> then calls <code class="literal">Iter</code>, puts its results into the newly created local <code class="literal">I</code> and <code class="literal">Str</code> variables, and executes the body of the loop. It keeps on doing this until <code class="literal">Iter</code>'s first return value is <code class="literal">nil</code>, at which point the loop is exited.<a id="IDX-CHP-4-0094" class="indexterm"></a></p><p>That last sentence is a rule about all iterators. That is, when an iterator returns <code class="literal">nil</code> as its first value (or when it returns nothing, which <code class="literal">for</code> adjusts to <code class="literal">nil</code>), the loop is ended. For this reason, the leftmost loop variable (which receives the iterator's first return value) is called the loop's <span class="emphasis"><em>control variable</em></span>.<a id="IDX-CHP-4-0095" class="indexterm"></a></p><p>This implementation of <code class="literal">ReverseIpairs</code> returns what is called a <span class="emphasis"><em>stateful</em></span> iterator because it includes (as the upvalues <code class="literal">Arr</code> and <code class="literal">I</code>) the current state of the iteration. You can also write <span class="emphasis"><em>stateless</em></span> iterators, which depend on <code class="literal">for</code> to keep track of the current state of the iteration for them.</p><p>Try this stateless version of <code class="literal">ReverseIpairs</code>:</p><pre class="programlisting">do -- Local scope for Iter.
   -- ReverseIpairs's iterator; Arr is the "invariant state",
   -- and I is the control variable's previous value:
   local function Iter(Arr, I)
       if I &gt; 1 then
         I = I - 1
         return I, Arr[I] -- Violates structured programming
             -- (not a severe misdeed in such a small function).
      end
    end

     -- An iterator factory -- like ipairs, but goes through
     -- the array in reverse order:
     function ReverseIpairs(Arr)
         return Iter, Arr, #Arr + 1
      end
end

for I, Str in ReverseIpairs({"one", "two", "three"}) do
    print(I, Str)
end</pre><p>It prints the same thing as the stateful version:</p><pre class="programlisting">3  three
2  two
1  one</pre><p>The generic <code class="literal">for</code> actually expects up to three values to the right of the <code class="literal">in</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The iterator itself</p></li><li class="listitem"><p>An <span class="emphasis"><em>invariant state</em></span> (<code class="literal">nil</code> in a stateful iterator, and usually the table being looped through in a stateless iterator)<a id="IDX-CHP-4-0096" class="indexterm"></a><a id="IDX-CHP-4-0097" class="indexterm"></a></p></li><li class="listitem"><p>A seed value for the loop's control variable (<code class="literal">nil</code> in a stateful iterator and in some stateless iterators)</p></li></ul></div><p>Every time <code class="literal">for</code> calls the iterator, it passes it two arguments: the invariant state and the value of the control variable from the previous iteration. That's why it needs the seed value—to have something to pass the iterator before the first iteration.</p><p>In the example, <code class="literal">ReverseIpairs</code> returns <code class="literal">Iter</code>, the array it was given (the invariant state), and the length of the array plus one (the seed value for the control variable). <code class="literal">for</code> then calls <code class="literal">Iter</code> with the array and the seed value. <code class="literal">Iter</code> doesn't know that it's being called on the first iteration. It just sees that its second argument is <code class="literal">4</code> and, in effect, thinks to itself: "If the last value of the control variable was <code class="literal">4</code>, then it's time for me to return <code class="literal">3</code> and the 3rd element of my first argument." <code class="literal">for</code> assigns these values to <code class="literal">I</code> and <code class="literal">Str</code>, and executes the body of the loop. Then it calls <code class="literal">Iter</code> again, with the array and <code class="literal">3</code> as arguments. This process continues until the last time <code class="literal">Iter</code> is called. Because its second argument is <code class="literal">1</code>, it returns nothing. <code class="literal">for</code> looks at <code class="literal">Iter</code>'s first return value and, seeing it to be (after adjustment) <code class="literal">nil</code>, ends the loop.</p><p>The built-in function <code class="literal">next</code> is a stateless iterator. It takes a table and a key in that table and returns the "next" key-value pair in the table, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>NameToInstr = {John = "rhythm guitar",</code></strong>
&gt;&gt;   <strong class="userinput"><code>Paul = "bass guitar",</code></strong>
&gt;&gt;   <strong class="userinput"><code>George = "lead guitar",</code></strong>
&gt;&gt;   <strong class="userinput"><code>Ringo = "drumkit"}</code></strong>
&gt; <strong class="userinput"><code>print(next(NameToInstr, "Ringo"))</code></strong>
George lead guitar
&gt; <strong class="userinput"><code>print(next(NameToInstr, "George"))</code></strong>
John rhythm guitar
&gt; <strong class="userinput"><code>print(next(NameToInstr, "John"))</code></strong>
Paul    bass guitar</pre><p>If given the seed value <code class="literal">nil</code>, it returns the "first" key-value pair in the table, and if given the "last" key in the table, it returns <code class="literal">nil</code>, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(next(NameToInstr))</code></strong>
Ringo   drumkit
&gt; <strong class="userinput"><code>print(next(NameToInstr, "Paul"))</code></strong>
nil</pre><p>"Next," "first," and "last" are in quotes here because the order of the table is arbitrary. But it's the same arbitrary order in which <code class="literal">pairs</code> loops through a table. In fact, all <code class="literal">pairs</code> does is return <code class="literal">next</code>, the table given to it, and <code class="literal">nil</code>, so that if you write one of the following:</p><pre class="programlisting">for Key, Val in next, Tbl, nil do

for Key, Val in next, Tbl do</pre><p>it's the same as writing this:</p><pre class="programlisting">for Key, Val in pairs(Tbl) do</pre><p><code class="literal">pairs</code> has parentheses after it and <code class="literal">next</code> doesn't because <code class="literal">pairs</code> is an iterator factory and needs to be called, but <code class="literal">next</code> is an iterator and needs to be given straight to <code class="literal">for</code>.</p><div class="blockquote"><blockquote class="blockquote"><p>If you check it out, you'll see that <code class="literal">next</code> and the iterator returned by <code class="literal">pairs</code> are actually different functions, but that's just a quirk of the Lua implementation. Both are just wrappers around the same function written in C.<a id="IDX-CHP-4-0098" class="indexterm"></a></p></blockquote></div><p><code class="literal">ipairs</code> is similar. It returns a stateless iterator, the table given to it, and a seed value of <code class="literal">0</code>. The iterator (called <code class="literal">IpairsIter</code> in the following example) works by adding one to its second argument and returning that key-value pair of its first argument:</p><pre class="programlisting">&gt; <strong class="userinput"><code>IpairsIter, Arr, Seed = ipairs({"one", "two", "three"})</code></strong>
&gt; <strong class="userinput"><code>print(IpairsIter, Arr, Seed)</code></strong>
function: 0x480c68  table: 0x496230 0
&gt; <strong class="userinput"><code>print(IpairsIter(Arr, 0))</code></strong>
1       one
&gt; <strong class="userinput"><code>print(IpairsIter(Arr, 1))</code></strong>
2       two
&gt; <strong class="userinput"><code>print(IpairsIter(Arr, 2))</code></strong>
3       three
&gt; <strong class="userinput"><code>print(IpairsIter(Arr, 3)) -- This will return nothing.</code></strong>

&gt;</pre><p><code class="literal">IpairsIter</code> is not a built-in function, but it's easy to write. Here's how:</p><pre class="programlisting">function IpairsIter(Arr, PrevI)
  local CurI = PrevI + 1
  Val = Arr[CurI]
  if Val ~= nil then
    return CurI, Val
  end
end</pre><p>The behavior of the generic <code class="literal">for</code> is complex, but it allows <code class="literal">for</code> to be both flexible and efficient—flexible because an iterator can be written for anything you want to loop through, and efficient because a stateless iterator factory can return the same iterator every time, rather than creating a new closure each time it's called. If you're writing an iterator, and you can easily tell just by looking at the control variable's previous value what the next value should be, then write a stateless iterator; otherwise write a stateful one.</p><p>All of the iterator factories you've seen so far have only taken one argument, and all their iterators have returned two values after each iteration, but that's only because they're all for iterating through key-value pairs of tables. The following <code class="literal">Subseqs</code> iterator factory takes an array and a <code class="literal">Len</code> number, , and then returns an iterator that loops through the array's subsequences, each subsequence being <code class="literal">Len</code> elements long:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- Returns an iterator that goes through all Len-long</code></strong>
&gt; <strong class="userinput"><code>-- subsequences of Arr:</code></strong>
&gt; <strong class="userinput"><code>function Subseqs(Arr, Len)</code></strong>
&gt;&gt;   <strong class="userinput"><code>local Pos = 0</code></strong>
&gt;&gt;
&gt;&gt;   <strong class="userinput"><code>return function()</code></strong>
&gt;&gt;     <strong class="userinput"><code>Pos = Pos + 1</code></strong>
&gt;&gt;     <strong class="userinput"><code>if Pos + Len - 1 &lt;= #Arr then</code></strong></pre><pre class="programlisting">&gt;&gt;     <strong class="userinput"><code>return unpack(Arr, Pos, Pos + Len - 1)</code></strong>
&gt;&gt;     <strong class="userinput"><code>end</code></strong>
&gt;&gt;   <strong class="userinput"><code>end</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>Nums = {"one", "two", "three", "four", "five", "six"}</code></strong>
&gt; <strong class="userinput"><code>for Val1, Val2, Val3, Val4 in Subseqs(Nums, 4) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(Val1, Val2, Val3, Val4)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
one      two    three   four
two      three  four    five
three    four   five    six</pre><p>Here's an iterator (meant to be part of <code class="literal">ring.lua</code>) that only returns one value after each iteration—it loops through all values in the ring, starting with the current one:</p><pre class="programlisting">-- Returns an iterator that iterates through all self's
-- elements.
function Methods:Elems()
    local IterPos -- The position of the element the iterator
       -- needs to return

    return function()
       local Ret
       if IterPos then
          if IterPos ~= self.Pos then
             Ret = self[IterPos]
          else
             -- Back at the beginning; do nothing (which ends the
             -- loop by returning nil).
          end
        else
          -- At the beginning: initialize IterPos:
          IterPos = self.Pos
          Ret = self[IterPos] -- If the ring is empty, this'll
               -- end the loop by returning nil.
      end
      IterPos = OneMod(IterPos + 1, #self)
      return Ret
   end
end</pre><p>Here it is in use:</p><pre class="programlisting">&gt; <strong class="userinput"><code>dofile("ring.lua")</code></strong>
&gt; <strong class="userinput"><code>Days = MakeRing{"Monday", "Tuesday", "Wednesday",</code></strong>
&gt;&gt;   <strong class="userinput"><code>"Thursday", "Friday", "Saturday", "Sunday"}</code></strong>
&gt; <strong class="userinput"><code>Days:RotateR()</code></strong>
&gt; <strong class="userinput"><code>for Day in Days:Elems() do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(Day)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
Sunday
Monday</pre><pre class="programlisting">Tuesday
Wednesday
Thursday
Friday
Saturday</pre><p>The normal rules for adjustment apply to iterators and loop variables:<a id="IDX-CHP-4-0099" class="indexterm"></a><a id="IDX-CHP-4-0100" class="indexterm"></a><a id="IDX-CHP-4-0101" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Letters = {"a", "b", "c"}</code></strong>
&gt; <strong class="userinput"><code>for I in ipairs(Letters) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(I)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
1
2
3
&gt; <strong class="userinput"><code>for I, Letter, Junk1, Junk2 in ipairs(Letters) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(I, Letter, Junk1, Junk2)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
1       a       nil       nil
2       b       nil       nil
3       c       nil       nil</pre><p>You can write stateless iterators that ignore their second argument (and keep track of where they are by side-effecting the table given as the first argument), but this technique is seldom used.</p><p>You'll learn one more method for writing iterators in <a class="link" href="ch12.html" title="Chapter 12. Using Community Libraries">Chapter 12</a>.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="global_variable_environments"></a>Global Variable Environments</h1></div></div></div><p>You may have noticed similarities between global variables and table keys, such as their lack of distinction between <code class="literal">nil</code> and nonexistence. These similarities are not coincidental. Global variables are actually stored in a table. This table can be found in the global variable <code class="literal">_G</code>, as you can see in the following example:</p><div class="blockquote"><blockquote class="blockquote"><p>You can tell by looking at the numbers that <code class="literal">print</code> and <code class="literal">_G.print</code> are the same value, as are <code class="literal">_G</code> itself and <code class="literal">_G._G._G._G</code>, because <code class="literal">_G</code>, being both a global variable and a table containing all the global variables, contains itself.</p></blockquote></div><pre class="programlisting">&gt; <strong class="userinput"><code>print(print, _G.print)</code></strong>
function: 0x481720  function: 0x481720
&gt; <strong class="userinput"><code>MyGlobal = "Hello!"</code></strong>
&gt; <strong class="userinput"><code>print(MyGlobal, _G.MyGlobal)</code></strong>
Hello! Hello!
&gt; <strong class="userinput"><code>print(_G, _G._G._G._G)</code></strong>
table: 0x4806e8 table: 0x4806e8</pre><p>This means that you can access global variables whose names are strings built at run time (without resorting to <code class="literal">loadstring</code>), like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Abcd = "test 1"</code></strong>
&gt; <strong class="userinput"><code>print(_G["Ab" .. "cd"])</code></strong></pre><pre class="programlisting">test 1
&gt; <strong class="userinput"><code>_G["Wx" .. "yz"] = "test 2"</code></strong>
&gt; <strong class="userinput"><code>print(Wxyz)</code></strong>
test 2</pre><div class="blockquote"><blockquote class="blockquote"><p>For more on <code class="literal">loadstring</code>, see <a class="link" href="ch03.html" title="Chapter 3. Extending Lua with Functions">Chapter 3</a>.<a id="IDX-CHP-4-0102" class="indexterm"></a></p></blockquote></div><p>You can also loop through all global variables. Give the following code a try:</p><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">print</code> already puts a tab character between the things it prints. The extra <code class="literal">print</code> in the following example just makes it easier to read.</p></blockquote></div><pre class="programlisting">for Name, Val in pairs(_G) do
  print(Name, "\t", Val)
end</pre><p>A table used to store global variables is called an <span class="emphasis"><em>environment</em></span>, and every function has one. Usually they're all the same environment, but you can give a function its own environment with the function <code class="literal">setfenv</code> (short for set function environment). In the following example, you create a <code class="literal">Greet</code> function and give it an empty environment. This function tries to call <code class="literal">print</code>, but the <code class="literal">"print"</code> key in its environment is not set, so there's an error:</p><pre class="programlisting">&gt; <strong class="userinput"><code>function Greet(Name)</code></strong>
&gt;&gt;   <strong class="userinput"><code>print("Hello, " .. Name .. ".")</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>setfenv(Greet, {})</code></strong>
&gt; <strong class="userinput"><code>Greet("Syd")</code></strong>
stdin:2: attempt to call global 'print' (a nil value)
stack traceback:
       stdin:2: in function 'Greet'
       stdin:1: in main chunk
       [C]: ?</pre><p>When you give it an environment whose <code class="literal">"print"</code> key is set to the <code class="literal">print</code> function, it works as desired:</p><pre class="programlisting">&gt; <strong class="userinput"><code>setfenv(Greet, {print = print})</code></strong>
&gt; <strong class="userinput"><code>Greet("Syd")</code></strong>
Hello, Syd.</pre><p>Of course, the function could be called <code class="literal">print</code> but could do something different than the real <code class="literal">print</code>, as in the following example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Env = {print = function(Str)</code></strong>
&gt;&gt;   <strong class="userinput"><code>print("&lt;&lt;&lt;" .. Str .. "&gt;&gt;&gt;")</code></strong>
&gt;&gt; <strong class="userinput"><code>end}</code></strong>
&gt; <strong class="userinput"><code>setfenv(Greet, Env)</code></strong>
&gt; <strong class="userinput"><code>Greet("Syd")</code></strong>
&lt;&lt;&lt;Hello, Syd.&gt;&gt;&gt;</pre><p>Earlier it was said that some closures can be side-effected by calling them. Now you see that you can give side effects to all functions by calling <code class="literal">setfenv</code> on them.</p><p>A function's environment can be retrieved with the <code class="literal">getfenv</code> ("get function environment") function. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>PrintEnv, GreetEnv = getfenv(print), getfenv(Greet)</code></strong>
&gt; <strong class="userinput"><code>-- print's environment is different than Greet's environment:</code></strong>
&gt; <strong class="userinput"><code>print(PrintEnv, GreetEnv)</code></strong>
table: 0x4806e8 table: 0x493958
&gt; <strong class="userinput"><code>-- print's environment is the one in _G, Greet's isn't:</code></strong>
&gt; <strong class="userinput"><code>print(PrintEnv == _G, GreetEnv == _G)</code></strong>
true false</pre><p>Environment tables are just ordinary tables, and behave accordingly. In the previous example, because <code class="literal">PrintEnv</code> is the same as <code class="literal">_G</code>, any changes you make to <code class="literal">PrintEnv</code> will show up in <code class="literal">_G</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>PrintEnv.Test = "test"</code></strong>
&gt; <strong class="userinput"><code>print(_G.Test)</code></strong>
test
&gt; <strong class="userinput"><code>print(Test)</code></strong>
test</pre><p>Function environments can be used to modularize code by making global variables not so global. An example of this (the <code class="literal">module</code> function) is given in <a class="link" href="ch07.html" title="Chapter 7. Using Modules">Chapter 7</a>.</p><p>Another common use is <span class="emphasis"><em>sandboxing</em></span>, which means running code with a limited or otherwise specialized set of global variables. The environment you gave to <code class="literal">Greet</code> that only had <code class="literal">print</code> in it was a sandbox—<code class="literal">Greet</code> had no way of accessing any of Lua's other built-in functions. This sort of thing is useful if your program needs to run code supplied by a user, but you want to limit the power of the user to mess things up (either by assigning to global variables, or by calling functions that he or she shouldn't be calling). One way to make a sandbox is to make a table with all the globals that the sandboxed function is supposed to have access to—this is the technique you used in the <code class="literal">Greet</code> example. (It may be easier to use a function like <code class="literal">DeepCopy</code> to copy <code class="literal">_G</code>, and then remove anything you don't want it to contain.) Another, more flexible technique is explained in <a class="link" href="ch11.html" title="Chapter 11. Exploring Lua's Libraries">Chapter 11</a>.<a id="IDX-CHP-4-0103" class="indexterm"></a></p><p>The first argument to <code class="literal">setfenv</code> or <code class="literal">getfenv</code> can be a number instead of a function. The number is treated as a stack level, and the function at that level of the stack has its environment set or gotten. Lower numbers are closer to the top of the stack: <code class="literal">1</code> is the current function (the one calling <code class="literal">setfenv</code> or <code class="literal">getfenv</code>); <code class="literal">2</code> is the function that called the current function (and hence is right below it on the stack); <code class="literal">3</code> is the function that called the function that called the current function; and so on. (Calling <code class="literal">getfenv</code> with no argument is the same as calling it with an argument of <code class="literal">1</code>—it returns the current function's environment.) For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- Gives its caller an empty environment:</code></strong>
&gt; <strong class="userinput"><code>function PwnMe()</code></strong>
&gt;&gt;   <strong class="userinput"><code>setfenv(2, {})</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>do</code></strong>
&gt;&gt;   <strong class="userinput"><code>PwnMe()</code></strong>
&gt;&gt;   <strong class="userinput"><code>-- Global variables are missing now:</code></strong>
&gt;&gt;   <strong class="userinput"><code>print("test")</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong></pre><pre class="programlisting">stdin:4: attempt to call global 'print' (a nil value)
stack traceback:
       stdin:4: in main chunk
       [C]: ?
&gt; <strong class="userinput"><code>-- Since this is a new chunk now, things are back to</code></strong>
&gt; <strong class="userinput"><code>-- normal. That wouldn't be the case if this were a</code></strong>
&gt; <strong class="userinput"><code>-- script, and therefore all one chunk.</code></strong>
&gt; <strong class="userinput"><code>print("test")</code></strong>
test</pre><div class="blockquote"><blockquote class="blockquote"><p>For more on chunks, see <a class="link" href="ch03.html" title="Chapter 3. Extending Lua with Functions">Chapter 3</a>.</p></blockquote></div><p>This means that if you're sandboxing a function to prevent it from messing with its caller's global variables, you should not include either <code class="literal">setfenv</code> or <code class="literal">getfenv</code> in the sandbox.</p><p>When you create a function, it inherits the environment of its source function. That's why <code class="literal">DoNothing1</code> and <code class="literal">DoNothing2</code> have different environments in the following code, and they'll keep these environments until and unless you use <code class="literal">setfenv</code> on them:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- Returns a do-nothing function:</code></strong>
&gt; <strong class="userinput"><code>function MakeDoNothing()</code></strong>
&gt;&gt;   <strong class="userinput"><code>return function() end</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>EmptyTbl1, EmptyTbl2 = {}, {}</code></strong>
&gt; <strong class="userinput"><code>setfenv(MakeDoNothing, EmptyTbl1)</code></strong>
&gt; <strong class="userinput"><code>DoNothing1 = MakeDoNothing()</code></strong>
&gt; <strong class="userinput"><code>setfenv(MakeDoNothing, EmptyTbl2)</code></strong>
&gt; <strong class="userinput"><code>DoNothing2 = MakeDoNothing()</code></strong>
&gt; <strong class="userinput"><code>-- DoNothings 1 and 2 have the environments that</code></strong>
&gt; <strong class="userinput"><code>-- MakeDoNothing had when it created them:</code></strong>
&gt; <strong class="userinput"><code>print(getfenv(DoNothing1) == EmptyTbl1)</code></strong>
true
&gt; <strong class="userinput"><code>print(getfenv(DoNothing2) == EmptyTbl2)</code></strong>
true</pre><p>You cannot alter an environment of a function not written in Lua, as shown here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- This causes an error because print is written in C:</code></strong>
&gt; <strong class="userinput"><code>setfenv(print, {})</code></strong>
stdin:1: 'setfenv' cannot change environment of given object
stack traceback:
       [C]: in function 'setfenv'
       stdin:1: in main chunk
       [C]: ?</pre><p>This restriction is to protect functions written in low-level languages like C (which have much more power to mess things up) from unauthorized meddling by Lua functions.</p><div class="blockquote"><blockquote class="blockquote"><p>Like many restrictions in Lua, this one can be bypassed with the debug library, described in <a class="link" href="ch10.html" title="Chapter 10. Looking Under the Hood">Chapter 10</a>.</p></blockquote></div><p>There is a way, though, for you to set the environment used by the bottom frame of the stack. You'll learn how to do this in a moment, but first, here's a bit of background. The bottom frame of the stack is always in C (which is why stack tracebacks always end with "<code class="literal">[C]: ?</code>"). Its environment is called the <span class="emphasis"><em>global environment</em></span>. (This term is a bit confusing because all references to global variables are resolved by looking in an environment, but even if various functions/stack frames have different environments, only one of them is the <span class="emphasis"><em>global</em></span> environment.)<a id="IDX-CHP-4-0104" class="indexterm"></a><a id="IDX-CHP-4-0105" class="indexterm"></a></p><p>If you try to change the global environment by figuring out what stack level it's at, you'll get the same error given previously when you tried to give <code class="literal">setfenv</code> the <code class="literal">print</code> function:</p><pre class="programlisting">&gt; <strong class="userinput"><code>setfenv(2, {})</code></strong>
stdin:1: 'setfenv' cannot change environment of given object
stack traceback:
        [C]: in function 'setfenv'
        stdin:1: in main chunk
        [C]: ?</pre><p>The way to work around this is to use the magic number <code class="literal">0</code> as the first argument to <code class="literal">setfenv</code>. Chunks typed into the interpreter inherit the global environment. Then you set the global environment to a table with nothing in it but <code class="literal">_G</code> (the original global environment). After you do this, every chunk inherits that environment and thus can't access the standard global variables under their usual names. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>setfenv(0, {_G = _G})</code></strong>
&gt; <strong class="userinput"><code>-- Error message won't have tracebacks, as explained below.</code></strong>
&gt; <strong class="userinput"><code>print("This won't work.")</code></strong>
stdin:1: attempt to call global 'print' (a nil value)
&gt; <strong class="userinput"><code>_G.print("This won't either, since print calls tostring.")</code></strong>
attempt to call a nil value
&gt; <strong class="userinput"><code>tostring = _G.tostring</code></strong>
&gt; <strong class="userinput"><code>_G.print("Now that tostring is in place, this will work.")</code></strong>
Now that tostring is in place, this will work.
&gt; <strong class="userinput"><code>-- Undo the damage by putting the original global</code></strong>
&gt; <strong class="userinput"><code>-- environment back in place:</code></strong>
&gt; <strong class="userinput"><code>_G.setfenv(0, _G)</code></strong>
&gt; <strong class="userinput"><code>print("This works again!")</code></strong>
This works again!</pre><p>Note the following in this example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Although you can't access it with <code class="literal">setfenv</code> or <code class="literal">getfenv, print</code> has its own environment. That environment is unaffected by changing the global environment, because it is the original global environment, inherited by <code class="literal">print</code> when it was created. If <code class="literal">print</code> looked for <code class="literal">tostring</code>, it would find it, but it looks instead in the current global environment, where <code class="literal">tostring</code> is <code class="literal">nil</code>. (There's no hidden meaning to <code class="literal">print</code> looking in the global environment rather than its own; that's just how it was written.)</p></li><li class="listitem"><p>The error message has no stack traceback. That's because the stack traceback is created by calling the function <code class="literal">debug.traceback</code>. When the interpreter sees that this function is missing, it doesn't even try to call it.</p></li></ul></div><p><code class="literal">setfenv</code> returns the function whose environment it just set, or nothing if it's used to set the global environment, as shown here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>DoNothing = function() end</code></strong>
&gt; <strong class="userinput"><code>print(setfenv(DoNothing, _G) == DoNothing)</code></strong>
true
&gt; <strong class="userinput"><code>print(select("#", setfenv(0, _G)))</code></strong>
0</pre><div class="blockquote"><blockquote class="blockquote"><p>In Lua 5.0, <code class="literal">setfenv</code> never returns a value.<a id="IDX-CHP-4-0106" class="indexterm"></a></p></blockquote></div><p>If <code class="literal">getfenv</code> is passed a non-Lua function, it returns the global environment (not that function's real environment).</p><p>A function returned by <code class="literal">loadstring</code> (or by one of its cousins <code class="literal">load</code> and <code class="literal">loadfile</code>) inherits the current global environment.</p><p><code class="literal">_G</code> is just a regular global variable, with no magic behavior. When Lua starts up, it puts the global environment into <code class="literal">_G</code>, but if the global environment is changed to a different table, <code class="literal">_G</code> is not updated, and if you put a different table into <code class="literal">_G</code>, no environments are changed. <code class="literal">_G</code> is purely a convenience, and in the previous examples, it saved you from having to type a lot of <code class="literal">getfenv(0)</code>.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="summary-010"></a>Summary</h1></div></div></div><p>In this chapter, you examined tables and some other things that are easier to understand in relation to tables. What you learned included the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Tables are collections of key-value pairs, and they are Lua's only data structure.</p></li><li class="listitem"><p>Curly braces are used to create tables; square brackets and dots are used to read and assign to table fields.</p></li><li class="listitem"><p>There is no difference between a key not existing in a table, and that key existing but being associated with the value <code class="literal">nil</code>.</p></li><li class="listitem"><p>You can use tables as arrays by using consecutive integer keys (starting at one).</p></li><li class="listitem"><p>You can use <code class="literal">pairs</code> and <code class="literal">ipairs</code> with the generic <code class="literal">for</code> to loop through tables.</p></li><li class="listitem"><p>The <code class="literal">table</code> global variable contains a table, which in turn contains functions useful for dealing with tables (as in <code class="literal">table.sort</code>).</p></li><li class="listitem"><p>The colon syntax makes writing in an object-oriented style more convenient.</p></li><li class="listitem"><p>You can access the extra arguments of a vararg function with <code class="literal">...</code> (the vararg expression). You can use the <code class="literal">select</code> and <code class="literal">unpack</code> functions when dealing with vararg functions.</p></li><li class="listitem"><p>All chunks are compiled into functions. For example, scripts are vararg functions, which allows access to their command-line arguments.</p></li><li class="listitem"><p>Tables are mutable, so that when you alter a table's contents, it is still the same table.</p></li><li class="listitem"><p><code class="literal">pairs</code> and <code class="literal">ipairs</code> are iterator factories. You can write iterator factories of your own.</p></li><li class="listitem"><p>Global variables are stored in tables called environments. You use the <code class="literal">getfenv</code> and <code class="literal">setfenv</code> functions to manipulate these environments.</p></li></ul></div><p>Numeric, string, Boolean, and <code class="literal">nil</code> values; operators; expressions; statements; control structures; functions; tables—these are the building blocks of Lua and, as now that you know them, you know Lua.</p><p>You may have noticed that through this and the previous two chapters, there were an increasing proportion of examples that look like they could be useful in real programs. This trend continues in the next chapter, which has lots of code relevant to the real world—code for searching, matching, substituting, and otherwise manipulating strings and their characters and substrings. First, though, try the exercises for this chapter (answers are in the appendix).</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-011"></a>Exercises</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>In your head, figure out what the following prints:</p><pre class="programlisting">A = {}
B = "C"
C = "B"
D = {
  [A] = {B = C},
  [B] = {[C] = B},
  [C] = {[A] = A}}
print(D.C["B"])</pre></li><li class="listitem"><p>By default, <code class="literal">table.sort</code> uses <code class="literal">&lt;</code> to compare array elements, so it can only sort arrays of numbers or arrays of strings. Write a comparison function that allows <code class="literal">table.sort</code> to sort arrays of mixed types. In the sorted array, all values of a given type should be grouped together. Within each such group, numbers and strings should be sorted as usual, and other types should be sorted in some arbitrary but consistent way.</p><p>Test the function out on an array like this:</p><pre class="programlisting">{{}, {}, {}, "", "a", "b", "c", 1, 2, 3, −100, 1.1,
  function() end, function() end, false, false, true}</pre></li><li class="listitem"><p>The <code class="literal">print</code> function converts all its arguments to strings, separates them with tab characters, and outputs them, along with a trailing newline. Write a function that, instead of giving that as output, returns it as a string, so that the following:</p><pre class="programlisting">Sprint("Hi", {}, nil)</pre><p>returns this:</p><pre class="programlisting">"Hi\ttable: 0x484048\tnil\n"</pre><p>which, if printed, would look like this:</p><pre class="programlisting">Hi       table: 0x484048 nil</pre></li><li class="listitem"><p>In <code class="literal">ring.lua</code>, the <code class="literal">RotateL</code> method only rotates its object one element to the left, as shown here:</p><pre class="programlisting">-- Rotates self to the left:
function Methods:RotateL()
  if #self &gt; 0 then
    self.Pos = OneMod(self.Pos + 1, #self)
  end
end</pre><p>Rewrite it to take an optional numeric argument (defaulting to <code class="literal">1</code>) and rotate the object by that many elements. (This requires neither a loop nor recursion.)</p></li><li class="listitem"><p>Write a stateful iterator generator, <code class="literal">SortedPairs</code>, that behaves just like <code class="literal">pairs</code>, except that it goes through key-value pairs in order by key. Use the <code class="literal">CompAll</code> function from exercise 2 to sort the keys.</p></li></ol></div></div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="ch03.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">3. Extending Lua with Functions</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="ch05.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">5. Using Strings</div>
        </a>
    
  
  </div>


        
    </section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag">
        
        

        
          <p>You have 6 days left in your trial, Michaelschiner. Subscribe today. <a href="https://learning.oreilly.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
        
        

      </div>

    
    



        
      </div>
      
        

<footer class="pagefoot t-pagefoot">
  <a href="ch04.html#" class="icon-up" onclick="window.Appcues.track('JumpTop_HeronBook')"><div class="visuallyhidden">Back to top</div></a>
  <ul class='js-footer-nav'>
  
    
    <li><a href="https://learning.oreilly.com/public/support/">Support</a></li>
    
    <li><a href="https://learning.oreilly.com/accounts/logout/">Sign Out</a></li>
    
  
  
  </ul>
  <span class="copyright">&#169; 2021 <a href="https://learning.oreilly.com/" target="_blank">O'Reilly Media, Inc</a>.</span>
  
    
    <a href="https://www.oreilly.com/terms/">Terms of Service</a> 
     / 
    
    <a href="https://learning.oreilly.com/privacy">Privacy Policy</a> 
    
    
  
</footer>

      
    
    <script src="https://learning.oreilly.com/jsi18n/web/" charset="utf-8"></script>
    <script src="https://learning.oreilly.com/library/jsi18n/appcache/" charset="utf-8"></script>
  </body>
</html>
