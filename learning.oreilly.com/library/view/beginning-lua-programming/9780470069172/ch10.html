<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch10.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch10.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch10.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch10.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><!--<![endif]--><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="author" content="O'Reilly Media" /><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9780470069172"/><link rel="shortcut icon" href="https://www.oreilly.com/favicon.ico" /><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"/><meta property="twitter:account_id" content="4503599627559754" /><link rel="shortcut icon" href="https://learning.oreilly.com/favicon.ico" type="image/x-icon"><link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic' rel='stylesheet' type='text/css'><title>10. Looking Under the Hood - Beginning Lua Programming</title><link rel="stylesheet" href="https://learning.oreilly.com/static/CACHE/css/output.5bdb4fcb2aad.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://learning.oreilly.com/static/css/annotator.e3b0c44298fc.css"/><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book"></style><script> // <![CDATA[
    var g = {
      position_cache: {
        
          "chapter": "/api/v1/book/9780470069172/chapter/ch10.html",
          "book_id": "9780470069172",
          "chapter_uri": "ch10.html",
          "position": 0,
          "user_uuid": "ce47de5b-ce80-49f0-b5cd-c60d3d33b198",
          "next_chapter_uri": "/library/view/beginning-lua-programming/9780470069172/ch11.html"
        
      },
      title: "Beginning Lua Programming",
      author_list: "Aaron Brown, Kurt Jung",
      format: "book",
      source: "application/epub+zip",
      is_system_book: true,
      is_public: false,
      loaded_from_server: true,
      allow_scripts: false,
      has_mathml: false
    };
    // ]]></script><script src="https://learning.oreilly.com/static/js/src/modernizr.8e35451ddb64.js"></script><script>
    
      

      
        
          window.PUBLIC_ANNOTATIONS = true;
        
      

      window.MOBILE_PUBLIC_ANNOTATIONS = false;

    

    
      window.PRIVACY_CONTROL_OVERRIDE = false;
    

      window.PRIVACY_CONTROL_SWITCH = true;

      window.PUBLISHER_PAGES = true;

      window.SBO = {
        "constants": {
          "SITB_ENDPOINT": "/api/v2/sitb/",
          "SEARCH_SELECT_ENDPOINT": "https://learning.oreilly.com/api/v2/search/select/",
        }
      };
  </script><link rel="canonical" href="ch10.html"/><meta name="description" content="Chapter 10. Looking Under the Hood This chapter covers various ways of looking at the inner workings of Lua. To continue the automotive metaphor of the title, you can write ... "><meta property="og:title" content="10. Looking Under the Hood" /><meta itemprop="isPartOf" content="/library/view/beginning-lua-programming/9780470069172/" /><meta itemprop="name" content="10. Looking Under the Hood" /><meta property="og:url" itemprop="url" content="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch10.html" /><meta property="og:site_name" content="Safari" /><meta property="og:image" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9780470069172/" /><meta property="og:description" itemprop="description" content="Chapter 10. Looking Under the Hood This chapter covers various ways of looking at the inner workings of Lua. To continue the automotive metaphor of the title, you can write ... "><meta itemprop="inLanguage" content="en" /><meta itemprop="publisher" content="Wrox" /><meta property="og:type" content="book" /><meta property="og:book:isbn" itemprop="isbn" content="9780470069172" /><meta property="og:book:author" itemprop="author" content="Aaron Brown" /><meta property="og:book:author" itemprop="author" content="Kurt Jung" /><meta property="og:book:tag" itemprop="about" content="Core Programming" /><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@OReillyMedia"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><noscript><meta http-equiv="refresh" content="0; URL=https://learning.oreilly.com/library/no-js/" /></noscript><script>
    var dataLayer = window.dataLayer || [];

    
      window.medalliaVsgUserIdentifier = 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198';
      dataLayer.push({userIdentifier: 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198'});
      dataLayer.push({loggedIn: 'yes'});

      
        window.medalliaVsgAccountIdentifier = '29964b7b-68d8-4532-9a9b-32e089689c1f';
        

        window.medalliaVsgIsIndividual = true;
        
          
          dataLayer.push({learningAccountType: 'free trial'});
          
        

        
      
    

    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5P4V6Z');
    (function () {
      var VERSION = 'V1.1';
      var AUTHOR = 'Awwad';
      if (!window.GtmHelper)
        window.GtmHelper = function () {
          var instance = this;
          var loc = document.location;
          this.version = VERSION;
          this.author = AUTHOR;
          this.readCookie = function (name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
              var c = ca[i];
              while (c.charAt(0) == ' ') c = c.substring(1, c.length);
              if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
          };
          this.createCookie = function (name, value, days, cookieDomain) {
            var domain = "";
            var expires = "";

            if (days) {
              var date = new Date();
              date.setTime(date.getTime() + Math.ceil(days * 24 * 60 * 60 * 1000));
              var expires = " expires=" + date.toGMTString() + ";";
            }

            if (typeof (cookieDomain) != 'undefined')
              domain = " domain=" + cookieDomain + "; ";

            document.cookie = name + "=" + value + ";" + expires + domain + "path=/";
          };

          this.isDuplicated = function (currentTransactionId) {
            // the previous transaction id:
            var previousTransIdValue = this.readCookie("previousTransId");

            if (currentTransactionId === previousTransIdValue) {
              return true; // Duplication
            } else {
              return false;
            }
          };
        }
    })()
  </script><script defer src="https://learning.oreilly.com/static/js/build/vendor.0eac897f11ed.js"></script><script defer src="https://learning.oreilly.com/static/js/build/reader.c745ea9296ac.js"></script></head>


<body class="reading sidenav nav-collapsed  scalefonts">

    
  <noscript> 
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
            height="0" width="0"
            style="display:none;visibility:hidden">
    </iframe>
  </noscript>



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        

  


<a href="ch10.html#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li><a href="https://learning.oreilly.com/home/" class="l0 nav-icn"><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.738 14H9.254v-3.676a.617.617 0 0 0-.621-.613H7.39a.617.617 0 0 0-.62.613V14H4.284a.617.617 0 0 1-.622-.613V10.22c0-.327.132-.64.367-.87l3.547-3.493a.627.627 0 0 1 .875 0l3.54 3.499c.234.229.366.54.367.864v3.167a.617.617 0 0 1-.62.613zM7.57 2.181a.625.625 0 0 1 .882 0l5.77 5.692-.93.92-5.28-5.209-5.28 5.208-.932-.919 5.77-5.692z" /></svg><span>Home</span></a></li><li class="search"><a href="ch10.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"/></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="ch10.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"/></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li class="flyout-parent"><a
                href="ch10.html#"
                class="l1 nav-icn "
                
              ><?xml version="1.0" encoding="UTF-8"?><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M8,8 C6.34321755,8 5.00013,6.65691245 5.00013,5.00013 C5.00013,3.34334755 6.34321755,2.00026001 8,2.00026001 C9.65678245,2.00026001 10.99987,3.34334755 10.99987,5.00013 C10.99987,6.65691245 9.65678245,8 8,8 Z M2.33024571,11.3523547 L2.33774538,11.3523547 C3.7622187,9.70968996 5.82947484,8.76608166 8.00374984,8.76608166 C10.1780248,8.76608166 12.245281,9.70968996 13.6697543,11.3523547 C13.8892083,11.6177474 14.0062813,11.9530021 13.99974,12.2973138 L13.99974,13.99974 L2.00026001,13.99974 L2.00026001,12.2973138 C1.99371867,11.9530021 2.11079172,11.6177474 2.33024571,11.3523547 Z" id="path-1"></path></svg><span>Your O&#39;Reilly</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/profile/"
                    class="l2 nav-icn"
                    
                  ><span>Profile</span></a></li><li><a
                    href="https://learning.oreilly.com/history/"
                    class="l2 nav-icn"
                    
                  ><span>History</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/"
                    class="l2 nav-icn"
                    
                  ><span>Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/u/ce47de5b-ce80-49f0-b5cd-c60d3d33b198/"
                    class="l2 nav-icn"
                    
                  ><span>Highlights</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/answers/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M2.31032699,3.75609006 C4.65421571,1.41371359 8.45302454,1.41472092 10.7955702,3.75860838 C13.1381158,6.10249583 13.1369405,9.90130261 10.7930518,12.243847 C8.44916311,14.5863913 4.65018639,14.5852161 2.30780867,12.2413286 C-0.0346204845,9.89749489 -0.0334929936,6.09853298 2.31032699,3.75609006 Z M8.8198605,4.98016308 C7.34193969,3.86924672 5.23410194,3.98609692 3.88914868,5.33104946 C3.12814393,6.09032122 2.72818176,7.13880077 2.79015179,8.21201133 C2.79115912,8.23064692 2.79233434,8.24928252 2.79350956,8.26791811 L2.79350956,8.26791811 C2.83179539,8.8307976 2.9944077,9.37404287 3.26947292,9.86201677 L3.26947292,9.86201677 L2.77621706,11.7027432 C2.7699968,11.7259241 2.77662063,11.7506624 2.79359185,11.7676337 C2.8105631,11.7846049 2.83530144,11.7912287 2.85848233,11.7850085 L2.85848233,11.7850085 L4.69400524,11.2922565 C5.26306363,11.6167344 5.90703177,11.786885 6.56209849,11.7858479 C8.64827865,11.7858479 10.3395879,10.094542 10.3395879,8.00836292 C10.3405204,6.84135608 9.80105674,5.73967784 8.87862141,5.02482134 L8.87862141,5.02482134 L8.82825492,4.98654283 Z M13.7933062,2 C14.7073496,2.00009863 15.4482759,2.74110484 15.4482759,3.65514822 C15.4482759,4.32460943 15.0449926,4.92814782 14.4264842,5.18432286 C13.8079757,5.44049789 13.096053,5.29885769 12.6226979,4.82545158 C12.1493429,4.35204547 12.0077795,3.64010743 12.2640213,3.02162665 C12.5202631,2.40314587 13.123845,1.99992776 13.7933062,2 Z"/></svg><span>Answers</span></a></li><li class="flyout-parent"><a
                href="ch10.html#"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z"/></g></svg><span>Explore</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/topics/"
                    class="l2 nav-icn"
                    
                  ><span>All Topics</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;formats=case%20study&amp;formats=learning%20path&amp;formats=live%20online%20training&amp;formats=notebook&amp;formats=oriole&amp;formats=video&amp;sort=popularity&amp;facet_json=true&amp;page=0&amp;collection_type=expert"
                    class="l2 nav-icn"
                    
                  ><span>Most Popular Titles</span></a></li><li><a
                    href="https://learning.oreilly.com/recommendations/"
                    class="l2 nav-icn"
                    
                  ><span>Recommended</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;sort=publication_date&amp;facet_json=true&amp;page=0"
                    class="l2 nav-icn"
                    
                  ><span>Early Releases</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/discover/"
                    class="l2 nav-icn"
                    
                  ><span>Shared Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/resource-centers/"
                    class="l2 nav-icn"
                    
                  ><span>Resource Centers</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch10.html#"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M12.8 3.2A1.2 1.2 0 0 1 14 4.4v8.4a1.2 1.2 0 0 1-1.2 1.2H3.2A1.2 1.2 0 0 1 2 12.8V4.4a1.2 1.2 0 0 1 1.2-1.2h1.2V2h1.2v1.2h4.8V2h1.2v1.2h1.2zm-9.6 9.6h9.6V6.2H3.2v6.6zM8 9.5a1.35 1.35 0 1 1 0-2.7 1.35 1.35 0 0 1 0 2.7zm2.7 2.148v.552H5.3v-.552c0-.321.124-.634.355-.858a3.358 3.358 0 0 1 4.69 0c.23.224.355.537.355.858z" /></svg><span>Live Events</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/attend/"
                    class="l2 nav-icn"
                    
                  ><span>All Events</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/architectural-katas/"
                    class="l2 nav-icn"
                    
                  ><span>Architectural Katas</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/ai/"
                    class="l2 nav-icn"
                    
                  ><span>AI &amp; ML</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/strata/"
                    class="l2 nav-icn"
                    
                  ><span>Data Sci &amp; Eng</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/oscon/"
                    class="l2 nav-icn"
                    
                  ><span>Programming</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/infrastructure-ops/"
                    class="l2 nav-icn"
                    
                  ><span>Infra &amp; Ops</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/software-architecture/"
                    class="l2 nav-icn"
                    
                  ><span>Software Arch</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch10.html#"
                class="l1 nav-icn "
                
              ><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.6467109,4.35328907 L14.7964612,7.51003884 C15.0678463,7.78304342 15.0678463,8.22395603 14.7964612,8.49696061 L11.6467109,11.6467109 L10.6597892,10.6597892 L13.3055794,8 L10.6597892,5.34021084 L11.6467109,4.35328907 Z M4.35328907,11.6467109 L1.20353875,8.48996116 C0.932153749,8.21695658 0.932153749,7.77604397 1.20353875,7.50303939 L4.35328907,4.35328907 L5.34021084,5.34021084 L2.69442057,8 L5.34021084,10.6597892 L4.35328907,11.6467109 Z M5.84417089,11.4997226 L8.67194674,4.50027742 L10.1838269,4.50027742 L7.35605105,11.4997226 L5.84417089,11.4997226 Z" id="Mask"></path></svg><span>Interactive</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=content-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Scenarios</span></a></li><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=sandbox-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Sandboxes</span></a></li><li><a
                    href="https://learning.oreilly.com/interactive/?classification=jupyter-notebook"
                    class="l2 nav-icn"
                    
                  ><span>Jupyter Notebooks</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/certifications/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M12.912 9.18L14 8.014l-1.088-1.18a.304.304 0 01-.075-.268L13.195 5l-1.535-.463a.313.313 0 01-.194-.194l-.462-1.537-1.565.358c-.09.03-.194 0-.269-.074L8.007 2 6.845 3.09a.303.303 0 01-.269.074l-1.565-.358-.462 1.537a.313.313 0 01-.194.194L2.82 5l.358 1.567a.26.26 0 01-.075.269L2 8.015l1.088 1.164c.075.075.09.18.075.269l-.358 1.567 1.535.463c.09.03.164.104.194.194l.462 1.537 1.565-.358c.015 0 .045-.015.075-.015.075 0 .15.03.209.074L8.007 14l1.163-1.09a.303.303 0 01.269-.074l1.565.358.462-1.537a.313.313 0 01.194-.194L13.195 11l-.358-1.567a.338.338 0 01.075-.254zm-6.046 1.37L4.41 8.26l1.16-1.244 1.767 1.649L10.4 5.6l1.202 1.202-4.242 4.243-.495-.495z"/></svg><span>Certifications</span></a></li><li ><a
                href="https://learning.oreilly.com/preferences/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"/></g></svg><span>Settings</span></a></li><li ><a
                href="https://learning.oreilly.com/public/support/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M7.363 6.656a2.692 2.692 0 0 1-2.681-2.703c0-1.493 1.2-2.703 2.681-2.703a2.692 2.692 0 0 1 2.682 2.703c0 1.493-1.2 2.703-2.682 2.703zm4.023 2.027c-1.852 0-3.352 1.513-3.352 3.379H2v-1.534c-.006-.31.099-.612.295-.852a6.666 6.666 0 0 1 9.09-.993zm-.543.676h1.12v.304c.003.284.16.543.408.676a.766.766 0 0 0 .77 0l.303-.176.556.966-.302.176a.772.772 0 0 0-.362.676v.08a.772.772 0 0 0 .362.677l.302.21-.556.965-.302-.175a.766.766 0 0 0-.771 0 .778.778 0 0 0-.409.675v.352h-1.106v-.372a.778.778 0 0 0-.409-.676.766.766 0 0 0-.77 0l-.303.176-.556-.912.302-.176a.772.772 0 0 0 .362-.676v-.04-.04a.772.772 0 0 0-.362-.676l-.302-.176.556-.966.289.155a.766.766 0 0 0 .77 0 .778.778 0 0 0 .41-.676V9.36zm1.562 2.703c0-.271-.108-.531-.3-.722a1.001 1.001 0 0 0-.72-.292 1.01 1.01 0 0 0-.992 1.023 1.01 1.01 0 0 0 1.01 1.004 1.01 1.01 0 0 0 1.002-1.013z" /></svg><span>Support</span></a></li><li ><a
                href="https://get.oreilly.com/email-signup.html"
                class="l1 nav-icn "
                target=&quot;_blank&quot;
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.564 2.263l2.172 2.174c.17.168.264.397.264.636V11a.6.6 0 0 1-.6.6h-.6V6.2h-6V2.6a.6.6 0 0 1 .6-.6h3.527c.239 0 .468.095.637.263zM2.6 14a.6.6 0 0 1-.6-.6V6.8a.6.6 0 0 1 .6-.6h1.903a1.2 1.2 0 0 1 .849.352L6.2 7.4H11a.6.6 0 0 1 .6.6v5.4a.6.6 0 0 1-.6.6H2.6zM11 5h1.8L11 3.2V5z" /></svg><span>Newsletters</span></a></li><li ><a
                href="https://learning.oreilly.com/accounts/logout/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.613 12.63A.607.607 0 0 1 2 12.03V3.602C2 3.269 2.274 3 2.613 3h5.515v1.204H3.226v7.223h4.902v1.203H2.613zM5.677 9.02V6.611h4.903V4.926a.301.301 0 0 1 .19-.274.31.31 0 0 1 .33.063l2.722 2.673a.594.594 0 0 1 0 .849L11.1 10.909a.31.31 0 0 1-.331.063.301.301 0 0 1-.19-.274V9.02H5.677z" /></svg><span>Sign Out</span></a></li></ul></div></li></ul></nav></header>



      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="ch10.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Beginning Lua Programming
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="ch10.html#" title="Search in archive" class="js-search-controls search-controls" onclick="window.Appcues.track('SearchBook_HeronBook')"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9780470069172/chapter/ch10.html"><div class="js-collections-dropdown collections-dropdown menu-bit-cards" onclick="window.Appcues.track('AddPlaylist_HeronBook')"></div></div></li><li class="js-font-control-panel font-control-activator"><a href="ch10.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size" onclick="window.Appcues.track('ChangeFont_HeronBook')"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="ch10.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share" onclick="window.Appcues.track('Share_HeronBook')"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a
        class="twitter share-button t-twitter"
        target="_blank"
        aria-label="Share this section on Twitter"
        title="Share this section on Twitter"
      
        href="https://twitter.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch10.html&text=Beginning%20Lua%20Programming&via=OReillyMedia"
      ><span>Twitter</span></a></li><li><a
        class="facebook share-button t-facebook"
        target="_blank"
        aria-label="Share this section on Facebook"
        title="Share this section on Facebook"
        href="https://www.facebook.com/sharer/sharer.php?u=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch10.html"
      ><span>Facebook</span></a></li><li><a
        class="googleplus share-button t-googleplus"
        target="_blank"
        aria-label="Share this secton on Google Plus"
        title="Share this secton on Google Plus"
        href="https://plus.google.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch10.html"
      ><span>Google Plus</span></a></li><li><a
        class="email share-button t-email"
        aria-label="Share this section via email"
        title="Share this section via email"
      
        href="mailto:?subject=Safari: 10.%20Looking%20Under%20the%20Hood&body=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch10.html%0D%0Afrom Beginning%20Lua%20Programming%0D%0A"
      ><span>Email</span></a></li></ul></li><!-- endif request.user.is_authenticated -->
      </ul>
    </div>

      
          
      

    <section role="document">
        
        




  <script defer src="https://learning.oreilly.com/static/js/build/djangoMessagesPage.bfaca9fd8619.js"></script>


        <script src="https://fast.appcues.com/48743.js"></script>
<script>
  var userId = "ce47de5b-ce80-49f0-b5cd-c60d3d33b198";

  var userObject = {
    firstName: "Michael",
    segment: "Trial",
    admin: "False",
    profileCreatedOn: "2021-05-13",
    academic: ""
  };
  window.Appcues.identify(userId, userObject);
  window.Appcues.page();

  setTimeout(function () {
    window.Appcues.track('ViewingBook_HeronBook')
  }, 20000);
</script>


	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="ch09.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">9. Handling Events Naturally with Coroutines</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="ch11.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">11. Exploring Lua&#39;s Libraries</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="looking_under_the_hood"></a>Chapter 10. Looking Under the Hood</h1></div></div></div><p>This chapter covers various ways of looking at the inner workings of Lua. To continue the automotive metaphor of the title, you can write many useful programs without knowing the things in this chapter, just as you can drive a car without knowing how to change the oil. However, the knowledge and techniques in this chapter will help you find bugs, and let you do things with Lua that otherwise wouldn't be possible. You'll learn about the following:<a id="IDX-CHP-10-0001" class="indexterm"></a><a id="IDX-CHP-10-0002" class="indexterm"></a><a id="IDX-CHP-10-0003" class="indexterm"></a><a id="IDX-CHP-10-0004" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Using bytecode</p></li><li class="listitem"><p>Controlling Lua's memory management</p></li><li class="listitem"><p>Understanding the implementation of tables and strings</p></li><li class="listitem"><p>Looking directly inside functions to see and alter their local variables</p></li><li class="listitem"><p>Tracing the execution of your code on a call-by-call, line-by-line, or instruction-by-instruction basis</p></li></ul></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="bytecode_and_luac"></a>Bytecode and luac</h1></div></div></div><p>As mentioned in <a class="link" href="ch03.html" title="Chapter 3. Extending Lua with Functions">Chapter 3</a>, before Lua can execute source code, it needs to compile it into bytecode, which is then interpreted by the bytecode interpreter. Another name for the bytecode interpreter is the <span class="emphasis"><em>virtual machine</em></span>, because it's kind of like an imaginary computer (imaginary in the sense no one has ever built one out of silicon —it's just simulated by your real computer). Lua comes with two programs: the command-line interpreter <code class="literal">lua</code>, and the bytecode compiler <code class="literal">luac</code>. The main purpose of <code class="literal">luac</code> is to compile Lua source code to bytecode and save that bytecode to a file (so it can be run later), but it can also output a human-readable listing of the bytecode.<a id="IDX-CHP-10-0005" class="indexterm"></a></p><div class="sidebar"><a id="try_it_out_colon_reading_bytecode_with_l"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Reading Bytecode With Luacr</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Save the following as <code class="literal">test.lua</code>:</p><pre class="programlisting">-- A short script (for use as a luac test).

function Greet(Name)
    print("Hello, " .. Name .. ".")</pre><pre class="programlisting">end

Greet("whoever you are")</pre></li><li class="listitem"><p>Run <code class="literal">luac</code> as follows:<a id="IDX-CHP-10-0006" class="indexterm"></a></p><pre class="programlisting">luac -p -l test.lua</pre><p>The output should look something like this:</p><pre class="programlisting">main &lt;test.lua:0,0&lt; (6 instructions, 24 bytes at 0x471410)
0+ params, 2 slots, 0 upvalues, 0 locals, 2 constants, 1 function
        1       [5]     CLOSURE        0  0      ; 0x471560
        2       [3]     SETGLOBAL      0  −1     ; Greet
        3       [7]     GETGLOBAL      0  −1     ; Greet
        4       [7]     LOADK          1  −2     ; "whoever you are"
        5       [7]     CALL           0  2 1
        6       [7]     RETURN         0  1

function &lt;test.lua:3,5&lt;    (7 instructions, 28 bytes at 0x471560)
1 param, 5 slots, 0 upvalues,       1 local,    3 constants, 0 functions
        1       [4]     GETGLOBAL                1 −1    ; print
        2       [4]     LOADK                    2 −2    ; "Hello, "
        3       [4]     MOVE                     3 0
        4       [4]     LOADK                    4 −3    ; "."
        5       [4]     CONCAT                   2 2 4
        6       [4]     CALL                     1 2 1
        7       [5]     RETURN                   0 1</pre></li></ol></div><p><span class="strong"><strong>How It Works</strong></span></p><p>The <code class="literal">-p</code> option tells <code class="literal">luac</code> to only <span class="emphasis"><em>parse</em></span> the file (check it for syntactical correctness) rather than actually outputting any bytecode. The <code class="literal">-l</code> option tells it to print a bytecode listing. The last argument, <code class="literal">test.lua</code>, names the file to be used as source code. (This filename has to be the last argument; no options can follow it.)</p><p>The bytecode listing itself has two sections: one for the main chunk (the whole file <code class="literal">test.lua</code>) and one for the <code class="literal">Greet</code> function definition. This chapter isn't big enough to give anywhere close to a comprehensive description of the virtual-machine instructions that bytecode is composed of, but a line-by-line breakdown will give you at least an impression of how bytecode works.</p><p>First, the following lines give information about the main chunk (more on this in a moment):</p><pre class="programlisting">main &lt;test.lua:0,0&lt; (6 instructions, 24 bytes at 0x471410)
0+ params, 2 slots, 0 upvalues, 0 locals, 2 constants, 1 function</pre><p>Then the <code class="literal">CLOSURE</code> instruction creates a function, using the definition at <code class="literal">0x471560</code> where the <code class="literal">[5]</code> means that this corresponds to line 5 of the source code (the end of <code class="literal">Greet</code>'s function definition):</p><pre class="programlisting">1      [5]     CLOSURE        0 0      ; 0x471560</pre><p>This instruction assigns the function to the global variable <code class="literal">Greet</code>:</p><pre class="programlisting">2      [3]     SETGLOBAL    0 −1     ; Greet</pre><p>This instruction gets the value (a function) of the global variable <code class="literal">Greet</code>:<a id="IDX-CHP-10-0007" class="indexterm"></a><a id="IDX-CHP-10-0008" class="indexterm"></a></p><pre class="programlisting">3      [7]     GETGLOBAL   0 −1     ; Greet</pre><p>This instruction loads one of the main chunk's constants (<code class="literal">"whoever you are"</code>) into register 1:</p><pre class="programlisting">4      [7]     LOADK            1 −2      ; "whoever you are"</pre><p>The Lua virtual machine has up to 250 <span class="emphasis"><em>registers</em></span>, or temporary storage locations. Here, a register is being used to store "<code class="literal">whoever you are"</code> until it is passed to a function. Registers are also used to store arguments and other local variables. In the example's output, where the second line says <code class="literal">2 slots</code>, that means that the main chunk uses 2 registers. Registers reside on the call stack, so each function call gets a fresh set.</p><pre class="programlisting">Continuing with the line-by-line breakdown of the example, the following
 instruction calls register 0 (the Greet function) with 1 argument and 0 return
 values (subtract 1 from both the 2 and the 1 to get these values):  5
 [7]         CALL                0 2 1</pre><p>Then this instruction returns from the main chunk, thereby ending the script:</p><pre class="programlisting">6     [7]    RETURN          0 1</pre><p>These lines give information about the <code class="literal">Greet</code> function definition—it resides at 0x471560, has one argument (parameter) and three constants, and uses five registers:</p><pre class="programlisting">function &lt;test.lua:3,5&lt; (7 instructions, 28 bytes at 0x471560)
1 param,  5 slots,   0 upvalues,   1 local, 3 constants, 0 functions</pre><p>This instruction gets the value (a function) of the global variable <code class="literal">print</code>:</p><pre class="programlisting">1     [4]       GETGLOBAL         1 −1      ; print</pre><p>These instructions put the constant "<code class="literal">Hello, "</code>, the function's argument, and the constant " . " into registers 2, 3, and 4:</p><pre class="programlisting">2     [4]       LOADK                  2 −2      ; "Hello, "
 3     [4]       MOVE                    3 0
 4     [4]       LOADK                 4 −3       ; "."</pre><p>And finally, these instructions concatenate registers 2 through 4, call <code class="literal">print</code>, and return from <code class="literal">Greet</code>:</p><pre class="programlisting">5     [4]       CONCAT               2 2 4
6     [4]       CALL                 1 2 1
7     [5]       RETURN               0 1</pre><p>If you want to know more about the Lua virtual machine, check out Kein-Hong Man's "A No-Frills Introduction to Lua 5.1 VM Instructions." It's available at <code class="literal">luaforge.net</code>, along with his ChunkSpy program, which is a tool for analyzing bytecode.<a id="IDX-CHP-10-0009" class="indexterm"></a></p></div><p>You can use bytecode listings to find certain kinds of bugs, troubleshoot efficiency issues, and understand the meaning of particularly hairy pieces of source code. To create a bytecode file, get rid of the <code class="literal">-p</code> option (and the <code class="literal">-l</code> option) and supply the output filename with the <code class="literal">-o</code> option, or don't supply it and look for the output in the file <code class="literal">luac.out</code>. A common convention is to end bytecode files in <code class="literal">.luac</code>, but (as with <code class="literal">.lua</code> files), you can name them anything you want and Lua won't care. For example, this line creates a <code class="literal">test.luac</code> file:<a id="IDX-CHP-10-0010" class="indexterm"></a><a id="IDX-CHP-10-0011" class="indexterm"></a><a id="IDX-CHP-10-0012" class="indexterm"></a><a id="IDX-CHP-10-0013" class="indexterm"></a><a id="IDX-CHP-10-0014" class="indexterm"></a><a id="IDX-CHP-10-0015" class="indexterm"></a></p><pre class="programlisting">luac -o test.luac test.lua</pre><p>You can run this like a regular Lua file, by typing the following:</p><pre class="programlisting">lua test.luac</pre><p>The output is this:</p><pre class="programlisting">Hello, whoever you are.</pre><p>Lua can tell the difference between bytecode and source code by looking at the first byte of the file. If it's the character "<code class="literal">\27"</code>, then the file is treated as bytecode; otherwise it's treated as normal source code. This applies not only to the command-line interpreter, but also to <code class="literal">loadstring</code> and its cousins <code class="literal">load, loadfile</code>, and <code class="literal">dofile</code>, all of which can accept either source code or bytecode.</p><p>The <code class="literal">string.dump</code> function converts from a Lua function to bytecode as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>function Greet(Name)</code></strong>
&gt;&gt;   <strong class="userinput"><code>print("Hello, " .. Name .. ".")</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>-- Convert Greet to bytecode:</code></strong>
&gt; <strong class="userinput"><code>Bytecode = string.dump(Greet)</code></strong>
&gt; <strong class="userinput"><code>-- Convert it back to a function and call it:</code></strong>
&gt; <strong class="userinput"><code>(loadstring(Bytecode))("Insert name here")</code></strong>
Hello, Insert name here.</pre><p>According to the Lua reference manual, the function given to <code class="literal">string.dump</code> cannot have upvalues. An undocumented feature (which therefore may change without notice in a future version) is that a function with upvalues may be dumped, but in the dumped version, all the upvalues will be private to the function (even if the original shared them with another function) and they'll be <code class="literal">nil</code> until assigned to from within the function. (In Lua 5.0, <code class="literal">string.dump</code> triggered an error if given a function with upvalues.)</p><p><code class="literal">luac</code> is necessary less often than you might think. For example, you can use <code class="literal">luac</code> to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Save the time you would otherwise spend to compile a source code file before running it. Because Lua's bytecode compiler is so fast, this is very seldom a big enough time saver to be worth the hassle.</p></li><li class="listitem"><p>Hide scripts from snooping eyes and fiddling fingers. Other than constant strings, a <code class="literal">.luac</code> file looks like gobbledygook in a text editor, and this is enough to protect it from casual exploration, but a determined person (armed with the aforementioned ChunkSpy, for example) can still read and modify it.<a id="IDX-CHP-10-0016" class="indexterm"></a></p></li><li class="listitem"><p>Save space. Because <code class="literal">.luac</code> files are not necessarily much smaller (or any smaller) than the corresponding <code class="literal">.lua</code> files, this is also seldom worth the hassle. One case where it can be worthwhile is in embedded systems, where space is at a premium. (If source code is never used on the embedded device itself, then the bytecode-compiler component of Lua doesn't need to be present, which saves more space.)</p></li><li class="listitem"><p>Check syntax. The <code class="literal">-p</code> option allows you to check files for syntax errors without actually running them.<a id="IDX-CHP-10-0017" class="indexterm"></a></p></li><li class="listitem"><p>Generate bytecode listings (as discussed previously) for debugging purposes.<a id="IDX-CHP-10-0018" class="indexterm"></a></p></li></ul></div><p>These last two uses are the domain of lint-type program checkers. For example, a program to find unintentional global variables could create a list of all globals by looking at <code class="literal">GETGLOBAL</code> and <code class="literal">SETGLOBAL</code> instructions in a bytecode listing.<a id="IDX-CHP-10-0019" class="indexterm"></a></p><p>Bytecode is not portable. A bytecode file generated on one machine can only be used on another if the second machine has the same byte order (little-endian versus big-endian) and word size (32-bit versus 64-bit, for example). <span class="emphasis"><em>Byte order</em></span> just refers to the order in which multiple-byte numbers are laid out in memory.<a id="IDX-CHP-10-0020" class="indexterm"></a></p><p>Also, because the virtual machine is nothing more than a means of implementing Lua, bytecode is not portable between different versions. Therefore, Lua 5.0 bytecode won't work on Lua 5.1 or vice versa.</p><p>The following table lists the <code class="literal">luac</code> options and what they do.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"><col class="col2"></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Option</p></th><th style="text-align: left" valign="bottom"><p>Action</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">-l</code></p></td><td style="text-align: left" valign="top"><p>Prints a bytecode listing.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-o</code></p></td><td style="text-align: left" valign="top"><p>Uses the following command-line argument as the name of the output file. (The default is <code class="literal">luac.out</code>.)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-p</code></p></td><td style="text-align: left" valign="top"><p>Only parses the source code—doesn't output any bytecode.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-s</code></p></td><td style="text-align: left" valign="top"><p>Strips debugging information (making the output file smaller, but losing things like the line numbers used in error messages).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-v</code></p></td><td style="text-align: left" valign="top"><p>Prints version information.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">--</code></p></td><td style="text-align: left" valign="top"><p>Stops handling options (this is useful if you want to compile a script whose name starts with <code class="literal">-</code>).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-</code></p></td><td style="text-align: left" valign="top"><p>Treatsstandard <code class="literal">luac</code> input as source code (otherwise, the file named by the last <code class="literal">luac</code> argument is used as source code).</p></td></tr></tbody></table></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="garbage_collection"></a>Garbage Collection</h1></div></div></div><p>If a value is of a type that uses a variable amount of space (such as a string, table, or function) or if it's used as an upvalue and hence may outlive its stack frame, Lua automatically sets aside the necessary space for it in memory. If Lua subsequently notices that this value is no longer either pointed to by a variable or is used as a key or value in a table, it marks that value's memory as no longer occupied so that it can be reused. This process is called <span class="emphasis"><em>garbage collection</em></span>.<a id="IDX-CHP-10-0021" class="indexterm"></a></p><p>In the following Try It Out, you print bar charts to show how memory usage varies as strings are created and garbage-collected.</p><div class="sidebar"><a id="try_it_out_measuring_memory_usage"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out Measuring Memory Usage</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Type the following function into the interpreter:<a id="IDX-CHP-10-0022" class="indexterm"></a><a id="IDX-CHP-10-0023" class="indexterm"></a><a id="IDX-CHP-10-0024" class="indexterm"></a></p><pre class="programlisting">function GarbageTest(Len)
    -- Clean up any garbage:
    collectgarbage("collect")
    for I = 0, 9 do
      -- Create a Len-character string and put it in a variable
      -- that will go out of scope at the end of this iteration:
      local Junk = string.rep(I, Len)
      -- Print a line of a bar chart showing memory usage:
    print(string.rep("#", collectgarbage("count"))) -- This use
      -- of string.rep increases memory usage a bit too, but
      -- that can be ignored.
   end
end</pre></li><li class="listitem"><p>Call <code class="literal">GarbageTest</code> with an argument of <code class="literal">200</code>. The output should look something like this:<a id="IDX-CHP-10-0025" class="indexterm"></a></p><pre class="programlisting">####################
####################
####################
#####################
#####################
#####################
#####################
######################
######################
######################</pre></li><li class="listitem"><p>Call <code class="literal">GarbageTest</code> with an argument of <code class="literal">3000</code>. The output should look something like this:</p><pre class="programlisting">###########################
################################
#####################################
##########################################
###############################################
##############################
###################################
########################################
#############################################
##################################################</pre></li></ol></div><p><span class="strong"><strong>How It Works</strong></span></p><p>The <code class="literal">collectgarbage</code> function does various things related to garbage collection, depending on the option string given as its first argument. At the beginning of <code class="literal">GarbageTest</code>, it's called with the "<code class="literal">collect"</code> option, which makes Lua run a garbage-collection cycle (so that <code class="literal">GarbageTest</code> can run with a clean slate). On every iteration of the loop, a new string is created, then <code class="literal">collectgarbage</code> is used with the "<code class="literal">count"</code> option that makes it return the current memory usage (in kilobytes), and this number is printed in bar chart form. Because <code class="literal">Junk</code> is local, a string created on one iteration is not accessible from the next iteration, which means it's eligible for garbage collection. When the strings are only 200 characters long, you can see memory usage slowly ramp up, but when they are 3000 characters long, memory usage ramps up more quickly, until the garbage collector kicks in and frees up the memory used by strings from previous iterations. That's why the second bar chart has a sawtooth shape.</p><p>Any code that creates a lot of large strings (or other collectable objects such as tables) that immediately become inaccessible is said to <span class="emphasis"><em>churn</em></span> the memory pool. Memory churn causes the garbage collector to kick in often and can hence slow down your program. The previous example causes memory churn on purpose, but here are two rules of thumb for avoiding churn caused by strings:<a id="IDX-CHP-10-0026" class="indexterm"></a><a id="IDX-CHP-10-0027" class="indexterm"></a><a id="IDX-CHP-10-0028" class="indexterm"></a><a id="IDX-CHP-10-0029" class="indexterm"></a><a id="IDX-CHP-10-0030" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Don't do in several <code class="literal">string.gsub</code> strings what can be done in one string.</p></li><li class="listitem"><p>Instead of building up a string piece by piece by concatenating onto the end of it on every iteration of a loop, put the pieces into an array and concatenate it all at once with <code class="literal">table.concat</code>.</p></li></ul></div><p>These are important mainly when the strings are long; otherwise the churn is not noticeable.</p></div><p><code class="literal">collectgarbage</code> has other options that enable you to stop and restart the garbage collector and tweak how often it kicks in automatically and how fast it runs. These options are summarized in <a class="link" href="ch11.html" title="Chapter 11. Exploring Lua's Libraries">Chapter 11</a>. For more details, see the Lua reference manual.</p><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">collectgarbage</code> did not take the same arguments in Lua 5.0 as it does in Lua 5.1, and it didn't have as many uses. Some of the slack was picked up by the <code class="literal">gcinfo</code> function.</p></blockquote></div><p>If a table has a metatable whose <code class="literal">__mode</code> field is a string containing the letter "<code class="literal">k"</code>, and the garbage collector sees a key in that table that, if it weren't a key in that table, would be inaccessible, then the garbage collector will remove that key-value pair. (This doesn't happen if the key is a string, number, or Boolean.) For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>F1 = function() end</code></strong>
&gt; <strong class="userinput"><code>F2 = function() end</code></strong>
&gt; <strong class="userinput"><code>F3 = function() end</code></strong>
&gt; <strong class="userinput"><code>WeakKeyedTbl = {[F1] = 1, [F2] = 2, [F3] = 3}</code></strong>
&gt; <strong class="userinput"><code>setmetatable(WeakKeyedTbl, {__mode = "k"})</code></strong>
&gt; <strong class="userinput"><code>-- Make function F2 inaccessible except via WeakKeyedTbl:</code></strong>
&gt; <strong class="userinput"><code>F2 = nil</code></strong>
&gt; <strong class="userinput"><code>collectgarbage("collect")</code></strong>
&gt; <strong class="userinput"><code>-- The key-value pair [F2] = 2 is no longer in WeakKeyedTbl:</code></strong>
&gt; <strong class="userinput"><code>for F, N in pairs(WeakKeyedTbl) do</code></strong>
&gt;&gt; <strong class="userinput"><code>print(F, N)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
function: 0x493890  1
function: 0x493e10  3</pre><p>Such a table is said to have <span class="emphasis"><em>weak keys</em></span>.<a id="IDX-CHP-10-0031" class="indexterm"></a></p><p>Similarly, if the letter "<code class="literal">v"</code> is contained in the string in the <code class="literal">__mode</code> field of a table, and the garbage collector sees a value in that table that, if it weren't a value in that table, would be inaccessible, then the garbage collector will remove that key-value pair (again, only if the value is not a string, number, or Boolean). For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>F1 = function() end</code></strong>
&gt; <strong class="userinput"><code>F2 = function() end</code></strong>
&gt; <strong class="userinput"><code>F3 = function() end</code></strong>
&gt; <strong class="userinput"><code>WeakValuedTbl = {F1, F2, F3}</code></strong>
&gt; <strong class="userinput"><code>setmetatable(WeakValuedTbl, {__mode = "v"})</code></strong>
&gt; <strong class="userinput"><code>-- Make function F2 inaccessible except via WeakValuedTbl:</code></strong></pre><pre class="programlisting">&gt; <strong class="userinput"><code>F2 = nil</code></strong>
&gt; <strong class="userinput"><code>collectgarbage("collect")</code></strong>
&gt; <strong class="userinput"><code>-- The key-value pair [2] = F2 is no longer in WeakValuedTbl:</code></strong>
&gt; <strong class="userinput"><code>print(WeakValuedTbl[1], WeakValuedTbl[2], WeakValuedTbl[3])</code></strong>
function: 0x493890  nil  function: 0x493e10</pre><p>Such a table is said to have <span class="emphasis"><em>weak values</em></span>.<a id="IDX-CHP-10-0032" class="indexterm"></a></p><div class="blockquote"><blockquote class="blockquote"><p>The reason this doesn't apply to strings, numbers, and Booleans is that they are never truly inaccessible. For example, if the string "<code class="literal">ab</code>" doesn't happen to already be in a variable or a table, it can still be obtained by concatenating "<code class="literal">a</code>" and "<code class="literal">b</code>".</p></blockquote></div><p>Weak keys and values are useful when you want to make an association between a function, table, thread (coroutine), or userdata and some second value, and it's impossible or inconvenient to make that second value part of the first value, but you don't want the association to stick around when you're done with the first value. For instance, a weak-keyed table could have functions as keys and descriptions of those functions as values. When no other variable or table contained a particular function, it and its description would automatically disappear from the table.</p><p>The memory leak in <code class="literal">orderedtbl.lua</code> that was pointed out in <a class="link" href="ch08.html" title="Chapter 8. Extending Lua's Behavior with Metamethods">Chapter 8</a> can be fixed by giving the three tables responsible for the leak weak keys this:</p><pre class="programlisting">local RealTbls = {} -- Keys: proxy tables; values: the real
     -- tables.
local NumToKeys = {} -- Keys: proxy tables; values: arrays
     -- of real tables' keys, in order.
local KeyToNums = {} -- Keys: proxy tables; values: tables
     -- mapping real tables' keys to their (order) numbers.
-- Prevent leakage by giving all of the above tables weak keys:
local ModeMeta = {__mode = "k"}
setmetatable(RealTbls, ModeMeta)
setmetatable(NumToKeys, ModeMeta)
setmetatable(KeyToNums, ModeMeta)

-- Does the bookkeeping necessary to add a key and its order
-- to the real table (or update/delete a key):
local function __newindex(Proxy, Key, Val)</pre><p>The <code class="literal">__mode</code> string can contain both "<code class="literal">k"</code> and "<code class="literal">v"</code> (as in "<code class="literal">kv"</code>), in which case both the keys and the values of that table are weak. (Any other characters that might also be in the string are ignored.)</p><p>Don't change a metatable's <code class="literal">__mode</code> field after it has been used as a metatable; otherwise you'll get unpredictable results (because Lua caches this field).</p><p>One other metamethod that has to do with garbage collection is specific to userdata. The userdata type will be covered in <a class="link" href="ch13.html" title="Chapter 13. Interfacing Lua with Other Languages">Chapter 13</a>, but it's basically a way of exposing a C datatype (or a datatype of some other language) to Lua. When userdata that has a metatable with a <code class="literal">__gc</code> field is up for garbage collection, then the value of that field is called with the userdata as an argument. The <code class="literal">__gc</code> function should free any memory or other resources (such as open files or network connections) that were allocated outside of Lua when the userdata was created. In this way, languages that are not garbage collected (such as C) can reap the benefits of garbage collection when interfaced with Lua. (This rationale explains why <code class="literal">__gc</code> has no effect on tables, which already reap said benefits.)</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="the_implementation_of_tables_and_strings"></a>The Implementation of Tables and Strings</h1></div></div></div><p>Tables and strings are both implemented using a technique called <span class="emphasis"><em>hashing</em></span>. Imagine that you had a formula for converting a person's name into a number between one and a thousand. If this formula gives a result of 719 for the name John Smith, then 719 is said to be the <span class="emphasis"><em>hash</em></span> of John Smith. Now imagine a thousand-page phone book organized by hash. Assume that there aren't too many people in the phone book, and assume that the hash formula is such that they are distributed more or less randomly throughout the book (so that all the people whose last names start with S aren't clumped together, for example). Given these assumptions, if you turn to page 719, you'll have only one or at most a handful of names to look through to find John Smith.<a id="IDX-CHP-10-0033" class="indexterm"></a><a id="IDX-CHP-10-0034" class="indexterm"></a><a id="IDX-CHP-10-0035" class="indexterm"></a><a id="IDX-CHP-10-0036" class="indexterm"></a><a id="IDX-CHP-10-0037" class="indexterm"></a></p><p>This would be pretty impractical for a phone book meant for humans, but it turns out to be an efficient way for a computer to store things and retrieve them. A table index like <code class="literal">Tbl.Xyz</code> tells Lua to hash "<code class="literal">Xyz</code>" and look for its value in the same place as the other keys (if any) with the same hash.</p><p>Hashing is a good way to store key-value pairs if the keys can be any type at all. But for keys that are consecutive integers, nothing beats storing only the values in memory one right after the other, in order by key. Finding a particular key's value is then just a matter of adding that key to the memory address right before where the values start, which avoids the overhead of computing the hash and possibly searching through other keys with the same hash. If Lua notices that an array has consecutive integer keys starting at <code class="literal">1</code>, then it lays their values out this way, in what is called the <span class="emphasis"><em>array part</em></span> of the table. The rest of the table is kept in the <span class="emphasis"><em>hash part</em></span>.<a id="IDX-CHP-10-0038" class="indexterm"></a></p><p>This makes Lua tables more efficient for common uses, but it's just an implementation detail—it doesn't alter a table's behavior as far as what key-value pairs that table contains. For example, <code class="literal">ipairs</code> goes through all consecutive integer keys whether they're in the array part or the hash part of the table. (The distinction between a table's array part and hash part explains some aspects of Lua's behavior that are explicitly undefined, such as the unpredictable length of an array with gaps.)</p><p>Lua strings are said to be <span class="emphasis"><em>interned</em></span>. This means that a new string is only created if a string does not already exist with the same sequence of characters. On the second line of the following example, when "<code class="literal">X</code>" and "<code class="literal">YZ</code>" are concatenated to form "<code class="literal">XYZ</code>", Lua asks itself, "do I already have a string that has this sequence of characters?" (This is the part of strings' implementation that uses hashing, so that answering this question doesn't require a search through every single currently existing string.)<a id="IDX-CHP-10-0039" class="indexterm"></a></p><pre class="programlisting">A = "XYZ"
B = "X" .. "YZ"</pre><p>In this case, the answer is yes, so rather than setting aside a new hunk of memory to store the string, it just assigns the string that's already in <code class="literal">A</code> to <code class="literal">B</code>. This is why Lua strings are immutable—otherwise <code class="literal">A</code> would change if <code class="literal">B</code> were changed. The main advantages of interning are that determining whether two strings are equal is very quick, and it takes the same amount of time even if the strings are very long. Another advantage is that storing lots of identical strings takes much less memory.</p><p>A disadvantage of interning is that even strings that are used only briefly need to go through the overhead of being hashed and then being interned (if they're not already equal to a previously interned string). This is why the <code class="literal">GarbageTest</code> example caused memory churn: On every iteration, a new string was interned, but at the end of every iteration, the just-interned string became eligible for garbage collection. The rules of thumb given for avoiding memory churn work because they avoid unnecessarily interning long but short-lived strings.<a id="IDX-CHP-10-0040" class="indexterm"></a><a id="IDX-CHP-10-0041" class="indexterm"></a></p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="the_debug_library"></a>The Debug Library</h1></div></div></div><p>The debug library includes various functions for looking under the hood of Lua code. These functions are available in the table <code class="literal">debug</code>.<a id="IDX-CHP-10-0042" class="indexterm"></a><a id="IDX-CHP-10-0043" class="indexterm"></a><a id="IDX-CHP-10-0044" class="indexterm"></a></p><p>Use the debug library with caution. Its functions violate the normal rules of what values and variables are accessible from where. These functions can also be slow. Unless you are writing a debugging tool or something else that needs to poke around in Lua's guts, you probably don't want to use the debug library.</p><p>All of the functionality described in this section is also available from C. In cases where speed is important, you may want to work from C rather than Lua.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="inspecting_and_manipulating_running_code"></a>Inspecting and Manipulating Running Code</h2></div></div></div><p>Some of the debug library's functions enable you to look at and alter running functions and their variables. In the following Try It Out, you use these functions to access local variables that are not in scope.</p><div class="sidebar"><a id="try_it_out_colon_accessing_out-of-scope"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Accessing Out-of-Scope Locals</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Type the following into the interpreter:</p><pre class="programlisting">I = "global"

function Inner()
  local I = "inside Inner, outside loop"
  for I = 1, 10 do
    if I == 5 then
      debug.debug()
    end
    print("I (inside loop): " .. I)
  end
end

function Outer()
  local I = "inside Outer"
  Inner()
end</pre></li><li class="listitem"><p>Call <code class="literal">Outer</code>. You'll see the following:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Outer()</code></strong>
I (inside loop): 1
I (inside loop): 2
I (inside loop): 3
I (inside loop): 4
lua_debug&gt;</pre></li><li class="listitem"><p>The last line ("<code class="literal">lua_debug&lt;</code>") is a debugging prompt. It's similar to the prompt you're already familiar with, but less full-featured. In particular, it doesn't accept input spread between multiple lines, and you might also find that line-editing keys such as backspace don't work with it, so type the following carefully:</p><pre class="programlisting">lua_debug&gt; <strong class="userinput"><code>print(I)</code></strong>
global
lua_debug&gt; <strong class="userinput"><code>local I = "this chunk"; print(debug.getlocal(1, 1))</code></strong>
I        this chunk
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(2, 1))</code></strong>
nil
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 1))</code></strong>
I        inside Inner, outside loop
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 2))</code></strong>
(for index)       5
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 3))</code></strong>
(for limit)       10
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 4))</code></strong>
(for step)        1
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 5))</code></strong>
I                 5
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 6))</code></strong>
nil
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(4, 1))</code></strong>
I        inside Outer
lua_debug&gt; <strong class="userinput"><code>print(debug.setlocal(3, 5, "Kilroy was here!"))</code></strong>
I
lua_debug&gt; <strong class="userinput"><code>cont</code></strong>
I (inside loop): Kilroy was here!
I (inside loop): 6
I (inside loop): 7
I (inside loop): 8
I (inside loop): 9
I (inside loop): 10</pre></li></ol></div><p><span class="strong"><strong>How It Works</strong></span><a id="IDX-CHP-10-0045" class="indexterm"></a><a id="IDX-CHP-10-0046" class="indexterm"></a></p><p>The <code class="literal">debug.debug</code> function opens an "interpreter within the interpreter"—an interpreter that runs while something else (in this case, the <code class="literal">for</code> loop inside of <code class="literal">Inner</code>) is still running. There is nothing magical about this—ssmdyou could write it yourself using <code class="literal">io.read, loadstring</code>, and <code class="literal">io.stderr:write</code>. Because each line you type is a separate chunk, you can't access variables local to <code class="literal">Inner</code> and <code class="literal">Outer</code> in the normal way shown here:</p><pre class="programlisting">lua_debug&gt; <strong class="userinput"><code>print(I)</code></strong>
global</pre><p>Instead, you can use the <code class="literal">debug.getlocal</code> function, which can access variables even if they're out of scope. This function takes two arguments, both numbers. You use the first argument to specify which stack frame you want to look in. In the second argument, you specify which local within that stack frame you want. <code class="literal">debug.getlocal</code> itself is considered to be at stack frame 0, and the function calling <code class="literal">debug.getlocal</code> is considered to be at stack frame 1, so the following means "get the first local variable in the current function" (the current function being the chunk typed at the prompt):</p><pre class="programlisting">lua_debug&gt; <strong class="userinput"><code>local I = "this chunk"; print(debug.getlocal(1, 1))</code></strong>
I  this chunk</pre><p><code class="literal">debug.getlocal</code> returns both the variable's name and its value.</p><p>Local variables are numbered consecutively, starting at 1. In the following snippet, <code class="literal">debug.getlocal</code> is asked for the first local variable in stack frame 2, which is the <code class="literal">debug.debug</code> function itself. <code class="literal">debug.debug</code> has no local variables, so <code class="literal">debug.getlocal</code> returns <code class="literal">nil</code>:<a id="IDX-CHP-10-0047" class="indexterm"></a><a id="IDX-CHP-10-0048" class="indexterm"></a><a id="IDX-CHP-10-0049" class="indexterm"></a><a id="IDX-CHP-10-0050" class="indexterm"></a></p><pre class="programlisting">lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(2, 1))</code></strong>
nil</pre><p>Because <code class="literal">debug.debug</code> is at stack frame 2, the function that called it (<code class="literal">Inner</code>) must be at stack frame 3. Not only can <code class="literal">debug.getlocal</code> see both of <code class="literal">Inner</code>'s local variables named <code class="literal">I</code>, but it can also see the hidden variables that Lua uses to keep track of the loop. These are the ones whose names start with an open parenthesis:</p><pre class="programlisting">lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 1))</code></strong>
I      inside Inner, outside loop
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 2))</code></strong>
(for index)  5
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 3))</code></strong>
(for limit)  10
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 4))</code></strong>
(for step)  1
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 5))</code></strong>
I     5
lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(3, 6))</code></strong>
nil</pre><p><code class="literal">debug.getlocal</code> can also see inside <code class="literal">Outer</code> as follows:</p><pre class="programlisting">lua_debug&gt; <strong class="userinput"><code>print(debug.getlocal(4, 1))</code></strong>
I                  inside Outer</pre><p>The <code class="literal">debug.setlocal</code> function is similar to <code class="literal">debug.getlocal</code>, except it assigns a value to the specified local (and returns the local's name). If the debugging prompt sees a line with nothing but the magic word <code class="literal">cont</code> on it, then <code class="literal">debug.debug</code> returns and the code that called it continues. In this case, the loop continues where it left off, except <code class="literal">I</code> has received a new value:</p><pre class="programlisting">lua_debug&gt; <strong class="userinput"><code>print(debug.setlocal(3, 5, "Kilroy was here!"))</code></strong>
I
lua_debug&gt; <strong class="userinput"><code>cont</code></strong>
I (inside loop): Kilroy was here!
I (inside loop): 6
I (inside loop): 7
I (inside loop): 8
I (inside loop): 9
I (inside loop): 10</pre></div><p>Rather than figuring out in your head what functions are at what stack frames, you can use the <code class="literal">debug.traceback</code> function (introduced in <a class="link" href="ch06.html" title="Chapter 6. Handling and Avoiding Errors">Chapter 6</a>) as shown in this example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Outer()</code></strong>
I(inside loop): 1
I (inside loop): 2
I (inside loop): 3</pre><pre class="programlisting">I (inside loop): 4
lua_debug&gt; <strong class="userinput"><code>print(debug.traceback())</code></strong>
stack traceback:
        (debug command):1: in main chunk
        [C]: in function 'debug'
        stdin:5: in function 'Inner'
        stdin:3: in function 'Outer'
        stdin:1: in main chunk
        [C]: ?</pre><p>For more detail about a given stack frame and the function running at that stack frame, use the function <code class="literal">debug.getinfo</code>, which returns either an associative table or <code class="literal">nil</code> if there is no frame at the requested stack level. The table's fields will be explained in a moment, but you can see the correspondence between each stack frame's <code class="literal">short_src, currentline</code>, and <code class="literal">name</code> fields in the following example and that stack frame's line in the previous traceback:<a id="IDX-CHP-10-0051" class="indexterm"></a></p><pre class="programlisting">lua_debug&gt; <strong class="userinput"><code>for K, V in pairs(debug.getinfo(1)) do print(K, V) end</code></strong>
nups    0
what    main
func    function: 0x495e40
lastlinedefined 0
source =(debug command)
currentline     1
namewhat
linedefined     0
short_src  (debug command)
lua_debug&gt; <strong class="userinput"><code>for K, V in pairs(debug.getinfo(2)) do print(K, V) end</code></strong>
source  =[C]
what    C
func    function: 0x485730
nups    0
short_src        [C]
name    debug
currentline      −1
namewhat         field
linedefined      −1
lastlinedefined  −1
lua_debug&gt; <strong class="userinput"><code>for K, V in pairs(debug.getinfo(3)) do print(K, V) end</code></strong>
source   =stdin
what     Lua
func     function: 0x495918
nups     0
short_src        stdin
name    Inner
currentline      5
namewhat         global
linedefined      1
lastlinedefined  9
lua_debug&gt; <strong class="userinput"><code>for K, V in pairs(debug.getinfo(4)) do print(K, V) end</code></strong>
source   =stdin
what     Lua
func     function: 0x496cc8
nups     0
short_src  stdin</pre><pre class="programlisting">name Outer
currentline       3
namewhat          global
linedefined       1
lastlinedefined   4
lua_debug&gt; <strong class="userinput"><code>for K, V in pairs(debug.getinfo(5)) do print(K, V) end</code></strong>
nups     0
what     main
func     function: 0x495240
lastlinedefined  0
source  =stdin
currentline      1
namewhat
linedefined      0
short_src        stdin
lua_debug&gt; <strong class="userinput"><code>for K, V in pairs(debug.getinfo(6)) do print(K, V) end</code></strong>
nups     0
what     C
func     function: 0x480d78
lastlinedefined  −1
source  =[C]
currentline      −1
namewhat
linedefined      −1
short_src        [C]
lua_debug&gt; <strong class="userinput"><code>print(debug.getinfo(7))</code></strong>
nil</pre><p>If no second argument is given, the contents of the table default to the fields shown in the previous output. If the second argument is a string, the characters in it are treated as code letters that specify which fields to include. The following table gives the meanings of the fields. All line numbers are line numbers of the chunk the function was defined in or <code class="literal">−1</code> if no line number is available. Some of the code letters select multiple fields.<a id="IDX-CHP-10-0052" class="indexterm"></a><a id="IDX-CHP-10-0053" class="indexterm"></a><a id="IDX-CHP-10-0054" class="indexterm"></a><a id="IDX-CHP-10-0055" class="indexterm"></a></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"><col class="col2"><col class="col3"></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Field name</p></th><th style="text-align: left" valign="bottom"><p>Meaning</p></th><th style="text-align: left" valign="bottom"><p>Code Letter</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">activelines</code></p></td><td style="text-align: left" valign="top"><p>A table whose indexes are the line numbers of those lines in this stack frame's function that have code on them. Empty lines and lines with nothing but comments don't count, nor do lines where nothing actually happens on the bytecode level (such as lines with <code class="literal">end</code> keywords). This is the only field not returned if no second argument is given.</p></td><td style="text-align: left" valign="top"><p><code class="literal">L</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">currentline</code></p></td><td style="text-align: left" valign="top"><p>The line number of the currently running line in the selected stack frame.</p></td><td style="text-align: left" valign="top"><p><code class="literal">l</code> (lowercase)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">func</code></p></td><td style="text-align: left" valign="top"><p>This stack frame's function.</p></td><td style="text-align: left" valign="top"><p><code class="literal">f</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">lastlinedefined</code></p></td><td style="text-align: left" valign="top"><p>The line number of the last line of the function's definition.</p></td><td style="text-align: left" valign="top"><p><code class="literal">S</code> (uppercase)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">linedefined</code><a id="IDX-CHP-10-0056" class="indexterm"></a><a id="IDX-CHP-10-0057" class="indexterm"></a><a id="IDX-CHP-10-0058" class="indexterm"></a><a id="IDX-CHP-10-0059" class="indexterm"></a><a id="IDX-CHP-10-0060" class="indexterm"></a><a id="IDX-CHP-10-0061" class="indexterm"></a><a id="IDX-CHP-10-0062" class="indexterm"></a></p></td><td style="text-align: left" valign="top"><p>The line number of the first line of the function's definition.</p></td><td style="text-align: left" valign="top"><p><code class="literal">S</code> (uppercase)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">name</code></p></td><td style="text-align: left" valign="top"><p>The function's name, or <code class="literal">nil</code> if Lua can't figure out a meaningful name (because the function is anonymous, for example). If the function did a tail call, this will be the empty string.</p></td><td style="text-align: left" valign="top"><p><code class="literal">n</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">namewhat</code></p></td><td style="text-align: left" valign="top"><p>What type of name the <code class="literal">name</code> field is. This can be "<code class="literal">field"</code>, "<code class="literal">global"</code>, "<code class="literal">local"</code>, "<code class="literal">method"</code>, "<code class="literal">upvalue"</code>, or (if no <code class="literal">name</code> was found) "<code class="literal">"</code>.</p></td><td style="text-align: left" valign="top"><p><code class="literal">n</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">nups</code></p></td><td style="text-align: left" valign="top"><p>The number of upvalues the function has.</p></td><td style="text-align: left" valign="top"><p><code class="literal">u</code> (lowercase)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">short_src</code></p></td><td style="text-align: left" valign="top"><p>An abbreviated version of <code class="literal">source</code> (convenient for use in error messages).</p></td><td style="text-align: left" valign="top"><p><code class="literal">S</code> (uppercase)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">source</code></p></td><td style="text-align: left" valign="top"><p>If the chunk in which the function was defined was a file, then the <code class="literal">source</code> field is the character <code class="literal">@</code> followed by the filename. If the chunk was just a string, <code class="literal">source</code> is that string, or the string's chunk name if one was given (as the second argument to <code class="literal">loadstring</code>, for example). If the function is a C function, <code class="literal">source</code> is "<code class="literal">=[C]"</code>. If the stack frame has been reused by a tail call, then <code class="literal">source</code> is "<code class="literal">=(tail call)"</code>.</p></td><td style="text-align: left" valign="top"><p><code class="literal">S</code> (uppercase)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">what</code></p></td><td style="text-align: left" valign="top"><p>If the function did a tail call (and its stack frame has therefore been overwritten), <code class="literal">what</code> is "<code class="literal">tail"</code>. Otherwise, if the function is an entire chunk, <code class="literal">what</code> is "<code class="literal">main"</code>; or if it's a regular Lua function or a C function, <code class="literal">what</code> is "<code class="literal">Lua"</code> or "<code class="literal">C"</code>. A function written in a language other than Lua or C is considered a C function, because its Lua binding is in C.</p></td><td style="text-align: left" valign="top"><p><code class="literal">S</code> (uppercase)</p></td></tr></tbody></table></div><p>When you're figuring out the number to give functions like <code class="literal">debug.getlocal</code> and <code class="literal">debug.getinfo</code> to specify a stack frame, you should include tail calls in your reckoning, even though they don't really get their own stack frames. Because tail calls reuse their callers' stack frames, no other information is available about a function that did a tail call. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>return (function() -- This whole chunk is a function that</code></strong>
&gt;&gt;   <strong class="userinput"><code>-- does a tail call to an anonymous function. This</code></strong>
&gt;&gt;   <strong class="userinput"><code>-- anonymous function can get its caller's info, but</code></strong>
&gt;&gt;   <strong class="userinput"><code>-- there's not much there:</code></strong>
&gt;&gt;   <strong class="userinput"><code>for K, V in pairs(debug.getinfo(2)) do</code></strong>
&gt;&gt;       <strong class="userinput"><code>print(K, V)</code></strong>
&gt;&gt;   <strong class="userinput"><code>end</code></strong>
&gt;&gt; <strong class="userinput"><code>end)()</code></strong>
source  =(tail call)
what    tail</pre><pre class="programlisting">nups    0
short_src       (tail call)
name
currentline     −1
namewhat
linedefined     −1
lastlinedefined −1</pre><p>The first argument to <code class="literal">debug.getinfo</code> can be a function rather than a stack level. For example:<a id="IDX-CHP-10-0063" class="indexterm"></a><a id="IDX-CHP-10-0064" class="indexterm"></a><a id="IDX-CHP-10-0065" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>function Greet(Name)</code></strong>
&gt;&gt;   <strong class="userinput"><code>print("Hello, " .. Name .. ".")</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>for K, V in pairs(debug.getinfo(Greet)) do</code></strong>
&gt;&gt;    <strong class="userinput"><code>print(K, V)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
nups    0
what    Lua
func    function: 0x494078
lastlinedefined 3
source  =stdin
currentline     −1
namewhat
linedefined     1
short_src       stdin</pre><p>Notice that <code class="literal">currentline</code> is <code class="literal">−1</code> because <code class="literal">debug.getinfo</code> doesn't know whether the function passed to it is even running, or, if it is, what stack levels it's running on. Also notice that <code class="literal">name</code> is not included. That's because as far as <code class="literal">debug.getinfo</code> is concerned, the function passed to it is just a value (it doesn't know that you got it from the global variable <code class="literal">Greet</code>).</p><p>The <code class="literal">debug.getupvalue</code> and <code class="literal">debug.setupvalue</code> functions are similar to <code class="literal">debug.getlocal</code> and <code class="literal">debug.setlocal</code>, except that they are for upvalues, whereas the latter functions are only for locals whose scope begins (and ends) within the function at the given stack frame. Also, instead of taking a stack frame as their first argument, <code class="literal">debug.getupvalue</code> and <code class="literal">debug.setupvalue</code> can only take a function, as specified here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>do</code></strong>
&gt;&gt;   <strong class="userinput"><code>local N = 0</code></strong>
&gt;&gt;
&gt;&gt;   <strong class="userinput"><code>-- Returns a number one higher than the last every time</code></strong>
&gt;&gt;   <strong class="userinput"><code>-- it's called:</code></strong>
&gt;&gt;   <strong class="userinput"><code>function Counter()</code></strong>
&gt;&gt;      <strong class="userinput"><code>N = N + 1</code></strong>
&gt;&gt;      <strong class="userinput"><code>return N</code></strong>
&gt;&gt;   <strong class="userinput"><code>end</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>-- Print Counter's first upvalue's name and value:</code></strong>
&gt; <strong class="userinput"><code>print(debug.getupvalue(Counter, 1))</code></strong>
N       0</pre><pre class="programlisting">&gt; <strong class="userinput"><code>-- Counter only has one upvalue; trying to get the second</code></strong>
&gt; <strong class="userinput"><code>-- returns nothing:</code></strong>
&gt; <strong class="userinput"><code>print(debug.getupvalue(Counter, 2))</code></strong>

&gt; <strong class="userinput"><code>print(Counter())</code></strong>
1
&gt; <strong class="userinput"><code>print(Counter())</code></strong>
2
&gt; <strong class="userinput"><code>print(debug.getupvalue(Counter, 1))</code></strong>
N       2
&gt; <strong class="userinput"><code>-- Set the upvalue to −100; Counter will add one to this</code></strong>
&gt; <strong class="userinput"><code>-- before returning it:</code></strong>
&gt; <strong class="userinput"><code>debug.setupvalue(Counter, 1, −100)</code></strong>
&gt; <strong class="userinput"><code>print(Counter())</code></strong>
-99</pre><p>Because of Lua's scoping rules, two locals in the same stack frame can have the same name, but two upvalues in the same function cannot.<a id="IDX-CHP-10-0066" class="indexterm"></a><a id="IDX-CHP-10-0067" class="indexterm"></a></p><p>Separate threads of execution have separate stacks. <code class="literal">debug.getinfo, debug.getlocal, debug.setlocal</code>, and <code class="literal">debug.traceback</code> work by default on the currently running thread, but take an optional first argument of the thread to be used (shifting any other arguments over to compensate). For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>function FncA()</code></strong>
&gt;&gt;   <strong class="userinput"><code>FncB()</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>function FncB()</code></strong>
&gt;&gt;   <strong class="userinput"><code>coroutine.yield()</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt;
&gt; <strong class="userinput"><code>Thread = coroutine.create(FncA)</code></strong>
&gt; <strong class="userinput"><code>coroutine.resume(Thread)</code></strong>
&gt; <strong class="userinput"><code>print(debug.traceback(Thread, "Inside another thread"))</code></strong>
Inside another thread
stack traceback:
        [C]: in function 'yield'
        stdin:2: in function 'FncB'
        stdin:2: in function &lt;stdin:1&gt;</pre><div class="blockquote"><blockquote class="blockquote"><p>None of Lua 5.0's debug functions took this optional first argument.</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="hooks"></a>Hooks</h2></div></div></div><p>The debug library enables you to use <span class="emphasis"><em>hooks</em></span>, which are functions that Lua calls automatically as other code is running. These are useful for debugging, and you can also use them to <span class="emphasis"><em>profile</em></span> code (to find out how much time is spent in which parts of a program, for example).</p><p>In the following Try It Out, you define a hook that prints information about function calls and returns as they happen.</p><div class="sidebar"><a id="try_it_out_colon_tracing_function_calls"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Tracing Function Calls with a Hook</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Save the following as <code class="literal">calltrace.lua</code>:</p><pre class="programlisting">-- Creates two global functions: a function that traces function calls
-- and returns, and another function to turn it off.
--
-- Usage:
--   require("calltrace")
--   Trace() -- Turns on tracing.
--   Untrace() -- Turns off tracing.

-- The current depth of the stack (nil when not tracing):
local Depth

-- Returns a string naming the function at StackLvl; this string will
-- include the function's current line number if WithLineNum is true. A
-- sensible string will be returned even if a name or line numbers
-- can't be found.
local function GetInfo(StackLvl, WithLineNum)
  -- StackLvl is reckoned from the caller's level:
  StackLvl = StackLvl + 1
  local Ret
  local Info = debug.getinfo(StackLvl, "nlS")
  if Info then
    local Name, What, LineNum, ShortSrc =
      Info.name, Info.what, Info.currentline, Info.short_src
    if What == "tail" then
      Ret = "overwritten stack frame"
    else
      if not Name then
        if What == "main" then
          Name = "chunk"
        else
          Name = What .. " function"
        end
      end
      if Name == "C function" then
        Ret = Name
      else
        -- Only use real line numbers:
        LineNum = LineNum &lt;= 1 and LineNum
        if WithLineNum and LineNum then
          Ret = Name .. " (" .. ShortSrc .. ", line " .. LineNum
            .. ")"
        else
          Ret = Name .. " (" .. ShortSrc .. ")"
        end
      end
    end
  else
    -- Below the bottom of the stack:
    Ret = "nowhere"
  end
  return Ret</pre><pre class="programlisting">end
  -- Returns a string of N spaces:
  local function Indent(N)
    return string.rep(" ", N)
  end

  -- The hook function set by Trace:
  local function Hook(Event)
    -- Info for the running function being called or returned from:
    local Running = GetInfo(2)
    -- Info for the function that called that function:
    local Caller = GetInfo(3, true)
    if Event == "call" then
      Depth = Depth + 1
      io.stderr:write(Indent(Depth), "calling ", Running, " from ",
        Caller, "\n")
    else
      local RetType
      if Event == "return" then
        RetType = "returning from "
      elseif Event == "tail return" then
        RetType = "tail-returning from "
      end
      io.stderr:write(Indent(Depth), RetType, Running, " to ", Caller,
        "\n")
      Depth = Depth - 1
    end
  end

  -- Sets a hook function that prints (to stderr) a trace of function
  -- calls and returns:
  function Trace()
    if not Depth then
      -- Before setting the hook, make an iterator that calls
      -- debug.getinfo repeatedly in search of the bottom of the stack:
      Depth = 1
      for Info in
        function()
          return debug.getinfo(Depth, "n")
        end
      do
        Depth = Depth + 1
      end
      -- Don't count the iterator itself or the empty frame counted at
      -- the end of the loop:
      Depth = Depth - 2
      debug.sethook(Hook, "cr")
    else
      -- Do nothing if Trace() is called twice.
    end
  end
  -- Unsets the hook function set by Trace:</pre><pre class="programlisting">function Untrace()
   debug.sethook()
   Depth = nil
 end</pre></li><li class="listitem"><p>Type the following into the interpreter:</p><pre class="programlisting">require("calltrace")

function FncA()
  FncB()
end

function FncB()
  FncC()
end

function FncC()
  print("Inside FncC")
end

Trace()
FncA()
Untrace()</pre></li><li class="listitem"><p>Starting from where you typed <code class="literal">Trace()</code>, the output should look like this:</p><pre class="programlisting">&lt; <strong class="userinput"><code>Trace()</code></strong>
   returning from sethook ([C]) to Trace (./calltrace.lua, line 99)
  returning from Trace (./calltrace.lua) to chunk (stdin, line 1)
 returning from chunk (stdin) to C function
&lt; <strong class="userinput"><code>FncA()</code></strong>
 calling chunk (stdin) from C function
  calling FncA (stdin) from chunk (stdin, line 1)
   calling FncB (stdin) from FncA (stdin, line 2)
    calling FncC (stdin) from FncB (stdin, line 2)
     calling print ([C]) from FncC (stdin, line 2)
      calling C function from print ([C])
      returning from C function to print ([C])
Inside FncC
     returning from print ([C]) to FncC (stdin, line 2)
    returning from FncC (stdin) to FncB (stdin, line 2)
   returning from FncB (stdin) to FncA (stdin, line 2)
  returning from FncA (stdin) to chunk (stdin, line 1)
 returning from chunk (stdin) to C function
&lt; <strong class="userinput"><code>Untrace()</code></strong>
 calling chunk (stdin) from C function
  calling Untrace (./calltrace.lua) from chunk (stdin, line 1)
   calling sethook ([C]) from Untrace (./calltrace.lua, line 107)
&lt;</pre></li></ol></div><p><span class="strong"><strong>How It Work</strong></span></p><p>When <code class="literal">Trace</code> is called, it measures the current depth of the stack (by calling <code class="literal">debug.getinfo</code> with deeper and deeper stack levels until it returns <code class="literal">nil</code>), and then it uses <code class="literal">debug.sethook(Hook, "cr")</code> to set <code class="literal">Hook</code> as a hook to be called whenever a function is called (the <code class="literal">c</code> in "<code class="literal">cr</code>") and whenever a function returns (the <code class="literal">r</code>). The hook itself is called with an argument of "<code class="literal">call"</code>, "<code class="literal">return"</code>, or "<code class="literal">tail return"</code>, depending on why it was called. It runs on top of the stack, which means it can get information about the function that was running when the hook was called by using <code class="literal">2</code> as an argument to <code class="literal">debug.getinfo</code>, and information about the function that called that one by using <code class="literal">3</code>. The retrieval of this information is hidden in the <code class="literal">GetInfo</code> function (which therefore needs to add <code class="literal">1</code> to its argument before calling <code class="literal">debug.getinfo</code>). The hook prints this information, indenting it by one column per stack frame.<a id="IDX-CHP-10-0068" class="indexterm"></a></p><p>As soon as the hook is set, it starts tracing. These lines show control returning from <code class="literal">debug.sethook</code>, through <code class="literal">Trace</code> and the interpreted chunk, back to the interpreter itself:</p><pre class="programlisting">returning from sethook ([C]) to Trace (./calltrace.lua, line 99)
  returning from Trace (./calltrace.lua) to chunk (stdin, line 1)
 returning from chunk (stdin) to C function</pre><p>Then when <code class="literal">FncA</code> is called, it calls <code class="literal">FncB</code>, which calls <code class="literal">FncC</code>, which calls <code class="literal">print</code>, which calls a C function (<code class="literal">tostring</code>, if you're curious). This C function returns, and then <code class="literal">print</code> prints the message given to it by <code class="literal">FncC</code>:</p><pre class="programlisting">calling chunk (stdin) from C function
  calling FncA (stdin) from chunk (stdin, line 1)
   calling FncB (stdin) from FncA (stdin, line 2)
    calling FncC (stdin) from FncB (stdin, line 2)
     calling print ([C]) from FncC (stdin, line 2)
      calling C function from print ([C])
      returning from C function to print ([C])
Inside FncC</pre><p>Control then returns back to the main loop of the interpreter through <code class="literal">FncC, FncB, FncA</code>, and the chunk where <code class="literal">FncA</code> was called:</p><pre class="programlisting">returning from print ([C]) to FncC (stdin, line 2)
      returning from FncC (stdin) to FncB (stdin, line 2)
     returning from FncB (stdin) to FncA (stdin, line 2)
    returning from FncA (stdin) to chunk (stdin, line 1)
   returning from chunk (stdin) to C function</pre><div class="blockquote"><blockquote class="blockquote"><p>In this example, the <code class="literal">Inside FncC</code> message was right where you'd expect it to be, just before <code class="literal">print</code> returned. Because that message was printed to standard output and the call trace was printed to standard error, your system may not output them in the right order, particularly if you use your shell's redirection operators to send the program's output to files or other programs.</p></blockquote></div><p>A hook is not called again until after it has returned. That's why <code class="literal">Hook</code>'s call to <code class="literal">GetInfo</code> is not traced. (If it were, there'd be an infinite regress and the rest of the program would never be reached.)</p><p><code class="literal">Untrace</code> unsets the hook by calling <code class="literal">debug.sethook</code> with no arguments. (It also <code class="literal">nil</code>s out <code class="literal">Depth</code> so that future calls to <code class="literal">Trace</code> from different stack levels will work.)</p></div><p>Tail calls are indented as though they grew the stack, like this:</p><pre class="programlisting">do -- local scope for Count.
  local Count = 5

  -- Keeps tail-calling itself until Count is 0:
  function Tail()
    if Count == 0 then
      return
    else
      Count = Count - 1
      return Tail()
    end
  end
end</pre><p>The function's call trace looks like this:</p><pre class="programlisting">calling chunk (stdin) from C function
   calling Tail (stdin) from chunk (stdin, line 1)
    calling Tail (stdin) from Tail (stdin, line 10)
     calling Tail (stdin) from Lua function (stdin, line 10)
      calling Tail (stdin) from Lua function (stdin, line 10)
       calling Tail (stdin) from Lua function (stdin, line 10)
        calling Tail (stdin) from Lua function (stdin, line 10)
        returning from Lua function (stdin) to overwritten stack frame
       tail-returning from Lua function (stdin) to overwritten stack frame
      tail-returning from Lua function (stdin) to overwritten stack frame
     tail-returning from Lua function (stdin) to overwritten stack frame
    tail-returning from Lua function (stdin) to overwritten stack frame
   tail-returning from Tail (stdin) to chunk (stdin, line 1)
  returning from chunk (stdin) to C function</pre><p>Notice that a <span class="emphasis"><em>tail return</em></span> is <span class="emphasis"><em>not</em></span> a return from a tail call. It's a return from a function that did a tail call.<a id="IDX-CHP-10-0069" class="indexterm"></a></p><p>It's possible to write a version of <code class="literal">Trace</code> that takes a list of functions and only traces those functions. The hook would still be called on every call and return, but it would check the list before printing anything. Depending on what information you wanted to print about returns from tail calls, you might need to manage your own stack that would grow even on tail calls.</p><p>If you use an end-of-file to exit the interpreter while calls are still being traced, you'll see the trace hit the left margin like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>^D</code></strong>
returning from C function to nowhere</pre><p>Because the second argument to <code class="literal">debug.sethook</code> was "<code class="literal">cr"</code>, the hook was called on calls and returns. If that argument includes the letter "<code class="literal">l"</code>, the hook will be called on every line of code, not counting lines where nothing happens (lines not counted by the <code class="literal">activelines</code> field of <code class="literal">debug.getinfo</code>'s return value). The hook will be called with two arguments: the string "<code class="literal">line"</code>, and the line number.</p><p>If <code class="literal">debug.sethook</code> has a nonzero third argument (called the <span class="emphasis"><em>hook count</em></span>), the hook will be called every time that many bytecode instructions have been executed. It will receive the "<code class="literal">count"</code> string as an argument.<a id="IDX-CHP-10-0070" class="indexterm"></a></p><p>The <code class="literal">debug.gethook</code> function returns three values: the current hook function, the current <span class="emphasis"><em>hook mask</em></span> (the string containing zero or more of "<code class="literal">c"</code>, "<code class="literal">l"</code>, and "<code class="literal">r"</code>), and the current hook count. For example, if there's no hook set, then the following:<a id="IDX-CHP-10-0071" class="indexterm"></a><a id="IDX-CHP-10-0072" class="indexterm"></a></p><pre class="programlisting">HookFnc, HookMask, HookCount = debug.gethook()
print("HookFnc: " .. tostring(HookFnc) .. "; HookMask: '"
  .. HookMask .. "'; HookCount: " .. HookCount)</pre><p>will print this:</p><pre class="programlisting">HookFnc: nil; HookMask: ''; HookCount: 0</pre><p>If the <code class="literal">calltrace.lua</code> hook is set, then it will print this:</p><pre class="programlisting">HookFnc: function: 0x495e58; HookMask: 'cr'; HookCount: 0</pre><p>Hooks are a per-thread setting. When you set a hook, it only gets set (and then called) in one thread. Like <code class="literal">debug.getinfo, debug.getlocal, debug.setlocal</code>, and <code class="literal">debug.traceback, debug.sethook</code> and <code class="literal">debug.gethook</code> work by default on the currently running thread, but take the thread to be used as an optional first argument. In <code class="literal">debug.sethook</code>, its other arguments are shifted over to compensate.</p><div class="blockquote"><blockquote class="blockquote"><p>The Lua 5.0 versions didn't take this optional argument.</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="other_functions_in_the_debug_library"></a>Other Functions in the Debug Library</h2></div></div></div><p><code class="literal">debug.getfenv</code> and <code class="literal">debug.setfenv</code> are just like <code class="literal">getfenv</code> and <code class="literal">setfenv</code>, except that they work with both Lua and C functions, as well as userdata and threads. (<code class="literal">getfenv</code> and <code class="literal">setfenv</code> only work with Lua functions.)</p><p>Similarly, <code class="literal">debug.getmetatable</code> and <code class="literal">debug.setmetatable</code> are like <code class="literal">getmetatable</code> and <code class="literal">setmetatable</code> except that they work with all values, not just tables.</p><p><code class="literal">debug.getregistry</code> returns the <span class="emphasis"><em>registry table</em></span>, a table that C code can use as a storage area. (See <a class="link" href="ch13.html" title="Chapter 13. Interfacing Lua with Other Languages">Chapter 13</a>.)</p><div class="blockquote"><blockquote class="blockquote"><p>Lua 5.0 did not include any of these five functions.</p></blockquote></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="summary-031"></a>Summary</h1></div></div></div><p>In this chapter you learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You can use the <code class="literal">luac</code> command-line program to compile source code to bytecode, or to print a human-readable bytecode listing.</p></li><li class="listitem"><p>Memory that is no longer used is reclaimed by the garbage collector. You can control the garbage collector's behavior with the <code class="literal">collectgarbage</code> function.</p></li><li class="listitem"><p>You can use a technique called hashing to implement tables. If Lua thinks that part of a table is being used as an array, it lays that part out sequentially in memory, which is more efficient than hashing for array use.</p></li><li class="listitem"><p>You can also implement strings with hashing. These strings are interned: two strings with the same contents are the same string, and their contents are at the same memory location.</p></li><li class="listitem"><p>The debug library enables you to examine local variables and altered them even if they're out of scope.</p></li><li class="listitem"><p>The debug library also enables you set a hook that will be called on every function call, function return, or line of source code, or every so many bytecode instructions.</p></li></ul></div><p>The next chapter will complete this book's treatment of the Lua language itself, by summarizing Lua's built-in library functions. The chapter after that discusses libraries written by members of the Lua community, then there's a chapter on the C side of Lua, and then the rest of the book is about doing various things in Lua (such as using databases, web programming, and more).</p><p>But first, here are a couple of exercises (with answers in the appendix) to enhance what you've learned in this chapter.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-032"></a>Exercises</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Imagine you have a file of Lua source code (not bytecode) that the Lua interpreter refuses to run, giving instead the error message "bad header in precompiled chunk." What must be wrong with the file to cause this message? (The hint here is the word "precompiled.")</p></li><li class="listitem"><p>Write a <code class="literal">GetVar</code> function that takes a variable name and returns the value of the variable in the scope where it was called. It should follow the same scoping rules as Lua itself (locals, then upvalues, then globals) except that it doesn't need to find external locals that aren't actually upvalues (because of not being referred to as variables anywhere in the function being searched).</p></li></ol></div><div class="blockquote"><blockquote class="blockquote"><p>The variable <code class="literal">D</code> in the following test code is an example of this. According to Lua's scoping rules, the value of <code class="literal">D</code> in <code class="literal">InnerFnc</code> should be <code class="literal">"upvalue"</code> and not "<code class="literal">global</code>", but finding would-be upvalues like <code class="literal">D</code> is actually impossible to do except in special cases.</p></blockquote></div><p>To test your function, run the following code:</p><pre class="programlisting">Gl = "global"
Up = "upvalue"
L = "local"
OL = "outer local"
IL = "inner local"
A, B, C, D, E = Gl, Gl, Gl, Gl, Gl

function OuterFnc()
 local A, B, C, D = Up, Up, Up, Up

 local function InnerFnc(A)
   local A = IL
   local B = L
   local _ = C -- Without this, C, like D, would not be an
      -- upvalue of InnerFnc.
   for _, Name in ipairs({"A", "B", "C", "D", "E"}) do
     print(Name, GetVar(Name))</pre><pre class="programlisting">end
  end

  InnerFnc(OL)
end

OuterFnc()</pre><p>It should print the following:</p><pre class="programlisting">A  inner local
B  local
C  upvalue
D  global
E  global</pre></div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="ch09.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">9. Handling Events Naturally with Coroutines</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="ch11.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">11. Exploring Lua&#39;s Libraries</div>
        </a>
    
  
  </div>


        
    </section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag">
        
        

        
          <p>You have 6 days left in your trial, Michaelschiner. Subscribe today. <a href="https://learning.oreilly.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
        
        

      </div>

    
    



        
      </div>
      
        

<footer class="pagefoot t-pagefoot">
  <a href="ch10.html#" class="icon-up" onclick="window.Appcues.track('JumpTop_HeronBook')"><div class="visuallyhidden">Back to top</div></a>
  <ul class='js-footer-nav'>
  
    
    <li><a href="https://learning.oreilly.com/public/support/">Support</a></li>
    
    <li><a href="https://learning.oreilly.com/accounts/logout/">Sign Out</a></li>
    
  
  
  </ul>
  <span class="copyright">&#169; 2021 <a href="https://learning.oreilly.com/" target="_blank">O'Reilly Media, Inc</a>.</span>
  
    
    <a href="https://www.oreilly.com/terms/">Terms of Service</a> 
     / 
    
    <a href="https://learning.oreilly.com/privacy">Privacy Policy</a> 
    
    
  
</footer>

      
    
    <script src="https://learning.oreilly.com/jsi18n/web/" charset="utf-8"></script>
    <script src="https://learning.oreilly.com/library/jsi18n/appcache/" charset="utf-8"></script>
  </body>
</html>
