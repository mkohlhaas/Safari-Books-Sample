<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch17.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch17.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch17.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch17.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><!--<![endif]--><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="author" content="O'Reilly Media" /><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9780470069172"/><link rel="shortcut icon" href="https://www.oreilly.com/favicon.ico" /><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"/><meta property="twitter:account_id" content="4503599627559754" /><link rel="shortcut icon" href="https://learning.oreilly.com/favicon.ico" type="image/x-icon"><link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic' rel='stylesheet' type='text/css'><title>17. Programming Games with Lua - Beginning Lua Programming</title><link rel="stylesheet" href="https://learning.oreilly.com/static/CACHE/css/output.5bdb4fcb2aad.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://learning.oreilly.com/static/css/annotator.e3b0c44298fc.css"/><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book"></style><script> // <![CDATA[
    var g = {
      position_cache: {
        
          "chapter": "/api/v1/book/9780470069172/chapter/ch17.html",
          "book_id": "9780470069172",
          "chapter_uri": "ch17.html",
          "position": 0,
          "user_uuid": "ce47de5b-ce80-49f0-b5cd-c60d3d33b198",
          "next_chapter_uri": "/library/view/beginning-lua-programming/9780470069172/ch18.html"
        
      },
      title: "Beginning Lua Programming",
      author_list: "Aaron Brown, Kurt Jung",
      format: "book",
      source: "application/epub+zip",
      is_system_book: true,
      is_public: false,
      loaded_from_server: true,
      allow_scripts: false,
      has_mathml: false
    };
    // ]]></script><script src="https://learning.oreilly.com/static/js/src/modernizr.8e35451ddb64.js"></script><script>
    
      

      
        
          window.PUBLIC_ANNOTATIONS = true;
        
      

      window.MOBILE_PUBLIC_ANNOTATIONS = false;

    

    
      window.PRIVACY_CONTROL_OVERRIDE = false;
    

      window.PRIVACY_CONTROL_SWITCH = true;

      window.PUBLISHER_PAGES = true;

      window.SBO = {
        "constants": {
          "SITB_ENDPOINT": "/api/v2/sitb/",
          "SEARCH_SELECT_ENDPOINT": "https://learning.oreilly.com/api/v2/search/select/",
        }
      };
  </script><link rel="canonical" href="ch17.html"/><meta name="description" content="Chapter 17. Programming Games with Lua Although Lua was not designed for video game programming in particular, it is quite popular with game programmers—in fact, they were the first programming ... "><meta property="og:title" content="17. Programming Games with Lua" /><meta itemprop="isPartOf" content="/library/view/beginning-lua-programming/9780470069172/" /><meta itemprop="name" content="17. Programming Games with Lua" /><meta property="og:url" itemprop="url" content="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch17.html" /><meta property="og:site_name" content="Safari" /><meta property="og:image" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9780470069172/" /><meta property="og:description" itemprop="description" content="Chapter 17. Programming Games with Lua Although Lua was not designed for video game programming in particular, it is quite popular with game programmers—in fact, they were the first programming ... "><meta itemprop="inLanguage" content="en" /><meta itemprop="publisher" content="Wrox" /><meta property="og:type" content="book" /><meta property="og:book:isbn" itemprop="isbn" content="9780470069172" /><meta property="og:book:author" itemprop="author" content="Aaron Brown" /><meta property="og:book:author" itemprop="author" content="Kurt Jung" /><meta property="og:book:tag" itemprop="about" content="Core Programming" /><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@OReillyMedia"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><noscript><meta http-equiv="refresh" content="0; URL=https://learning.oreilly.com/library/no-js/" /></noscript><script>
    var dataLayer = window.dataLayer || [];

    
      window.medalliaVsgUserIdentifier = 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198';
      dataLayer.push({userIdentifier: 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198'});
      dataLayer.push({loggedIn: 'yes'});

      
        window.medalliaVsgAccountIdentifier = '29964b7b-68d8-4532-9a9b-32e089689c1f';
        

        window.medalliaVsgIsIndividual = true;
        
          
          dataLayer.push({learningAccountType: 'free trial'});
          
        

        
      
    

    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5P4V6Z');
    (function () {
      var VERSION = 'V1.1';
      var AUTHOR = 'Awwad';
      if (!window.GtmHelper)
        window.GtmHelper = function () {
          var instance = this;
          var loc = document.location;
          this.version = VERSION;
          this.author = AUTHOR;
          this.readCookie = function (name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
              var c = ca[i];
              while (c.charAt(0) == ' ') c = c.substring(1, c.length);
              if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
          };
          this.createCookie = function (name, value, days, cookieDomain) {
            var domain = "";
            var expires = "";

            if (days) {
              var date = new Date();
              date.setTime(date.getTime() + Math.ceil(days * 24 * 60 * 60 * 1000));
              var expires = " expires=" + date.toGMTString() + ";";
            }

            if (typeof (cookieDomain) != 'undefined')
              domain = " domain=" + cookieDomain + "; ";

            document.cookie = name + "=" + value + ";" + expires + domain + "path=/";
          };

          this.isDuplicated = function (currentTransactionId) {
            // the previous transaction id:
            var previousTransIdValue = this.readCookie("previousTransId");

            if (currentTransactionId === previousTransIdValue) {
              return true; // Duplication
            } else {
              return false;
            }
          };
        }
    })()
  </script><script defer src="https://learning.oreilly.com/static/js/build/vendor.0eac897f11ed.js"></script><script defer src="https://learning.oreilly.com/static/js/build/reader.c745ea9296ac.js"></script></head>


<body class="reading sidenav nav-collapsed  scalefonts">

    
  <noscript> 
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
            height="0" width="0"
            style="display:none;visibility:hidden">
    </iframe>
  </noscript>



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        

  


<a href="ch17.html#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li><a href="https://learning.oreilly.com/home/" class="l0 nav-icn"><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.738 14H9.254v-3.676a.617.617 0 0 0-.621-.613H7.39a.617.617 0 0 0-.62.613V14H4.284a.617.617 0 0 1-.622-.613V10.22c0-.327.132-.64.367-.87l3.547-3.493a.627.627 0 0 1 .875 0l3.54 3.499c.234.229.366.54.367.864v3.167a.617.617 0 0 1-.62.613zM7.57 2.181a.625.625 0 0 1 .882 0l5.77 5.692-.93.92-5.28-5.209-5.28 5.208-.932-.919 5.77-5.692z" /></svg><span>Home</span></a></li><li class="search"><a href="ch17.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"/></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="ch17.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"/></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li class="flyout-parent"><a
                href="ch17.html#"
                class="l1 nav-icn "
                
              ><?xml version="1.0" encoding="UTF-8"?><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M8,8 C6.34321755,8 5.00013,6.65691245 5.00013,5.00013 C5.00013,3.34334755 6.34321755,2.00026001 8,2.00026001 C9.65678245,2.00026001 10.99987,3.34334755 10.99987,5.00013 C10.99987,6.65691245 9.65678245,8 8,8 Z M2.33024571,11.3523547 L2.33774538,11.3523547 C3.7622187,9.70968996 5.82947484,8.76608166 8.00374984,8.76608166 C10.1780248,8.76608166 12.245281,9.70968996 13.6697543,11.3523547 C13.8892083,11.6177474 14.0062813,11.9530021 13.99974,12.2973138 L13.99974,13.99974 L2.00026001,13.99974 L2.00026001,12.2973138 C1.99371867,11.9530021 2.11079172,11.6177474 2.33024571,11.3523547 Z" id="path-1"></path></svg><span>Your O&#39;Reilly</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/profile/"
                    class="l2 nav-icn"
                    
                  ><span>Profile</span></a></li><li><a
                    href="https://learning.oreilly.com/history/"
                    class="l2 nav-icn"
                    
                  ><span>History</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/"
                    class="l2 nav-icn"
                    
                  ><span>Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/u/ce47de5b-ce80-49f0-b5cd-c60d3d33b198/"
                    class="l2 nav-icn"
                    
                  ><span>Highlights</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/answers/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M2.31032699,3.75609006 C4.65421571,1.41371359 8.45302454,1.41472092 10.7955702,3.75860838 C13.1381158,6.10249583 13.1369405,9.90130261 10.7930518,12.243847 C8.44916311,14.5863913 4.65018639,14.5852161 2.30780867,12.2413286 C-0.0346204845,9.89749489 -0.0334929936,6.09853298 2.31032699,3.75609006 Z M8.8198605,4.98016308 C7.34193969,3.86924672 5.23410194,3.98609692 3.88914868,5.33104946 C3.12814393,6.09032122 2.72818176,7.13880077 2.79015179,8.21201133 C2.79115912,8.23064692 2.79233434,8.24928252 2.79350956,8.26791811 L2.79350956,8.26791811 C2.83179539,8.8307976 2.9944077,9.37404287 3.26947292,9.86201677 L3.26947292,9.86201677 L2.77621706,11.7027432 C2.7699968,11.7259241 2.77662063,11.7506624 2.79359185,11.7676337 C2.8105631,11.7846049 2.83530144,11.7912287 2.85848233,11.7850085 L2.85848233,11.7850085 L4.69400524,11.2922565 C5.26306363,11.6167344 5.90703177,11.786885 6.56209849,11.7858479 C8.64827865,11.7858479 10.3395879,10.094542 10.3395879,8.00836292 C10.3405204,6.84135608 9.80105674,5.73967784 8.87862141,5.02482134 L8.87862141,5.02482134 L8.82825492,4.98654283 Z M13.7933062,2 C14.7073496,2.00009863 15.4482759,2.74110484 15.4482759,3.65514822 C15.4482759,4.32460943 15.0449926,4.92814782 14.4264842,5.18432286 C13.8079757,5.44049789 13.096053,5.29885769 12.6226979,4.82545158 C12.1493429,4.35204547 12.0077795,3.64010743 12.2640213,3.02162665 C12.5202631,2.40314587 13.123845,1.99992776 13.7933062,2 Z"/></svg><span>Answers</span></a></li><li class="flyout-parent"><a
                href="ch17.html#"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z"/></g></svg><span>Explore</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/topics/"
                    class="l2 nav-icn"
                    
                  ><span>All Topics</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;formats=case%20study&amp;formats=learning%20path&amp;formats=live%20online%20training&amp;formats=notebook&amp;formats=oriole&amp;formats=video&amp;sort=popularity&amp;facet_json=true&amp;page=0&amp;collection_type=expert"
                    class="l2 nav-icn"
                    
                  ><span>Most Popular Titles</span></a></li><li><a
                    href="https://learning.oreilly.com/recommendations/"
                    class="l2 nav-icn"
                    
                  ><span>Recommended</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;sort=publication_date&amp;facet_json=true&amp;page=0"
                    class="l2 nav-icn"
                    
                  ><span>Early Releases</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/discover/"
                    class="l2 nav-icn"
                    
                  ><span>Shared Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/resource-centers/"
                    class="l2 nav-icn"
                    
                  ><span>Resource Centers</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch17.html#"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M12.8 3.2A1.2 1.2 0 0 1 14 4.4v8.4a1.2 1.2 0 0 1-1.2 1.2H3.2A1.2 1.2 0 0 1 2 12.8V4.4a1.2 1.2 0 0 1 1.2-1.2h1.2V2h1.2v1.2h4.8V2h1.2v1.2h1.2zm-9.6 9.6h9.6V6.2H3.2v6.6zM8 9.5a1.35 1.35 0 1 1 0-2.7 1.35 1.35 0 0 1 0 2.7zm2.7 2.148v.552H5.3v-.552c0-.321.124-.634.355-.858a3.358 3.358 0 0 1 4.69 0c.23.224.355.537.355.858z" /></svg><span>Live Events</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/attend/"
                    class="l2 nav-icn"
                    
                  ><span>All Events</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/architectural-katas/"
                    class="l2 nav-icn"
                    
                  ><span>Architectural Katas</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/ai/"
                    class="l2 nav-icn"
                    
                  ><span>AI &amp; ML</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/strata/"
                    class="l2 nav-icn"
                    
                  ><span>Data Sci &amp; Eng</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/oscon/"
                    class="l2 nav-icn"
                    
                  ><span>Programming</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/infrastructure-ops/"
                    class="l2 nav-icn"
                    
                  ><span>Infra &amp; Ops</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/software-architecture/"
                    class="l2 nav-icn"
                    
                  ><span>Software Arch</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch17.html#"
                class="l1 nav-icn "
                
              ><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.6467109,4.35328907 L14.7964612,7.51003884 C15.0678463,7.78304342 15.0678463,8.22395603 14.7964612,8.49696061 L11.6467109,11.6467109 L10.6597892,10.6597892 L13.3055794,8 L10.6597892,5.34021084 L11.6467109,4.35328907 Z M4.35328907,11.6467109 L1.20353875,8.48996116 C0.932153749,8.21695658 0.932153749,7.77604397 1.20353875,7.50303939 L4.35328907,4.35328907 L5.34021084,5.34021084 L2.69442057,8 L5.34021084,10.6597892 L4.35328907,11.6467109 Z M5.84417089,11.4997226 L8.67194674,4.50027742 L10.1838269,4.50027742 L7.35605105,11.4997226 L5.84417089,11.4997226 Z" id="Mask"></path></svg><span>Interactive</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=content-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Scenarios</span></a></li><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=sandbox-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Sandboxes</span></a></li><li><a
                    href="https://learning.oreilly.com/interactive/?classification=jupyter-notebook"
                    class="l2 nav-icn"
                    
                  ><span>Jupyter Notebooks</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/certifications/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M12.912 9.18L14 8.014l-1.088-1.18a.304.304 0 01-.075-.268L13.195 5l-1.535-.463a.313.313 0 01-.194-.194l-.462-1.537-1.565.358c-.09.03-.194 0-.269-.074L8.007 2 6.845 3.09a.303.303 0 01-.269.074l-1.565-.358-.462 1.537a.313.313 0 01-.194.194L2.82 5l.358 1.567a.26.26 0 01-.075.269L2 8.015l1.088 1.164c.075.075.09.18.075.269l-.358 1.567 1.535.463c.09.03.164.104.194.194l.462 1.537 1.565-.358c.015 0 .045-.015.075-.015.075 0 .15.03.209.074L8.007 14l1.163-1.09a.303.303 0 01.269-.074l1.565.358.462-1.537a.313.313 0 01.194-.194L13.195 11l-.358-1.567a.338.338 0 01.075-.254zm-6.046 1.37L4.41 8.26l1.16-1.244 1.767 1.649L10.4 5.6l1.202 1.202-4.242 4.243-.495-.495z"/></svg><span>Certifications</span></a></li><li ><a
                href="https://learning.oreilly.com/preferences/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"/></g></svg><span>Settings</span></a></li><li ><a
                href="https://learning.oreilly.com/public/support/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M7.363 6.656a2.692 2.692 0 0 1-2.681-2.703c0-1.493 1.2-2.703 2.681-2.703a2.692 2.692 0 0 1 2.682 2.703c0 1.493-1.2 2.703-2.682 2.703zm4.023 2.027c-1.852 0-3.352 1.513-3.352 3.379H2v-1.534c-.006-.31.099-.612.295-.852a6.666 6.666 0 0 1 9.09-.993zm-.543.676h1.12v.304c.003.284.16.543.408.676a.766.766 0 0 0 .77 0l.303-.176.556.966-.302.176a.772.772 0 0 0-.362.676v.08a.772.772 0 0 0 .362.677l.302.21-.556.965-.302-.175a.766.766 0 0 0-.771 0 .778.778 0 0 0-.409.675v.352h-1.106v-.372a.778.778 0 0 0-.409-.676.766.766 0 0 0-.77 0l-.303.176-.556-.912.302-.176a.772.772 0 0 0 .362-.676v-.04-.04a.772.772 0 0 0-.362-.676l-.302-.176.556-.966.289.155a.766.766 0 0 0 .77 0 .778.778 0 0 0 .41-.676V9.36zm1.562 2.703c0-.271-.108-.531-.3-.722a1.001 1.001 0 0 0-.72-.292 1.01 1.01 0 0 0-.992 1.023 1.01 1.01 0 0 0 1.01 1.004 1.01 1.01 0 0 0 1.002-1.013z" /></svg><span>Support</span></a></li><li ><a
                href="https://get.oreilly.com/email-signup.html"
                class="l1 nav-icn "
                target=&quot;_blank&quot;
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.564 2.263l2.172 2.174c.17.168.264.397.264.636V11a.6.6 0 0 1-.6.6h-.6V6.2h-6V2.6a.6.6 0 0 1 .6-.6h3.527c.239 0 .468.095.637.263zM2.6 14a.6.6 0 0 1-.6-.6V6.8a.6.6 0 0 1 .6-.6h1.903a1.2 1.2 0 0 1 .849.352L6.2 7.4H11a.6.6 0 0 1 .6.6v5.4a.6.6 0 0 1-.6.6H2.6zM11 5h1.8L11 3.2V5z" /></svg><span>Newsletters</span></a></li><li ><a
                href="https://learning.oreilly.com/accounts/logout/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.613 12.63A.607.607 0 0 1 2 12.03V3.602C2 3.269 2.274 3 2.613 3h5.515v1.204H3.226v7.223h4.902v1.203H2.613zM5.677 9.02V6.611h4.903V4.926a.301.301 0 0 1 .19-.274.31.31 0 0 1 .33.063l2.722 2.673a.594.594 0 0 1 0 .849L11.1 10.909a.31.31 0 0 1-.331.063.301.301 0 0 1-.19-.274V9.02H5.677z" /></svg><span>Sign Out</span></a></li></ul></div></li></ul></nav></header>



      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="ch17.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Beginning Lua Programming
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="ch17.html#" title="Search in archive" class="js-search-controls search-controls" onclick="window.Appcues.track('SearchBook_HeronBook')"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9780470069172/chapter/ch17.html"><div class="js-collections-dropdown collections-dropdown menu-bit-cards" onclick="window.Appcues.track('AddPlaylist_HeronBook')"></div></div></li><li class="js-font-control-panel font-control-activator"><a href="ch17.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size" onclick="window.Appcues.track('ChangeFont_HeronBook')"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="ch17.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share" onclick="window.Appcues.track('Share_HeronBook')"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a
        class="twitter share-button t-twitter"
        target="_blank"
        aria-label="Share this section on Twitter"
        title="Share this section on Twitter"
      
        href="https://twitter.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch17.html&text=Beginning%20Lua%20Programming&via=OReillyMedia"
      ><span>Twitter</span></a></li><li><a
        class="facebook share-button t-facebook"
        target="_blank"
        aria-label="Share this section on Facebook"
        title="Share this section on Facebook"
        href="https://www.facebook.com/sharer/sharer.php?u=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch17.html"
      ><span>Facebook</span></a></li><li><a
        class="googleplus share-button t-googleplus"
        target="_blank"
        aria-label="Share this secton on Google Plus"
        title="Share this secton on Google Plus"
        href="https://plus.google.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch17.html"
      ><span>Google Plus</span></a></li><li><a
        class="email share-button t-email"
        aria-label="Share this section via email"
        title="Share this section via email"
      
        href="mailto:?subject=Safari: 17.%20Programming%20Games%20with%20Lua&body=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch17.html%0D%0Afrom Beginning%20Lua%20Programming%0D%0A"
      ><span>Email</span></a></li></ul></li><!-- endif request.user.is_authenticated -->
      </ul>
    </div>

      
          
      

    <section role="document">
        
        




  <script defer src="https://learning.oreilly.com/static/js/build/djangoMessagesPage.bfaca9fd8619.js"></script>


        <script src="https://fast.appcues.com/48743.js"></script>
<script>
  var userId = "ce47de5b-ce80-49f0-b5cd-c60d3d33b198";

  var userObject = {
    firstName: "Michael",
    segment: "Trial",
    admin: "False",
    profileCreatedOn: "2021-05-13",
    academic: ""
  };
  window.Appcues.identify(userId, userObject);
  window.Appcues.page();

  setTimeout(function () {
    window.Appcues.track('ViewingBook_HeronBook')
  }, 20000);
</script>


	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="ch16.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">16. Connecting to a Larger World</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="ch18.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">18. Carrying Lua with You</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="programming_games_with_lua"></a>Chapter 17. Programming Games with Lua</h1></div></div></div><p>Although Lua was not designed for video game programming in particular, it is quite popular with game programmers—in fact, they were the first programming subculture in which Lua became a household word.<a id="IDX-CHP-17-0001" class="indexterm"></a><a id="IDX-CHP-17-0002" class="indexterm"></a><a id="IDX-CHP-17-0003" class="indexterm"></a></p><p>This chapter is only a short introduction to a large topic. It talks about why and when you would want to use Lua in a game, but most of it is occupied with an example: a simple 2-D action game. In this chapter you learn how to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Program with the SDL library</p></li><li class="listitem"><p>Define sprites</p></li><li class="listitem"><p>Make the sprites move, either automatically or in response to user input</p></li><li class="listitem"><p>Detect collisions between sprites</p></li></ul></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="understanding_why_and_when_to_use_lua"></a>Understanding Why and When to Use Lua</h1></div></div></div><p>It is possible to write games entirely in Lua, but generally there's a division of labor between Lua and at least one other language. This is for two reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There are some things (graphics, sound, and interaction with non-character-oriented hardware) that Lua simply cannot do on its own.</p></li><li class="listitem"><p>As languages of its type go, Lua is very fast, but some games, because of their real-time nature, have speed demands that can only be satisfied by less flexible languages like C and C++.</p></li></ul></div><p>In parts of a game (or any program, really) where either of those reasons apply, you should use another language. In parts where they don't apply, you can use Lua and benefit from its strong points (that generally aren't shared by languages that beat it in the preceding two departments). The benefits of Lua include the following:<a id="IDX-CHP-17-0004" class="indexterm"></a><a id="IDX-CHP-17-0005" class="indexterm"></a><a id="IDX-CHP-17-0006" class="indexterm"></a><a id="IDX-CHP-17-0007" class="indexterm"></a><a id="IDX-CHP-17-0008" class="indexterm"></a><a id="IDX-CHP-17-0009" class="indexterm"></a><a id="IDX-CHP-17-0010" class="indexterm"></a><a id="IDX-CHP-17-0011" class="indexterm"></a><a id="IDX-CHP-17-0012" class="indexterm"></a><a id="IDX-CHP-17-0013" class="indexterm"></a><a id="IDX-CHP-17-0014" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Lightweight compilation</strong></span>: In Lua, there's a very short distance between changing a program and seeing the effects of the change. (By loading Lua code at run time, you can even make changes without restarting the program.)</p></li><li class="listitem"><p><span class="strong"><strong>High-level nature</strong></span>: Lua includes as basic features things like tables, closures, and coroutines. These allow programs to be written at a higher level of abstraction.</p></li><li class="listitem"><p><span class="strong"><strong>Ease of learning</strong></span>: Lua has a simple syntax and type system. It doesn't have a lot of rules that are there just to make things easier for the computer.</p></li></ul></div><p>This division of labor means that things like graphics are generally written in some lower-level language, and things like game logic, AI for computer-controlled characters, level definitions, and saved-game files can be written in Lua, possibly by different team members than those working in the other language.</p><p>You can also use Lua for prototyping. Write as much of the game as possible in Lua, and then translate anything that's too slow (and can't be sufficiently optimized within Lua) to a lower-level language.</p><p>The rest of this chapter demonstrates a simple graphical game. So simple, in fact, that it barely deserves to be called a game (there is no scoring or way to win, and the gameplay gets old fast), but this simplicity is intentional—it allows you to examine some basic concepts in more detail than would be possible with a more amusing game.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="simple_2-d_action_game_using_sdl"></a>Simple 2-D Action Game Using SDL</h1></div></div></div><p>The example game will be entirely in Lua, except for the low-level graphics, which will use the Simple DirectMedia Layer (SDL) library. SDL is a cross-platform library that lets you do graphics, audio, joystick access, and other things that are useful in games. It is licensed under the GNU Lesser General Public License. More information, including documentation, is available at <code class="systemitem">www.libsdl.org</code>.<a id="IDX-CHP-17-0015" class="indexterm"></a></p><p>SDL is written in C, but you will be using a Lua binding to it in this chapter. Specifically, you'll be using the binding that comes with LuaCheia. LuaCheia (Portuguese for full moon) is a distribution of Lua that includes a bunch of add-on libraries, including SDL. (LuaCheia's SDL binding was done by Asko Kauppi, and an updated version is included in his Lua distribution LuaX, available at <code class="literal">luaforge.net</code>.)</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>LuaCheia uses Lua 5.0 rather than Lua 5.1, which is why <code class="literal">math.mod</code> is used instead of the <code class="literal">%</code> operator in the following examples.</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="installing_sdl_and_luacheia"></a>Installing SDL and LuaCheia</h2></div></div></div><p>For the SDL examples to work, you need to install LuaCheia. If you are using Windows, then your job is easy, because there's a Windows installer that installs everything you need.</p><p>On either platform, first follow these steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Go to LuaCheia's SourceForge.net page (<code class="literal">sourceforge.net/projects/luacheia/</code>). Click the Download LuaCheia link, select the file <code class="literal">luacheia5-win32-5.0.1a5.exe</code> (you may need to scroll down to see it), select a mirror site near you, save the file, and run it. This will install LuaCheia in the directory <code class="literal">C:\Program Files\luacheia</code> (or somewhere else if your Program Files directory is somewhere else).</p></li><li class="listitem"><p>In the following examples, you access LuaCheia typing <span class="strong"><strong>luacheia5</strong></span> at the shell. For this to work, add <code class="literal">C:\Program Files\luacheia</code> to your search path (as described in <a class="link" href="ch01.html" title="Chapter 1. Getting Situated">Chapter 1</a>). Alternatively, you can run LuaCheia by typing the following:</p><pre class="programlisting">"C:\Program Files\luacheia\luacheia5"</pre></li></ol></div><div class="blockquote"><blockquote class="blockquote"><p>Notice that you use quotes instead of just <code class="literal">luacheia5</code>.</p></blockquote></div><p>If you are using a Windows system, you're done. If however, you're using a Unix-like operating system, then you have a bit more work ahead of you. Before installing anything, make sure that you have the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">gcc</code> or another C compiler</p></li><li class="listitem"><p>C++ compiler, such as <code class="literal">g++</code> or <code class="literal">c++</code> (because the LuaCheia SDL binding is actually done in C++)</p><div class="blockquote"><blockquote class="blockquote"><p>This compiler may be <code class="literal">gcc</code> too, but <code class="literal">gcc</code> can be installed in a way that doesn't include its C++ components.</p></blockquote></div></li><li class="listitem"><p>The X Window System, including its header files (usually located at <code class="literal">/usr/include/X11/)</code></p></li></ul></div><div class="blockquote"><blockquote class="blockquote"><p>You may be able to get the following examples to work without the X Window System, using the framebuffer on Linux or native graphics on Mac OS X, but that's not covered here.</p></blockquote></div><p>Follow these steps to install SDL:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Go to the SDL 1.2 section of <code class="literal">www.libsdl.org</code> (listed under the Download header) and download the file <code class="literal">SDL-1.2.11.tar.gz</code> to <code class="literal">/usr/local/src/</code> or somewhere in your home directory. (If a more recent version is available, it will probably work too.)</p></li><li class="listitem"><p>Unpack the file and use <code class="literal">cd</code> to change to the directory that unpacking the file creates, as follows:</p><pre class="programlisting">tar xzvf SDL-1.2.11.tar.gz
cd SDL-1.2.11</pre><p>You can remove the <code class="literal">.tar.gz</code> file after it's unpacked.</p></li><li class="listitem"><p>Build the SDL makefiles as follows:</p><pre class="programlisting">./configure</pre><p>This will print a lot of data. Somewhere in the middle, you should see something like <code class="literal">checking for X... libraries /usr/X11R6/lib, headers</code>. If you instead see <code class="literal">checking for X... no</code>, then the X Window System (or its header files) could not be found.</p></li><li class="listitem"><p>Compile SDL as follows:</p><pre class="programlisting">make</pre></li><li class="listitem"><p>As root, install SDL like this:</p><pre class="programlisting">make install</pre></li></ol></div><p>Now follow these steps to compile and install LuaCheia:<a id="IDX-CHP-17-0016" class="indexterm"></a></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Go to LuaCheia's SourceForge.net page (<code class="literal">sourceforge.net/projects/luacheia/</code>). Click the Download LuaCheia link, select the file <code class="literal">luacheia5-5.0.1a5.tar.gz</code>, select a mirror site near you, and save the file to <code class="literal">/usr/local/src/</code> or somewhere in your home directory.</p></li><li class="listitem"><p>Unpack the file and use <code class="literal">cd</code> to change to the directory that unpacking the file creates, as follows:</p><pre class="programlisting">tar xzvf luacheia5-5.0.1a5.tar.gz
cd luacheia5-5.0.1a5</pre><p>You can remove the <code class="literal">.tar.gz</code> file after it's unpacked.</p></li><li class="listitem"><p>Build LuaCheia's makefiles as follows:</p><pre class="programlisting">./configure</pre><p>This will print a lot of data, including something like this in the middle:</p><pre class="programlisting">checking for sdl-config... /usr/local/bin/sdl-config
checking for SDL - version &gt;= 1.2.5... yes</pre></li><li class="listitem"><p>Compile LuaCheia as follows:</p><pre class="programlisting">make</pre></li><li class="listitem"><p>As root, install LuaCheia like this:</p><pre class="programlisting">make install</pre></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="using_sdl"></a>Using SDL</h2></div></div></div><p>Now that you have LuaCheia installed, it's time to use its binding to SDL in an example program. To make things a little more digestible, two versions of the example program will be given.</p><div class="sidebar"><a id="try_it_out_colon_writing_your_first_sdl"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Writing Your First SDL Program</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Save the following as <code class="literal">movearound.lua</code>:</p><pre class="programlisting">-- Simple SDL graphics demo. Usage: luacheia5 test.lua

assert(cheia.load("SDL"))
assert(cheia.load("bit"))

-- Returns a "screen" (a canvas within a window upon which the
-- sprites will be drawn):
local function MakeScreen()
  local ErrStr
  local Screen = SDL.SDL_SetVideoMode(640, 480, 8,
    bit.bor(SDL.SDL_SWSURFACE, SDL.SDL_ANYFORMAT))
  if not Screen then
    ErrStr = debug.traceback(SDL.SDL_GetError())
  end
  return Screen, ErrStr
end

-- Returns a sprite object; ImgName is the filename of a .bmp file:</pre><pre class="programlisting">local function MakeSprite(Screen, ImgName)
   local Sprite, ErrStr
   local Img = SDL.SDL_LoadBMP(ImgName)
   if Img then
     local Background = SDL.SDL_MapRGB(Screen.format, 0, 0, 0)
     -- Current X and Y positions:
     local CurX, CurY = 0, 0
     -- Tables to be (re)used as rectangle arguments to
     -- SDL_FillRect and SDL_BlitSurface:
     local FillRect = {x = 0, y = 0, w = Img.w, h = Img.h}
     local BlitRect = {x = 0, y = 0, w = Img.w, h = Img.h}
     -- The sprite object:
     Sprite = {}

     -- Moves the sprite; X and Y default to the current position if
     -- they are nil:
     function Sprite:Move(X, Y)
       local Succ, ErrStr
       X, Y = math.floor(X or CurX), math.floor(Y or CurY)
       -- Erase the sprite at its current position:
       FillRect.x, FillRect.y = CurX, CurY
       if SDL.SDL_FillRect(Screen, FillRect, Background) == 0 then
         -- Write it to its new position:
         BlitRect.x, BlitRect.y = X, Y
         if SDL.SDL_BlitSurface(Img, nil, Screen, BlitRect) == 0 then
           CurX, CurY = X, Y
           Succ = true
          else
            Succ, ErrStr = false, debug.traceback(SDL.SDL_GetError())
          end
        else
          Succ, ErrStr = false, debug.traceback(SDL.SDL_GetError())
        end
        return Succ, ErrStr
       end

       -- Give the sprite its initial position:
       local Succ
       Succ, ErrStr = Sprite:Move()
       if not Succ then
         Sprite = nil
       end
     else
       ErrStr = debug.traceback(SDL.SDL_GetError())
     end
     return Sprite, ErrStr
   end

   -- Returns a function that gets pending events (all it returns in
   -- this version is whether to quit):
   local function MakeGetEvents()
   -- An SDL_Event structure -- this is how SDL.SDL_PollEvent returns
   -- any event it finds in the event queue:
   local Event = SDL.SDL_Event_new()

   -- Returns whether to quit:
   return function()</pre><pre class="programlisting">local Quit = false
   -- Consume pending events:
   while not Quit and SDL.SDL_PollEvent(Event) == 1 do
      -- Was the window closed?
      if Event.type == SDL.SDL_QUIT then
       Quit = true -- Break the loop.
     -- Was "q" pressed?
     elseif Event.type == SDL.SDL_KEYDOWN
       and Event.key.keysym.sym == SDL.SDLK_q
     then
       Quit = true -- Break the loop.
     end
   end
   return Quit
  end
end

local function MainLoop(Screen, UserSprite)
  local Succ, ErrStr = true
  -- Put the sprite 32 pixels from the left side, and 0 pixels
  -- from the top, of the screen (window):
  Succ, ErrStr = UserSprite:Move(32, 0)
  if Succ then
   -- Update the entire screen:
   SDL.SDL_UpdateRect(Screen, 0, 0, 0, 0)
   local GetEvents = MakeGetEvents()
   -- GetEvents returns true if the user quits; loop until that
   -- happens:
   while not GetEvents() do end
  end
  return Succ, ErrStr
end

local function Main()
  local ErrStr
  local InitRes = SDL.SDL_Init(SDL.SDL_INIT_VIDEO)
  if InitRes == 0 then
    local Screen
    Screen, ErrStr = MakeScreen()
    if Screen then
    -- The window title is somewhat misleading in this initial
    -- version:
    SDL.SDL_WM_SetCaption("Move Around", "Move Around");
    SDL.SDL_EnableKeyRepeat(SDL.SDL_DEFAULT_REPEAT_DELAY,
      SDL.SDL_DEFAULT_REPEAT_INTERVAL)
    -- Create a sprite (eventually to be controlled by the user):
    local UserSprite
    UserSprite, ErrStr = MakeSprite(Screen, "goodie.bmp")
    if UserSprite then
    io.write("In the new window, press 'q' (or close the",
      " window) to quit.\n")
    io.flush()
    local _
    _, ErrStr = MainLoop(Screen, UserSprite)
   end
 end
 SDL.SDL_Quit()
   else
      ErrStr = debug.traceback(SDL.SDL_GetError())
    end
    return not ErrStr, ErrStr
  end

  local Succ, ErrStr = Main()
  if not Succ then
    io.stderr:write(ErrStr, "\n")
  end</pre></li><li class="listitem"><p>Use a drawing program (such as Microsoft Paint or The Gimp) to draw a picture roughly 32 pixels wide by 32 pixels tall, and save it in Windows bitmap format as <code class="literal">goodie.bmp</code>.</p></li><li class="listitem"><p>On Unix-like systems, start the X Window System if it's not already running.</p></li><li class="listitem"><p>Run <code class="literal">movearound.lua</code> as follows:</p><pre class="programlisting">luacheia5 movearound.lua</pre><p>As mentioned previously, if you're on Windows and you didn't add the LuaCheia directory to your search path, you'll need to type something like this instead:</p><pre class="programlisting">"C:\Program Files\luacheia\luacheia5" movearound.lua</pre><p>A new window will appear that looks like <a class="link" href="ch17.html#figure_17-1" title="Figure 17.1. Figure 17-1">Figure 17-1</a>. (For this example, the Lua logo was used to create <code class="literal">goodie.bmp</code>.)</p></li><li class="listitem"><p>Close the window with the mouse or by pressing q.</p><div class="figure"><a id="figure_17-1"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/1701.png" width="549" alt="Figure 17-1" height="429"></div></div><p class="title"><strong>Figure 17.1. Figure 17-1</strong></p></div></li></ol></div><p><span class="strong"><strong>How It Works</strong></span><a id="IDX-CHP-17-0017" class="indexterm"></a></p><p>This is a preliminary version of this example. Despite the name, nothing actually moves around yet.</p><p><code class="literal">assert(cheia.load("SDL"))</code> loads the SDL library, creating a global table called <code class="literal">SDL</code>. This table contains the SDL library's functions and constants. <code class="literal">SDL.SDL_Init</code> is the Lua version of the C function <code class="literal">SDL_Init, SDL.SDL_INIT_VIDEO</code> is the Lua version of the C constant <code class="literal">SDL_INIT_VIDEO</code>, and so on. Before any of SDL's other functions can be used, <code class="literal">SDL.SDL_Init</code> is called as follows:</p><pre class="programlisting">local function Main()
  local ErrStr
  local InitRes = SDL.SDL_Init(SDL.SDL_INIT_VIDEO)</pre><p>The <code class="literal">SDL.SDL_INIT_VIDEO</code> argument tells SDL that you want to initialize the video (graphics) subsystem. (SDL also can do things with sound, joysticks, CD-ROMs, and more.) As documented on the SDL website, the <code class="literal">SDL_Init</code> C function returns <code class="literal">0</code> if it succeeds and <code class="literal">−1</code> if it fails. From a Lua standpoint, it would be more idiomatic to return <code class="literal">true</code> on success and <code class="literal">false</code> on failure, but this binding is a relatively thin one that doesn't hide SDL's C-ish nature, so the check for success looks like this:</p><pre class="programlisting">if InitRes == 0 then</pre><div class="blockquote"><blockquote class="blockquote"><p>The thinness of the binding also explains why the names are so verbose. The second <code class="literal">SDL</code> in <code class="literal">SDL.SDL_Init</code> is only there because all of the C functions (and constants) start with <code class="literal">SDL_</code>.</p></blockquote></div><p>After SDL is initialized, the next step is to make a <span class="emphasis"><em>screen</em></span>—a surface that you can draw on, which appears in its own window. This is accomplished with the following:</p><pre class="programlisting">local function MakeScreen()
  local ErrStr
  local Screen = SDL.SDL_SetVideoMode(640, 480, 8,
    bit.bor(SDL.SDL_SWSURFACE, SDL.SDL_ANYFORMAT))</pre><div class="blockquote"><blockquote class="blockquote"><p>For details about the <code class="literal">SDL.SDL_SetVideoMode</code> arguments, see the SDL website. For now, just note that this and some other functions take on-off switches (flags) for various behaviors, and that when multiple flags need to be given, they're combined with a bitwise <code class="literal">or</code>. A bitwise <code class="literal">or</code> means that two (or more) numbers are treated as binary and a logical <code class="literal">or</code> is performed on the ones columns, the twos columns, the fours columns, and so on, with 1 used for <code class="literal">true</code> and 0 for <code class="literal">false</code>. The bitwise <code class="literal">or</code> here (<code class="literal">bit.bor</code>) is supplied by the LuaCheia library loaded earlier in the file with <code class="literal">cheia.load("bit")</code>. (This particular set of flags, <code class="literal">SDL.SDL_SWSURFACE</code> and <code class="literal">SDL.SDL_ANYFORMAT</code>, actually could have been handled without a bitwise operation, but other sets of flags you may use cannot.)</p></blockquote></div><p>A title is then given to the window, and key repeat is enabled (so that holding down a key is like rapidly tapping it over and over).</p><p>Next, a <span class="emphasis"><em>sprite</em></span> is created. A sprite is basically a picture that can be moved around the screen as a unit. SDL has no built-in support for sprites, so they need to be implemented in terms of more basic operations. Specifically, <code class="literal">MakeSprite</code> returns a table with a <code class="literal">Move</code> method. When this method is called, the sprite's image (<code class="literal">goodie.bmp</code>) is erased from its current location on the screen and redrawn so that its upper-left corner is at the given coordinates.<a id="IDX-CHP-17-0018" class="indexterm"></a></p><div class="blockquote"><blockquote class="blockquote"><p>The first coordinate, X, gives the horizontal component of the position, with <code class="literal">0</code> being the leftmost column of pixels on the screen. The second coordinate, Y, gives the vertical component of the position, with <code class="literal">0</code> being the topmost row of pixels.<a id="IDX-CHP-17-0019" class="indexterm"></a><a id="IDX-CHP-17-0020" class="indexterm"></a><a id="IDX-CHP-17-0021" class="indexterm"></a></p></blockquote></div><p>The erasing is done with <code class="literal">SDL.SDL_FillRect</code>, whose second argument shows the position and size of the rectangle to be painted with the background color. This second argument is a <span class="emphasis"><em>rectangle</em></span>, which in SDL means a table with <code class="literal">x, y, w</code> (width), and <code class="literal">h</code> (height) fields.</p><p>The redrawing is done with <code class="literal">SDL.SDL_BlitSurface</code>. (<span class="emphasis"><em>Blitting</em></span> means copying pixels from one area of memory to another.) <code class="literal">SDL.SDL_BlitSurface</code> takes the following four arguments:<a id="IDX-CHP-17-0022" class="indexterm"></a><a id="IDX-CHP-17-0023" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The first argument is the source surface which in this example is the surface generated by reading <code class="literal">goodie.bmp</code>. (A <span class="emphasis"><em>surface</em></span> is just a chunk of memory viewed as a rectangle of pixels.)</p></li><li class="listitem"><p>The second argument is a rectangle showing what part of the source surface to copy. If this is <code class="literal">nil</code>, the whole source surface is copied.</p></li><li class="listitem"><p>The third argument is the destination surface, which in this example is the screen.</p></li><li class="listitem"><p>The fourth arument is a rectangle showing where in the destination surface to copy the source surface to (the <code class="literal">w</code> and <code class="literal">h</code> fields are ignored).</p></li></ul></div><p>After the sprite is created, it's given to <code class="literal">MainLoop</code>, which moves it to <code class="literal">32, 0</code> (an arbitrary location chosen for demonstration purposes) and then makes sure that the sprite is visible by calling <code class="literal">SDL.SDL_UpdateRect</code>. Until <code class="literal">SDL.SDL_UpdateRect</code> is called, there's no guarantee that anything done by <code class="literal">SDL.SDL_BlitSurface</code> will be visible—it may be or it may not be. <code class="literal">SDL.SDL_UpdateRect</code> is your way of saying that you're done slinging bits around the screen and are ready for what you've done to become visible.</p><p>Apart from the surface to be updated, <code class="literal">SDL.SDL_UpdateRect</code> takes four arguments: the X position, Y position, width, and height of the rectangular section of the surface that is to be updated. As a special case, if it sees that all four of these arguments are <code class="literal">0</code>, it updates the whole surface (the screen in this case).</p><p>The <code class="literal">GetEvents</code> function uses <code class="literal">SDL.SDL_PollEvent</code> to check for new events. The only events it cares about are the window being closed and the Q key being pressed—if either of these happens, it returns <code class="literal">true</code>. If some other event or events occur, or if no events have occurred since the last time <code class="literal">SDL.SDL_PollEvent</code> was called, <code class="literal">GetEvents</code> returns <code class="literal">false</code>. Waiting for the user to quit is the job of the main loop of the program (which <code class="literal">MainLoop</code> is named after). This empty-bodied loop just calls <code class="literal">GetEvents</code> over and over until it returns <code class="literal">true</code>:</p><pre class="programlisting">while not GetEvents() do end</pre><p>Finally, <code class="literal">SDL.SDL_Quit</code> is called to shut down SDL, and if an error occurred anywhere along the way, its error message is printed.</p></div><p>The next version of <code class="literal">movearound.lua</code> will still have very low entertainment value as a game, but it will at least live up to its name—you'll be able to control the movement of a sprite. Meanwhile another sprite will be moving on its own.</p><div class="sidebar"><a id="try_it_out_colon_putting_sprites_in_moti"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Putting Sprites in Motion</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Make the following changes to <code class="literal">movearound.lua</code>:</p><pre class="programlisting">-- Simple SDL graphics demo. Usage: luacheia5 test.lua

assert(cheia.load("SDL"))
assert(cheia.load("bit"))

-- Returns a "screen" (a canvas within a window upon which the
-- sprites will be drawn):
local function MakeScreen()
  local ErrStr
  local Screen = SDL.SDL_SetVideoMode(640, 480, 8,
    bit.bor(SDL.SDL_SWSURFACE, SDL.SDL_ANYFORMAT))
  if not Screen then
    ErrStr = debug.traceback(SDL.SDL_GetError())
  end
  return Screen, ErrStr
end

-- Returns N, or (if N is lower than Min), a number as much above Min
-- as N is below it, or (if N is higher than Max), a number as much
-- below Max as N is above it; also returns a second value telling
-- whether had to return a number other than N:
local function ComputeBounce(N, Min, Max)
  local Fix = false
  if N &gt; Max then
    N = Max - (N - Max)
    Fix = true
  elseif N &lt; Min then
    N = Min + (Min - N)
    Fix = true
  end
 return N, Fix
end

-- Returns N, or Min if N is lower than Min, or Max, if N is higher
-- than Max:
local function Between(N, Min, Max)
  return N &gt; Max and Max or N &lt; Min and Min or N
end

-- Returns 1, 0, or −1 depending on whether N is positive, zero, or
-- negative:
local function Sign(N)
  if N &gt; 0 then
    N = 1
  elseif N &lt; 0 then
    N = −1
  end
  return N
end

-- Returns a sprite object; ImgName is the filename of a .bmp file:</pre><pre class="programlisting">local function MakeSprite(Screen, ImgName)
   local Sprite, ErrStr
   local Img = SDL.SDL_LoadBMP(ImgName)
   if Img then
     local Background = SDL.SDL_MapRGB(Screen.format, 0, 0, 0)
     -- Current X and Y positions:
     local CurX, CurY = 0, 0
     -- Current velocities along the X and Y axes, in pixels per tick
     -- (minimum −1, maximum 1):
     local VelX, VelY = 0, 0
     -- Velocity increment (the smallest unit by which velocity along
     -- a given axis changes):
     local VelInc = 1 / 32
     -- Tables to be (re)used as rectangle arguments to
     -- SDL_FillRect and SDL_BlitSurface:
     local FillRect = {x = 0, y = 0, w = Img.w, h = Img.h}
     local BlitRect = {x = 0, y = 0, w = Img.w, h = Img.h}
     -- The sprite object:
     Sprite = {}

     -- Moves the sprite; X and Y default to the current position if
     -- they are nil:
     function Sprite:Move(X, Y)
       local Succ, ErrStr
       X, Y = math.floor(X or CurX), math.floor(Y or CurY)
       -- Erase the sprite at its current position:
       FillRect.x, FillRect.y = CurX, CurY
       if SDL.SDL_FillRect(Screen, FillRect, Background) == 0 then
         -- Write it to its new position:
         BlitRect.x, BlitRect.y = X, Y
         if SDL.SDL_BlitSurface(Img, nil, Screen, BlitRect) == 0 then
           CurX, CurY = X, Y
           Succ = true
         else
           Succ, ErrStr = false, debug.traceback(SDL.SDL_GetError())
         end
       else
         Succ, ErrStr = false, debug.traceback(SDL.SDL_GetError())
       end
       return Succ, ErrStr
     end

   -- Call this once for every tick:
   function Sprite:Tick(Ticks)
     local Succ, ErrStr = true
     local NewX
     if VelX ~= 0 and math.mod(Ticks, 1 / VelX) &lt; 1 then
       NewX = CurX + Sign(VelX)
       -- Make sure it doesn't go off the edges:
       local Fix
       NewX, Fix = ComputeBounce(NewX, 0,
         self:ScreenWidth() - self:Width())
       if Fix then VelX = -VelX end
     end
     local NewY</pre><pre class="programlisting">if VelY ~= 0 and math.mod(Ticks, 1 / VelY) &lt; 1 then
       NewY = CurY + Sign(VelY)
       -- Make sure it doesn't go off the edges:
       local Fix
       NewY, Fix = ComputeBounce(NewY, 0,
         self:ScreenHeight() - self:Height())
       if Fix then VelY = -VelY end
     end
     if NewX or NewY then
       Succ, ErrStr = self:Move(NewX, NewY)
     end
     return Succ, ErrStr
   end

 -- Accelerates the sprite along the X axis (negative values of
 -- Accel accelerate to the left):
 function Sprite:AccelX(Accel)
   if Accel ~= 0 then
     VelX = Between(VelX + Accel * VelInc, −1, 1)
   end
 end

 -- Accelerates the sprite along the Y axis (negative values of
 -- Accel accelerate upward):
 function Sprite:AccelY(Accel)
  if Accel ~= 0 then
    VelY = Between(VelY + Accel * VelInc, −1, 1)
  end
 end

 -- Stops the sprite cold:
 function Sprite:Stop()
   VelX, VelY = 0, 0
 end

 -- More methods:
 function Sprite:X() return CurX end
 function Sprite:Y() return CurY end
 function Sprite:Width() return Img.w end
 function Sprite:Height() return Img.h end
 function Sprite:ScreenWidth() return Screen.w end
 function Sprite:ScreenHeight() return Screen.h end

 -- Give the sprite its initial position:
 local Succ
 Succ, ErrStr = Sprite:Move()
 if not Succ then
    Sprite = nil
  end
 else
  ErrStr = debug.traceback(SDL.SDL_GetError())
 end
 return Sprite, ErrStr
end

-- Returns a function that gets pending events:</pre><pre class="programlisting">local function MakeGetEvents()
  -- An SDL_Event structure -- this is how SDL.SDL_PollEvent returns
  -- any event it finds in the event queue:
  local Event = SDL.SDL_Event_new()

 -- Returns how much to accelerate to the right, how much to
 -- accelerate downward, and whether to stop or quit:
 return function()
   local AccelX, AccelY, OtherEvent = 0, 0
   -- Consume pending events:
   while not OtherEvent and SDL.SDL_PollEvent(Event) == 1 do
     -- Was the window closed?
     if Event.type == SDL.SDL_QUIT then
       OtherEvent = "Quit" -- Break the loop.
     elseif Event.type == SDL.SDL_KEYDOWN then
       local Key = Event.key.keysym.sym
       -- Was "q" pressed?
       if Key == SDL.SDLK_q then
         OtherEvent = "Quit" -- Break the loop.
       -- If an arrow key was pressed, accelerate the sprite in that
       -- direction:
       elseif Key == SDL.SDLK_LEFT then
          AccelX = AccelX - 1
       elseif Key == SDL.SDLK_RIGHT then
          AccelX = AccelX + 1
       elseif Key == SDL.SDLK_UP then
          AccelY = AccelY - 1
       elseif Key == SDL.SDLK_DOWN then
          AccelY = AccelY + 1
       elseif Key == SDL.SDLK_SPACE then
          OtherEvent = "Stop" -- Break the loop.
       else
         -- Some other key; ignore it.
       end
     end
 end
 return AccelX, AccelY, OtherEvent
 end
end

-- Moves the user sprite and automatic sprite the appropriate
-- distance for the given amount of ticks:
local function Step(UserSprite, AutoSprite, Ticks)
  local Succ, ErrStr = true
  -- Move the sprites:
  Succ, ErrStr = UserSprite:Tick(Ticks)
  if Succ then
    Succ, ErrStr = AutoSprite:Tick(Ticks)
  end
  return Succ, ErrStr
 end

-- Are Sprite1 and Sprite2 overlapping?
local function Overlap(Sprite1, Sprite2)
  local Ret = false
  -- This views the two sprites as rectangle-shaped, even if they</pre><pre class="programlisting">-- look like other shapes.
 local DiffX = math.abs(Sprite1:X() - Sprite2:X())
 local Width = (Sprite1:Width() + Sprite2:Width()) / 2
 if DiffX &lt; Width then
   local DiffY = math.abs(Sprite1:Y() - Sprite2:Y())
   local Height = (Sprite1:Height() + Sprite2:Height()) / 2
   if DiffY &lt; Height then
     Ret = true
   end
 end
 return Ret
end

local function MainLoop(Screen, UserSprite, AutoSprite)
  local Succ, ErrStr = true
  local GetEvents = MakeGetEvents()
  -- Loop until the user quits (or an error occurs):
  local PrevTicks = SDL.SDL_GetTicks();
  local OtherEvent
  while Succ and OtherEvent ~= "Quit" do
    -- Get any and all pending events:
    local AccelX, AccelY
    AccelX, AccelY, OtherEvent = GetEvents()
    -- Update the sprite's velocity:
    UserSprite:AccelX(AccelX)
    UserSprite:AccelY(AccelY)
    -- Get the current number of elapsed ticks -- if it's the same as
    -- the previous number, keep checking until it's different:
    local Ticks = SDL.SDL_GetTicks();
    while Ticks == PrevTicks do
      Ticks = SDL.SDL_GetTicks();
    end
    -- Call Step once for each tick that has happened since
    -- PrevTicks:
    for I = PrevTicks + 1, Ticks do
      Succ, ErrStr = Step(UserSprite, AutoSprite, I)
      if not Succ then break end -- BREAK ON ERROR.
    end
    PrevTicks = Ticks
    if OtherEvent == "Stop" then
      -- Screeching halt:
      UserSprite:Stop()
    end
    -- Are the two sprites overlapping?
    if Overlap(UserSprite, AutoSprite) then
      io.write("GAME OVER (collision)\n")
      break -- EXIT THE MAIN LOOP.
    end
    -- Update the entire screen:
    SDL.SDL_UpdateRect(Screen, 0, 0, 0, 0)
  end
  return Succ, ErrStr
end

  local function Main()
  local ErrStr
  local InitRes = SDL.SDL_Init(SDL.SDL_INIT_VIDEO)
  if InitRes == 0 then
    local Screen
    Screen, ErrStr = MakeScreen()
    if Screen then
      -- Set the window title; enable key repeat:
      SDL.SDL_WM_SetCaption("Move Around", "Move Around");
      SDL.SDL_EnableKeyRepeat(SDL.SDL_DEFAULT_REPEAT_DELAY,
       SDL.SDL_DEFAULT_REPEAT_INTERVAL)
  -- Create a sprite to be controlled by the user and another to
  -- be controlled by the program:
  local UserSprite
  UserSprite, ErrStr = MakeSprite(Screen, "goodie.bmp")
  if UserSprite then
  local AutoSprite
  AutoSprite, ErrStr = MakeSprite(Screen, "baddie.bmp")
  if AutoSprite then
    -- Give them their initial positions and velocities:
    local Succ
    local ScreenWidth, ScreenHeight = Screen.w, Screen.h
    Succ, ErrStr = UserSprite:Move(
      ScreenWidth / 3 - UserSprite:Width() / 2,
      ScreenHeight / 2 - UserSprite:Height() / 2)
    if Succ then
      Succ, ErrStr = AutoSprite:Move(
        ScreenWidth * (2 / 3) - AutoSprite:Width() / 2,
        ScreenHeight / 2 - AutoSprite:Height() / 2)
     if Succ then
     -- Go in one of the four diagonal directions depending
     -- on what time it is:
     local Time = math.mod(os.time(), 4) + 1
     local A = 5 -- AutoSprite initial acceleration.
     local AccelX = ({A, A, -A, -A})[Time]
     local AccelY = ({A, -A, -A, A})[Time]
     AutoSprite:AccelX(AccelX)
     AutoSprite:AccelY(AccelY)
     io.write([[
In the new window:
- press the arrow keys to change speed
- press space to stop moving
- press 'q' (or close the window) to quit.
]])
                     io.flush()
                     Succ, ErrStr = MainLoop(Screen, UserSprite, AutoSprite)
                  end
               end
            end
          end
       end
    SDL.SDL_Quit()
 else
   ErrStr = debug.traceback(SDL.SDL_GetError())
 end
 return not ErrStr, ErrStr
end

local Succ, ErrStr = Main()
if not Succ then
  io.stderr:write(ErrStr, "\n")
end</pre></li><li class="listitem"><p>Draw another picture roughly 32 pixels wide by 32 pixels tall, and save it in Windows bitmap format as <code class="literal">baddie.bmp</code>.</p></li><li class="listitem"><p>Run <code class="literal">movearound.lua</code> as follows:</p><pre class="programlisting">luacheia5 movearound.lua</pre></li></ol></div><p>You'll see something like <a class="link" href="ch17.html#figure_17-2" title="Figure 17.2. Figure 17-2">Figure 17-2</a>. The <code class="literal">baddie.bmp</code> sprite is moving. The <code class="literal">goodie.bmp</code> sprite is standing still, and pressing an arrow key makes it move in the arrow key's direction. Pressing the key repeatedly makes it go faster and faster in that direction. Pressing the space bar makes it come to a complete stop. Both sprites bounce when they hit the edges of the screen. The program ends when <code class="literal">baddie.bmp</code> touches <code class="literal">goodie.bmp</code>.</p><div class="figure"><a id="figure_17-2"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/1702.png" width="549" alt="Figure 17-2" height="430"></div></div><p class="title"><strong>Figure 17.2. Figure 17-2</strong></p></div><p><span class="strong"><strong>How It Works</strong></span><a id="IDX-CHP-17-0024" class="indexterm"></a></p><p>This version creates two sprites: <code class="literal">UserSprite</code> (controlled by the user) and <code class="literal">AutoSprite</code> (controlled by the program). They are initially placed respectively to the left and to the right of the screen's center. Then <code class="literal">AutoSprite</code> is accelerated (given a push) in a randomly chosen diagonal direction. (The direction is chosen based on what time it is—on Unix-like systems and Windows, <code class="literal">os.time</code> returns a number of seconds from a particular date in the past.) This acceleration is done with <code class="literal">AutoSprite</code>'s <code class="literal">AccelX</code> and <code class="literal">AccelY</code> methods as follows:</p><pre class="programlisting">-- Go in one of the four diagonal directions depending
-- on what time it is:
local Time = math.mod(os.time(), 4) + 1
local A = 5 -- AutoSprite initial acceleration.
local AccelX = ({A, A, -A, -A})[Time]
local AccelY = ({A, -A, -A, A})[Time]
AutoSprite:AccelX(AccelX)
AutoSprite:AccelY(AccelY)</pre><p>The <code class="literal">AccelX</code> method adds the product of its argument and <code class="literal">VelInc</code> (1/32) to the sprite's X <span class="emphasis"><em>velocity</em></span> (<code class="literal">VelX</code>). Velocity is speed and direction. X velocity is speed along the X axis, but it's negative if the direction is to the left. So, if <code class="literal">AccelX</code> is called with an argument of <code class="literal">1</code>, then <span class="emphasis"><em>f</em></span>1/32 is added to the sprite's X velocity (which is initialized to <code class="literal">0</code>). <code class="literal">AccelX</code> makes sure, though, that the sprite's X velocity never gets lower than <code class="literal">−1</code> or higher than <code class="literal">1</code>, like this:</p><pre class="programlisting">-- Accelerates the sprite along the X axis (negative values of
-- Accel accelerate to the left):
function Sprite:AccelX(Accel)
    if Accel ~= 0 then
      VelX = Between(VelX + Accel * VelInc, −1, 1)
    end
  end</pre><p><code class="literal">AccelY</code> does the same thing for the sprite's Y velocity.</p><p><code class="literal">MainLoop</code> and the main loop it contains are now more complex. Again, the loop (still a <code class="literal">while</code> loop) is based on repeatedly calling <code class="literal">GetEvents</code>, but the new <code class="literal">GetEvents</code> returns three values. The first two are based on how many times the arrow keys were pressed since the last call to <code class="literal">GetEvents</code>. They tell how much <code class="literal">UserSprite</code> needs to be accelerated along (respectively) the X and Y axes. The third return value tells whether an event other than an arrow keypress occurred. This third value can be <code class="literal">nil</code>, or "<code class="literal">Quit"</code> (if the user pressed q or closed the window), or "<code class="literal">Stop"</code> (if the user pressed the space bar).</p><p>The main loop keeps track of how many <span class="emphasis"><em>ticks</em></span> (milliseconds in SDL) have taken place since its previous iteration. After accelerating <code class="literal">UserSprite</code> appropriately, it calls <code class="literal">Step</code> once for each elapsed tick:</p><pre class="programlisting">-- Call Step once for each tick that has happened since
-- PrevTicks:
for I = PrevTicks + 1, Ticks do
  Succ, ErrStr = Step(UserSprite, AutoSprite, I)
  if not Succ then break end -- BREAK ON ERROR.
 end
 PrevTicks = Ticks</pre><p><code class="literal">Step</code> calls each sprite's <code class="literal">Tick</code> method with the current tick as an argument.</p><div class="blockquote"><blockquote class="blockquote"><p>Actually, it may not be the current tick, but the <code class="literal">for I</code> loop lets the <code class="literal">Tick</code> method think that it's being called every time a tick occurs, even when several ticks go by in between iterations of the main loop.</p></blockquote></div><p>In this program, velocity is expressed as the number of pixels to move per tick. Both the X and Y components of velocity have a minimum of <code class="literal">−1</code> (one pixel per tick to the left or upwards) and a maximum of <code class="literal">1</code> (one pixel per tick to the right or downwards). These values are often fractional, so the <code class="literal">Tick</code> method needs to decide on every tick whether or not to move its sprite one pixel. For example, if <code class="literal">VelX</code> is <code class="literal">0.25</code>, then <code class="literal">Tick</code> needs to move the sprite one pixel to the right on <span class="emphasis"><em>every fourth tick</em></span>. It does this with modulo arithmetic (using the Lua 5.0 function <code class="literal">math.mod</code>) as follows:</p><pre class="programlisting">-- Call this once for every tick:
function Sprite:Tick(Ticks)
   local Succ, ErrStr = true
   local NewX
   if VelX ~= 0 and math.mod(Ticks, 1 / VelX) &lt; 1 then</pre><div class="blockquote"><blockquote class="blockquote"><p>"<code class="literal">&lt; 1</code> " is used instead of "<code class="literal">== 0</code>" to account for the fact that <code class="literal">1 / VelX</code> may not be an integer.</p></blockquote></div><p>After a new X (always one more or one less than the current X) has been computed, the walls(the edges of the screen) need to be accounted for. If the new X puts part of the sprite offscreen, then it (the new X) is recomputed so that the sprite is fully onscreen, as though it had bounced off the screen's edge, and the sprite's X direction is reversed:</p><pre class="programlisting">NewX = CurX + Sign(VelX)
-- Make sure it doesn't go off the edges:
local Fix
NewX, Fix = ComputeBounce(NewX, 0,
  self:ScreenWidth() - self:Width())
if Fix then VelX = -VelX end</pre><p>Notice that the sprite's width has to be taken into account, because the sprite's X position is actually the position of its left edge.</p><p>After doing the same thing for the Y velocity and position, the sprite is moved if necessary:</p><pre class="programlisting">if NewX or NewY then
  Succ, ErrStr = self:Move(NewX, NewY)
end</pre><p>After <code class="literal">Step</code> has called each sprite's <code class="literal">Tick</code> method, it returns control to <code class="literal">MainLoop</code>, which checks whether a "<code class="literal">Stop"</code> event has occurred, and responds appropriately:</p><pre class="programlisting">if OtherEvent == "Stop" then
  -- Screeching halt:
  UserSprite:Stop()
end</pre><p>Then the main loop (and after that, the whole program) is exited if <code class="literal">AutoSprite</code> and <code class="literal">UserSprite</code> have collided:</p><pre class="programlisting">-- Are the two sprites overlapping?
if Overlap(UserSprite, AutoSprite) then
  io.write("GAME OVER (collision)\n")
  break -- EXIT THE MAIN LOOP.
 end</pre><p>If the loop hasn't been exited, then the screen is updated with <code class="literal">SDL.SDL_UpdateRect</code> and control goes back to the top of the loop. (The loop's <code class="literal">while</code> expression is responsible for ending things if a <code class="literal">"Quit"</code> event occurs.)</p></div><p>There are a number of ways you could make this game more interesting. Among other things, you could add the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Some sort of goal. This could be as simple as a literal goal—an area of the screen that must be reached, possibly by navigating around fixed obstacles, to win the game. Scoring could be based on how quickly the goal is reached.</p></li><li class="listitem"><p>More computer-controlled sprites, perhaps with more complex movement patterns. These could all be kept in a table, rather than each having its own variable (as <code class="literal">AutoSprite</code> does now).</p></li><li class="listitem"><p>Animation (such as making <code class="literal">AutoSprite</code>'s eyes blink).</p></li><li class="listitem"><p>Better collision detection so that sprites are not always considered to be shaped like rectangles.</p></li><li class="listitem"><p>That old video game standby, shooting things.</p></li></ul></div><p>You could also improve the interface by making it mouse- or joystick-based, putting it entirely in one window (instead of using <code class="literal">io.write</code> for messages), and allowing the game to be restarted from the same window.</p><p>If any of these changes slowed the game down too much, you could perform optimizations right in Lua, such as minimizing function calls and runtime table creation, and updating only the parts of the screen that need to be updated. If such optimizations weren't enough, you would need to rewrite parts of the game in a lower-level language.</p><p>One of the sample programs included with LuaCheia is Meteor Shower by Thatcher Ulrich. This game bears a family resemblance to the arcade classic Asteroids—it demonstrates mouse control, creation of sprites during gameplay, and gravitational physics. On Unix-like systems, you can run it like this:</p><pre class="programlisting">cd /usr/local/src/luacheia5-5.0.1a5/examples/meteor_shower
luacheia5 meteor_shower.lua</pre><p>On Windows, it is one of the choices in the <code class="literal">luacheia</code> submenu created in the Start menu by the installer.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="summary-063"></a>Summary</h1></div></div></div><p>In this chapter, you dipped your toes into the deep water of Lua game programming, and learned about the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Lua's strong suit in game programming, which is writing the more abstract and less speed-intensive portions of a program</p></li><li class="listitem"><p>The SDL library</p></li><li class="listitem"><p>Game programming concepts such as sprites, events, and ticks</p></li><li class="listitem"><p>The basics of implementing physics concepts like velocity and collisions</p></li></ul></div><p>As a self-directed exercise, you can make the improvements to <code class="literal">movearound.lua</code> suggested in the last section at any time. But for now, here's one exercise to tackle before you move on to the next chapter (about Lua on handheld devices), here's one exercise to tackle. The answer is in the appendix.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="exercise"></a>Exercise</h1></div></div></div><p>Here's an SDL program that's not very well commented. Without running it, figure out what it does.</p><pre class="programlisting">assert(cheia.load("SDL"))

local function GetImgs()
  local Goodie, Baddie, ErrStr
  Goodie = SDL.SDL_LoadBMP("goodie.bmp")
  if Goodie then
    Baddie = SDL.SDL_LoadBMP("baddie.bmp")
    if Baddie then
      if Goodie.w ~= Baddie.w or Goodie.h ~= Baddie.h then
        Goodie = nil
        ErrStr = debug.traceback(
          "goodie.bmp and baddie.bmp must have the same shape")
       end
    end
  else
    ErrStr = debug.traceback(SDL.SDL_GetError())
  end
  return Goodie, Baddie, ErrStr
end

local function Tile(Goodie, Baddie, Screen)
   math.randomseed(os.time())
   local ErrStr
   for X = 0, 3 do
     for Y = 0, 3 do
       local Img = math.random(1, 2) == 1 and Goodie or Baddie
       if SDL.SDL_BlitSurface(Img, nil, Screen,
   {x = X * Goodie.w, y = Y * Goodie.h}) ~= 0
  then
    ErrStr = debug.traceback(SDL.SDL_GetError())
    break -- BREAK ON ERROR.
   end
  end
 end
 return not ErrStr, ErrStr
end

local function WaitForQuit()
  local Event = SDL.SDL_Event_new()
  while Event do
   local Pending = SDL.SDL_PollEvent(Event) == 1
   if Pending
     and (Event.type == SDL.SDL_QUIT
      or Event.type == SDL.SDL_KEYDOWN
      and Event.key.keysym.sym == SDL.SDLK_q)
   then
    Event = false
   end
  end
end

local ErrStr
  if SDL.SDL_Init(SDL.SDL_INIT_VIDEO) == 0 then
   local Goodie, Baddie
   Goodie, Baddie, ErrStr = GetImgs()
   if Goodie then
    local Screen = SDL.SDL_SetVideoMode(Goodie.w * 4, Goodie.w * 4, 8,
      SDL.SDL_SWSURFACE)
    if Screen then
     local TileSucc
     TileSucc, ErrStr = Tile(Goodie, Baddie, Screen)
     if TileSucc then
      SDL.SDL_UpdateRect(Screen, 0, 0, 0, 0)
      WaitForQuit()
     end
   else
     ErrStr = debug.traceback(SDL.SDL_GetError())
   end
 else
   ErrStr = debug.traceback(SDL.SDL_GetError())
 end
else
  ErrStr = debug.traceback(SDL.SDL_GetError())
end
if ErrStr then
  io.stderr:write(ErrStr, "\n")
end</pre></div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="ch16.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">16. Connecting to a Larger World</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="ch18.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">18. Carrying Lua with You</div>
        </a>
    
  
  </div>


        
    </section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag">
        
        

        
          <p>You have 6 days left in your trial, Michaelschiner. Subscribe today. <a href="https://learning.oreilly.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
        
        

      </div>

    
    



        
      </div>
      
        

<footer class="pagefoot t-pagefoot">
  <a href="ch17.html#" class="icon-up" onclick="window.Appcues.track('JumpTop_HeronBook')"><div class="visuallyhidden">Back to top</div></a>
  <ul class='js-footer-nav'>
  
    
    <li><a href="https://learning.oreilly.com/public/support/">Support</a></li>
    
    <li><a href="https://learning.oreilly.com/accounts/logout/">Sign Out</a></li>
    
  
  
  </ul>
  <span class="copyright">&#169; 2021 <a href="https://learning.oreilly.com/" target="_blank">O'Reilly Media, Inc</a>.</span>
  
    
    <a href="https://www.oreilly.com/terms/">Terms of Service</a> 
     / 
    
    <a href="https://learning.oreilly.com/privacy">Privacy Policy</a> 
    
    
  
</footer>

      
    
    <script src="https://learning.oreilly.com/jsi18n/web/" charset="utf-8"></script>
    <script src="https://learning.oreilly.com/library/jsi18n/appcache/" charset="utf-8"></script>
  </body>
</html>
