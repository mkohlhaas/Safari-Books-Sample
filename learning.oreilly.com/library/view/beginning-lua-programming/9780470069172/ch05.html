<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch05.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch05.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch05.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch05.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><!--<![endif]--><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="author" content="O'Reilly Media" /><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9780470069172"/><link rel="shortcut icon" href="https://www.oreilly.com/favicon.ico" /><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"/><meta property="twitter:account_id" content="4503599627559754" /><link rel="shortcut icon" href="https://learning.oreilly.com/favicon.ico" type="image/x-icon"><link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic' rel='stylesheet' type='text/css'><title>5. Using Strings - Beginning Lua Programming</title><link rel="stylesheet" href="https://learning.oreilly.com/static/CACHE/css/output.5bdb4fcb2aad.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://learning.oreilly.com/static/css/annotator.e3b0c44298fc.css"/><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book"></style><script> // <![CDATA[
    var g = {
      position_cache: {
        
          "chapter": "/api/v1/book/9780470069172/chapter/ch05.html",
          "book_id": "9780470069172",
          "chapter_uri": "ch05.html",
          "position": 0,
          "user_uuid": "ce47de5b-ce80-49f0-b5cd-c60d3d33b198",
          "next_chapter_uri": "/library/view/beginning-lua-programming/9780470069172/ch06.html"
        
      },
      title: "Beginning Lua Programming",
      author_list: "Aaron Brown, Kurt Jung",
      format: "book",
      source: "application/epub+zip",
      is_system_book: true,
      is_public: false,
      loaded_from_server: true,
      allow_scripts: false,
      has_mathml: false
    };
    // ]]></script><script src="https://learning.oreilly.com/static/js/src/modernizr.8e35451ddb64.js"></script><script>
    
      

      
        
          window.PUBLIC_ANNOTATIONS = true;
        
      

      window.MOBILE_PUBLIC_ANNOTATIONS = false;

    

    
      window.PRIVACY_CONTROL_OVERRIDE = false;
    

      window.PRIVACY_CONTROL_SWITCH = true;

      window.PUBLISHER_PAGES = true;

      window.SBO = {
        "constants": {
          "SITB_ENDPOINT": "/api/v2/sitb/",
          "SEARCH_SELECT_ENDPOINT": "https://learning.oreilly.com/api/v2/search/select/",
        }
      };
  </script><link rel="canonical" href="ch05.html"/><meta name="description" content="Chapter 5. Using Strings The last chapter covered tables and the table library. You already know strings, but you don&#39;t know the string library, and that&#39;s the main topic of ... "><meta property="og:title" content="5. Using Strings" /><meta itemprop="isPartOf" content="/library/view/beginning-lua-programming/9780470069172/" /><meta itemprop="name" content="5. Using Strings" /><meta property="og:url" itemprop="url" content="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch05.html" /><meta property="og:site_name" content="Safari" /><meta property="og:image" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9780470069172/" /><meta property="og:description" itemprop="description" content="Chapter 5. Using Strings The last chapter covered tables and the table library. You already know strings, but you don&#39;t know the string library, and that&#39;s the main topic of ... "><meta itemprop="inLanguage" content="en" /><meta itemprop="publisher" content="Wrox" /><meta property="og:type" content="book" /><meta property="og:book:isbn" itemprop="isbn" content="9780470069172" /><meta property="og:book:author" itemprop="author" content="Aaron Brown" /><meta property="og:book:author" itemprop="author" content="Kurt Jung" /><meta property="og:book:tag" itemprop="about" content="Core Programming" /><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@OReillyMedia"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><noscript><meta http-equiv="refresh" content="0; URL=https://learning.oreilly.com/library/no-js/" /></noscript><script>
    var dataLayer = window.dataLayer || [];

    
      window.medalliaVsgUserIdentifier = 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198';
      dataLayer.push({userIdentifier: 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198'});
      dataLayer.push({loggedIn: 'yes'});

      
        window.medalliaVsgAccountIdentifier = '29964b7b-68d8-4532-9a9b-32e089689c1f';
        

        window.medalliaVsgIsIndividual = true;
        
          
          dataLayer.push({learningAccountType: 'free trial'});
          
        

        
      
    

    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5P4V6Z');
    (function () {
      var VERSION = 'V1.1';
      var AUTHOR = 'Awwad';
      if (!window.GtmHelper)
        window.GtmHelper = function () {
          var instance = this;
          var loc = document.location;
          this.version = VERSION;
          this.author = AUTHOR;
          this.readCookie = function (name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
              var c = ca[i];
              while (c.charAt(0) == ' ') c = c.substring(1, c.length);
              if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
          };
          this.createCookie = function (name, value, days, cookieDomain) {
            var domain = "";
            var expires = "";

            if (days) {
              var date = new Date();
              date.setTime(date.getTime() + Math.ceil(days * 24 * 60 * 60 * 1000));
              var expires = " expires=" + date.toGMTString() + ";";
            }

            if (typeof (cookieDomain) != 'undefined')
              domain = " domain=" + cookieDomain + "; ";

            document.cookie = name + "=" + value + ";" + expires + domain + "path=/";
          };

          this.isDuplicated = function (currentTransactionId) {
            // the previous transaction id:
            var previousTransIdValue = this.readCookie("previousTransId");

            if (currentTransactionId === previousTransIdValue) {
              return true; // Duplication
            } else {
              return false;
            }
          };
        }
    })()
  </script><script defer src="https://learning.oreilly.com/static/js/build/vendor.0eac897f11ed.js"></script><script defer src="https://learning.oreilly.com/static/js/build/reader.c745ea9296ac.js"></script></head>


<body class="reading sidenav nav-collapsed  scalefonts">

    
  <noscript> 
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
            height="0" width="0"
            style="display:none;visibility:hidden">
    </iframe>
  </noscript>



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        

  


<a href="ch05.html#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li><a href="https://learning.oreilly.com/home/" class="l0 nav-icn"><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.738 14H9.254v-3.676a.617.617 0 0 0-.621-.613H7.39a.617.617 0 0 0-.62.613V14H4.284a.617.617 0 0 1-.622-.613V10.22c0-.327.132-.64.367-.87l3.547-3.493a.627.627 0 0 1 .875 0l3.54 3.499c.234.229.366.54.367.864v3.167a.617.617 0 0 1-.62.613zM7.57 2.181a.625.625 0 0 1 .882 0l5.77 5.692-.93.92-5.28-5.209-5.28 5.208-.932-.919 5.77-5.692z" /></svg><span>Home</span></a></li><li class="search"><a href="ch05.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"/></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="ch05.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"/></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li class="flyout-parent"><a
                href="ch05.html#"
                class="l1 nav-icn "
                
              ><?xml version="1.0" encoding="UTF-8"?><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M8,8 C6.34321755,8 5.00013,6.65691245 5.00013,5.00013 C5.00013,3.34334755 6.34321755,2.00026001 8,2.00026001 C9.65678245,2.00026001 10.99987,3.34334755 10.99987,5.00013 C10.99987,6.65691245 9.65678245,8 8,8 Z M2.33024571,11.3523547 L2.33774538,11.3523547 C3.7622187,9.70968996 5.82947484,8.76608166 8.00374984,8.76608166 C10.1780248,8.76608166 12.245281,9.70968996 13.6697543,11.3523547 C13.8892083,11.6177474 14.0062813,11.9530021 13.99974,12.2973138 L13.99974,13.99974 L2.00026001,13.99974 L2.00026001,12.2973138 C1.99371867,11.9530021 2.11079172,11.6177474 2.33024571,11.3523547 Z" id="path-1"></path></svg><span>Your O&#39;Reilly</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/profile/"
                    class="l2 nav-icn"
                    
                  ><span>Profile</span></a></li><li><a
                    href="https://learning.oreilly.com/history/"
                    class="l2 nav-icn"
                    
                  ><span>History</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/"
                    class="l2 nav-icn"
                    
                  ><span>Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/u/ce47de5b-ce80-49f0-b5cd-c60d3d33b198/"
                    class="l2 nav-icn"
                    
                  ><span>Highlights</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/answers/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M2.31032699,3.75609006 C4.65421571,1.41371359 8.45302454,1.41472092 10.7955702,3.75860838 C13.1381158,6.10249583 13.1369405,9.90130261 10.7930518,12.243847 C8.44916311,14.5863913 4.65018639,14.5852161 2.30780867,12.2413286 C-0.0346204845,9.89749489 -0.0334929936,6.09853298 2.31032699,3.75609006 Z M8.8198605,4.98016308 C7.34193969,3.86924672 5.23410194,3.98609692 3.88914868,5.33104946 C3.12814393,6.09032122 2.72818176,7.13880077 2.79015179,8.21201133 C2.79115912,8.23064692 2.79233434,8.24928252 2.79350956,8.26791811 L2.79350956,8.26791811 C2.83179539,8.8307976 2.9944077,9.37404287 3.26947292,9.86201677 L3.26947292,9.86201677 L2.77621706,11.7027432 C2.7699968,11.7259241 2.77662063,11.7506624 2.79359185,11.7676337 C2.8105631,11.7846049 2.83530144,11.7912287 2.85848233,11.7850085 L2.85848233,11.7850085 L4.69400524,11.2922565 C5.26306363,11.6167344 5.90703177,11.786885 6.56209849,11.7858479 C8.64827865,11.7858479 10.3395879,10.094542 10.3395879,8.00836292 C10.3405204,6.84135608 9.80105674,5.73967784 8.87862141,5.02482134 L8.87862141,5.02482134 L8.82825492,4.98654283 Z M13.7933062,2 C14.7073496,2.00009863 15.4482759,2.74110484 15.4482759,3.65514822 C15.4482759,4.32460943 15.0449926,4.92814782 14.4264842,5.18432286 C13.8079757,5.44049789 13.096053,5.29885769 12.6226979,4.82545158 C12.1493429,4.35204547 12.0077795,3.64010743 12.2640213,3.02162665 C12.5202631,2.40314587 13.123845,1.99992776 13.7933062,2 Z"/></svg><span>Answers</span></a></li><li class="flyout-parent"><a
                href="ch05.html#"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z"/></g></svg><span>Explore</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/topics/"
                    class="l2 nav-icn"
                    
                  ><span>All Topics</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;formats=case%20study&amp;formats=learning%20path&amp;formats=live%20online%20training&amp;formats=notebook&amp;formats=oriole&amp;formats=video&amp;sort=popularity&amp;facet_json=true&amp;page=0&amp;collection_type=expert"
                    class="l2 nav-icn"
                    
                  ><span>Most Popular Titles</span></a></li><li><a
                    href="https://learning.oreilly.com/recommendations/"
                    class="l2 nav-icn"
                    
                  ><span>Recommended</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;sort=publication_date&amp;facet_json=true&amp;page=0"
                    class="l2 nav-icn"
                    
                  ><span>Early Releases</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/discover/"
                    class="l2 nav-icn"
                    
                  ><span>Shared Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/resource-centers/"
                    class="l2 nav-icn"
                    
                  ><span>Resource Centers</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch05.html#"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M12.8 3.2A1.2 1.2 0 0 1 14 4.4v8.4a1.2 1.2 0 0 1-1.2 1.2H3.2A1.2 1.2 0 0 1 2 12.8V4.4a1.2 1.2 0 0 1 1.2-1.2h1.2V2h1.2v1.2h4.8V2h1.2v1.2h1.2zm-9.6 9.6h9.6V6.2H3.2v6.6zM8 9.5a1.35 1.35 0 1 1 0-2.7 1.35 1.35 0 0 1 0 2.7zm2.7 2.148v.552H5.3v-.552c0-.321.124-.634.355-.858a3.358 3.358 0 0 1 4.69 0c.23.224.355.537.355.858z" /></svg><span>Live Events</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/attend/"
                    class="l2 nav-icn"
                    
                  ><span>All Events</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/architectural-katas/"
                    class="l2 nav-icn"
                    
                  ><span>Architectural Katas</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/ai/"
                    class="l2 nav-icn"
                    
                  ><span>AI &amp; ML</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/strata/"
                    class="l2 nav-icn"
                    
                  ><span>Data Sci &amp; Eng</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/oscon/"
                    class="l2 nav-icn"
                    
                  ><span>Programming</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/infrastructure-ops/"
                    class="l2 nav-icn"
                    
                  ><span>Infra &amp; Ops</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/software-architecture/"
                    class="l2 nav-icn"
                    
                  ><span>Software Arch</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch05.html#"
                class="l1 nav-icn "
                
              ><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.6467109,4.35328907 L14.7964612,7.51003884 C15.0678463,7.78304342 15.0678463,8.22395603 14.7964612,8.49696061 L11.6467109,11.6467109 L10.6597892,10.6597892 L13.3055794,8 L10.6597892,5.34021084 L11.6467109,4.35328907 Z M4.35328907,11.6467109 L1.20353875,8.48996116 C0.932153749,8.21695658 0.932153749,7.77604397 1.20353875,7.50303939 L4.35328907,4.35328907 L5.34021084,5.34021084 L2.69442057,8 L5.34021084,10.6597892 L4.35328907,11.6467109 Z M5.84417089,11.4997226 L8.67194674,4.50027742 L10.1838269,4.50027742 L7.35605105,11.4997226 L5.84417089,11.4997226 Z" id="Mask"></path></svg><span>Interactive</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=content-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Scenarios</span></a></li><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=sandbox-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Sandboxes</span></a></li><li><a
                    href="https://learning.oreilly.com/interactive/?classification=jupyter-notebook"
                    class="l2 nav-icn"
                    
                  ><span>Jupyter Notebooks</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/certifications/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M12.912 9.18L14 8.014l-1.088-1.18a.304.304 0 01-.075-.268L13.195 5l-1.535-.463a.313.313 0 01-.194-.194l-.462-1.537-1.565.358c-.09.03-.194 0-.269-.074L8.007 2 6.845 3.09a.303.303 0 01-.269.074l-1.565-.358-.462 1.537a.313.313 0 01-.194.194L2.82 5l.358 1.567a.26.26 0 01-.075.269L2 8.015l1.088 1.164c.075.075.09.18.075.269l-.358 1.567 1.535.463c.09.03.164.104.194.194l.462 1.537 1.565-.358c.015 0 .045-.015.075-.015.075 0 .15.03.209.074L8.007 14l1.163-1.09a.303.303 0 01.269-.074l1.565.358.462-1.537a.313.313 0 01.194-.194L13.195 11l-.358-1.567a.338.338 0 01.075-.254zm-6.046 1.37L4.41 8.26l1.16-1.244 1.767 1.649L10.4 5.6l1.202 1.202-4.242 4.243-.495-.495z"/></svg><span>Certifications</span></a></li><li ><a
                href="https://learning.oreilly.com/preferences/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"/></g></svg><span>Settings</span></a></li><li ><a
                href="https://learning.oreilly.com/public/support/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M7.363 6.656a2.692 2.692 0 0 1-2.681-2.703c0-1.493 1.2-2.703 2.681-2.703a2.692 2.692 0 0 1 2.682 2.703c0 1.493-1.2 2.703-2.682 2.703zm4.023 2.027c-1.852 0-3.352 1.513-3.352 3.379H2v-1.534c-.006-.31.099-.612.295-.852a6.666 6.666 0 0 1 9.09-.993zm-.543.676h1.12v.304c.003.284.16.543.408.676a.766.766 0 0 0 .77 0l.303-.176.556.966-.302.176a.772.772 0 0 0-.362.676v.08a.772.772 0 0 0 .362.677l.302.21-.556.965-.302-.175a.766.766 0 0 0-.771 0 .778.778 0 0 0-.409.675v.352h-1.106v-.372a.778.778 0 0 0-.409-.676.766.766 0 0 0-.77 0l-.303.176-.556-.912.302-.176a.772.772 0 0 0 .362-.676v-.04-.04a.772.772 0 0 0-.362-.676l-.302-.176.556-.966.289.155a.766.766 0 0 0 .77 0 .778.778 0 0 0 .41-.676V9.36zm1.562 2.703c0-.271-.108-.531-.3-.722a1.001 1.001 0 0 0-.72-.292 1.01 1.01 0 0 0-.992 1.023 1.01 1.01 0 0 0 1.01 1.004 1.01 1.01 0 0 0 1.002-1.013z" /></svg><span>Support</span></a></li><li ><a
                href="https://get.oreilly.com/email-signup.html"
                class="l1 nav-icn "
                target=&quot;_blank&quot;
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.564 2.263l2.172 2.174c.17.168.264.397.264.636V11a.6.6 0 0 1-.6.6h-.6V6.2h-6V2.6a.6.6 0 0 1 .6-.6h3.527c.239 0 .468.095.637.263zM2.6 14a.6.6 0 0 1-.6-.6V6.8a.6.6 0 0 1 .6-.6h1.903a1.2 1.2 0 0 1 .849.352L6.2 7.4H11a.6.6 0 0 1 .6.6v5.4a.6.6 0 0 1-.6.6H2.6zM11 5h1.8L11 3.2V5z" /></svg><span>Newsletters</span></a></li><li ><a
                href="https://learning.oreilly.com/accounts/logout/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.613 12.63A.607.607 0 0 1 2 12.03V3.602C2 3.269 2.274 3 2.613 3h5.515v1.204H3.226v7.223h4.902v1.203H2.613zM5.677 9.02V6.611h4.903V4.926a.301.301 0 0 1 .19-.274.31.31 0 0 1 .33.063l2.722 2.673a.594.594 0 0 1 0 .849L11.1 10.909a.31.31 0 0 1-.331.063.301.301 0 0 1-.19-.274V9.02H5.677z" /></svg><span>Sign Out</span></a></li></ul></div></li></ul></nav></header>



      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="ch05.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Beginning Lua Programming
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="ch05.html#" title="Search in archive" class="js-search-controls search-controls" onclick="window.Appcues.track('SearchBook_HeronBook')"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9780470069172/chapter/ch05.html"><div class="js-collections-dropdown collections-dropdown menu-bit-cards" onclick="window.Appcues.track('AddPlaylist_HeronBook')"></div></div></li><li class="js-font-control-panel font-control-activator"><a href="ch05.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size" onclick="window.Appcues.track('ChangeFont_HeronBook')"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="ch05.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share" onclick="window.Appcues.track('Share_HeronBook')"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a
        class="twitter share-button t-twitter"
        target="_blank"
        aria-label="Share this section on Twitter"
        title="Share this section on Twitter"
      
        href="https://twitter.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch05.html&text=Beginning%20Lua%20Programming&via=OReillyMedia"
      ><span>Twitter</span></a></li><li><a
        class="facebook share-button t-facebook"
        target="_blank"
        aria-label="Share this section on Facebook"
        title="Share this section on Facebook"
        href="https://www.facebook.com/sharer/sharer.php?u=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch05.html"
      ><span>Facebook</span></a></li><li><a
        class="googleplus share-button t-googleplus"
        target="_blank"
        aria-label="Share this secton on Google Plus"
        title="Share this secton on Google Plus"
        href="https://plus.google.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch05.html"
      ><span>Google Plus</span></a></li><li><a
        class="email share-button t-email"
        aria-label="Share this section via email"
        title="Share this section via email"
      
        href="mailto:?subject=Safari: 5.%20Using%20Strings&body=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch05.html%0D%0Afrom Beginning%20Lua%20Programming%0D%0A"
      ><span>Email</span></a></li></ul></li><!-- endif request.user.is_authenticated -->
      </ul>
    </div>

      
          
      

    <section role="document">
        
        




  <script defer src="https://learning.oreilly.com/static/js/build/djangoMessagesPage.bfaca9fd8619.js"></script>


        <script src="https://fast.appcues.com/48743.js"></script>
<script>
  var userId = "ce47de5b-ce80-49f0-b5cd-c60d3d33b198";

  var userObject = {
    firstName: "Michael",
    segment: "Trial",
    admin: "False",
    profileCreatedOn: "2021-05-13",
    academic: ""
  };
  window.Appcues.identify(userId, userObject);
  window.Appcues.page();

  setTimeout(function () {
    window.Appcues.track('ViewingBook_HeronBook')
  }, 20000);
</script>


	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="ch04.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">4. Working with Tables</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="ch06.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">6. Handling and Avoiding Errors</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="using_strings"></a>Chapter 5. Using Strings</h1></div></div></div><p>The last chapter covered tables and the table library. You already know strings, but you don't know the string library, and that's the main topic of this chapter. Among many other things, you'll learn about the following:<a id="IDX-CHP-5-0001" class="indexterm"></a><a id="IDX-CHP-5-0002" class="indexterm"></a><a id="IDX-CHP-5-0003" class="indexterm"></a><a id="IDX-CHP-5-0004" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Converting between uppercase and lowercase</p></li><li class="listitem"><p>Getting individual characters and substrings out of strings<a id="IDX-CHP-5-0005" class="indexterm"></a></p></li><li class="listitem"><p>Getting user input</p></li><li class="listitem"><p>Reading from and writing to files</p></li><li class="listitem"><p>Doing pattern matching and replacement on strings (which is very powerful, and accounts for more than half of the chapter)</p></li></ul></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="basic_string_conversion_functions"></a>Basic String Conversion Functions</h1></div></div></div><p>Many of the functions in the string library take a single string argument (and, in a few cases, one or two numeric arguments) and return a single string. In the following example, <code class="literal">string.lower</code> takes a string and returns a string that's the same except that any uppercase letters have been converted to lowercase:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.lower("HELLO there!"))</code></strong>
hello there!</pre><p>Of course, <code class="literal">string.lower</code> doesn't care if the string given to it contains no uppercase letters, or no letters at all — just returns the same string as shown here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.lower("hello there!"))</code></strong>
hello there!
&gt; <strong class="userinput"><code>print(string.lower("1 2 3 4"))</code></strong>
1 2 3 4</pre><p>You may occasionally find yourself doing something like the following, and wondering why <code class="literal">Str</code> hasn't been changed to <code class="literal">"abc"</code>:<a id="IDX-CHP-5-0006" class="indexterm"></a><a id="IDX-CHP-5-0007" class="indexterm"></a><a id="IDX-CHP-5-0008" class="indexterm"></a><a id="IDX-CHP-5-0009" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "ABC"</code></strong>
&gt; <strong class="userinput"><code>string.lower(Str)</code></strong>
&gt; <strong class="userinput"><code>print(Str)</code></strong>
ABC</pre><p>If you think about it, you'll see that this is because strings are immutable, so it's impossible for a function like <code class="literal">string.lower</code> to work by side effect the way functions like <code class="literal">table.sort</code> do. Instead, <code class="literal">string.lower</code> (and all string functions) works by return value:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "ABC"</code></strong>
&gt; <strong class="userinput"><code>Str = string.lower(Str)</code></strong>
&gt; <strong class="userinput"><code>print(Str)</code></strong>
abc</pre><p>It's convenient to say things like "<code class="literal">string.lower</code> converts any uppercase characters in a string to lowercase" (instead of the previous wordier "takes a string and returns a string" phrasing). Saying it this way doesn't mean that <code class="literal">string.lower</code> changes the characters right in the string itself, which is impossible. Rather, the conversion process creates a new string, which is the function's return value.</p><p><code class="literal">string.upper</code> is the obvious counterpart to <code class="literal">string.lower</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.upper("HELLO there!"))</code></strong>
HELLO THERE!</pre><p>Both <code class="literal">string.lower</code> and <code class="literal">string.upper</code> use the current locale to decide what characters are uppercase or lowercase letters. There's a short example of this later in this chapter.</p><p><code class="literal">string.reverse</code> reverses a string, character by character, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.reverse("desserts"))</code></strong>
stressed</pre><div class="blockquote"><blockquote class="blockquote"><p>Lua 5.0 didn't have <code class="literal">string.reverse</code>. It can be written by looping through a string backwards, putting its characters in an array, and passing that array to <code class="literal">table.concat</code>.</p></blockquote></div><p><code class="literal">string.rep</code> takes a string and a number, and repeats the string that many times, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.rep("a", 5))</code></strong>
aaaaa
&gt; <strong class="userinput"><code>print(string.rep("Hubba", 2))</code></strong>
HubbaHubba</pre><p><code class="literal">string.sub</code> returns a substring of the string given to it. The second and third arguments of <code class="literal">string.sub</code> are the (one-based) numeric positions of the desired first and last characters. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "alphaBRAVOcharlie"</code></strong>
&gt; <strong class="userinput"><code>print(string.sub(Str, 1, 5))</code></strong>
alpha
&gt; <strong class="userinput"><code>print(string.sub(Str, 6, 10))</code></strong>
BRAVO</pre><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.sub(Str, 11, 17))</code></strong>
charlie</pre><p>Negative numbers can be used as positions: <code class="literal">−1</code> means the last character in the string, <code class="literal">−2</code> means the second-to-last, and so on:<a id="IDX-CHP-5-0010" class="indexterm"></a><a id="IDX-CHP-5-0011" class="indexterm"></a><a id="IDX-CHP-5-0012" class="indexterm"></a><a id="IDX-CHP-5-0013" class="indexterm"></a><a id="IDX-CHP-5-0014" class="indexterm"></a><a id="IDX-CHP-5-0015" class="indexterm"></a><a id="IDX-CHP-5-0016" class="indexterm"></a><a id="IDX-CHP-5-0017" class="indexterm"></a><a id="IDX-CHP-5-0018" class="indexterm"></a><a id="IDX-CHP-5-0019" class="indexterm"></a><a id="IDX-CHP-5-0020" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.sub(Str, −7, −1))</code></strong>
charlie
<strong class="userinput"><code>&gt;print(string.sub(Str, 6, −8))</code></strong>
BRAVO
<strong class="userinput"><code>&gt;print(string.sub(Str, −17, 5))</code></strong>
alpha</pre><p>All of the built-in functions that take character positions understand negative ones.</p><p>If <code class="literal">string.sub</code>'s last argument is omitted, it defaults to <code class="literal">−1</code> (or, equivalently, the length of the string), as follows:<a id="IDX-CHP-5-0021" class="indexterm"></a></p><pre class="programlisting"><strong class="userinput"><code>&gt;print(string.sub(Str, 1))</code></strong>
alphaBRAVOcharlie
<strong class="userinput"><code>&gt;print(string.sub(Str, −7))</code></strong>
charlie</pre></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="string_length"></a>String Length</h1></div></div></div><p><code class="literal">string.len</code> (like the <code class="literal">#</code> operator) returns the length of the string given to it. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.len(""))</code></strong>
0
&gt; <strong class="userinput"><code>print(string.len("ABCDE"))</code></strong>
5</pre></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="converting_between_characters_and_charac"></a>Converting Between Characters and Character Codes</h1></div></div></div><p><code class="literal">string.byte</code> returns the numerical byte values used by your system to represent the characters of the substring specified (<code class="literal">string.sub</code>-style) by its second and third arguments. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.byte("ABCDE", 1, 5))</code></strong>
65      66      67      68      69
&gt; <strong class="userinput"><code>print(string.byte("ABCDE", 2, −2))</code></strong>
66      67      68</pre><p>The third argument defaults to the value of the second argument (so only one character's byte value is returned):</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.byte("ABCDE", 2))</code></strong>
66</pre><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.byte("ABCDE", −1))</code></strong>
69</pre><p><code class="literal">string.byte</code> is often called with only one argument, in which case the second argument defaults to <code class="literal">1</code>:<a id="IDX-CHP-5-0022" class="indexterm"></a><a id="IDX-CHP-5-0023" class="indexterm"></a><a id="IDX-CHP-5-0024" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.byte("ABCDE"))</code></strong>
65
&gt; <strong class="userinput"><code>print(string.byte("A"))</code></strong>
65</pre><div class="blockquote"><blockquote class="blockquote"><p>The Lua 5.0 <code class="literal">string.byte</code> only took two arguments and therefore never returned more than one value.</p></blockquote></div><p><code class="literal">string.char</code> takes integers like those returned by <code class="literal">string.byte</code> and returns a string composed of those characters, as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.char(65))</code></strong>
A
&gt; <strong class="userinput"><code>print(string.char(65, 65, 66, 66))</code></strong>
AABB</pre><p>If called with no arguments, it returns the empty string.</p><p>The byte values used by <code class="literal">string.byte</code> and <code class="literal">string.char</code> are not necessarily the same from system to system. Most of the examples in this book assume that ASCII characters have their ASCII values. (If this is not true on your system, you probably know it.)<a id="IDX-CHP-5-0025" class="indexterm"></a></p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="formatting_strings_and_numbers_with_stri"></a>Formatting Strings and Numbers with string.format</h1></div></div></div><p>The code you've seen and written so far has formatted its output using string concatenation: <code class="literal">tostring</code>, and the automatic insertion of tabs with <code class="literal">print</code>. A more powerful tool for formatting output is <code class="literal">string.format</code>, which can do the following:<a id="IDX-CHP-5-0026" class="indexterm"></a><a id="IDX-CHP-5-0027" class="indexterm"></a><a id="IDX-CHP-5-0028" class="indexterm"></a><a id="IDX-CHP-5-0029" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Pad strings with spaces and pad numbers with spaces or zeros<a id="IDX-CHP-5-0030" class="indexterm"></a><a id="IDX-CHP-5-0031" class="indexterm"></a></p></li><li class="listitem"><p>Output numbers in hexadecimal or in octal (base 8)</p></li><li class="listitem"><p>Trim extra characters from a string</p></li><li class="listitem"><p>Left- or right-justify output within columns<a id="IDX-CHP-5-0032" class="indexterm"></a></p></li></ul></div><div class="sidebar"><a id="try_it_out_colon_outputting_data_in_colu"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Outputting Data in Columns</strong></p></div></div></div><p>Imagine you have a bulletin board system, and you want a report of how many new posts and replies to existing posts each user has made. If you wanted to read this report in a web browser, you could format it as HTML, but if you want to read it on the command line or in a text editor, then it'll be easier to read if you format it in columns. (This works only with fixed-width fonts like Courier or Fixedsys, which you should be using to read and write code anyway.)<a id="IDX-CHP-5-0033" class="indexterm"></a></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Define the following function:<a id="IDX-CHP-5-0034" class="indexterm"></a><a id="IDX-CHP-5-0035" class="indexterm"></a></p><pre class="programlisting">-- Prints a report of posts per user:
function Report(Users)
  print("USERNAME NEW POSTS REPLIES")
  for Username, User in pairs(Users) do
    print(string.format("%-15s %6d %6d",
      Username, User.NewPosts, User.Replies))
  end
end</pre></li><li class="listitem"><p>Run it as follows:</p><pre class="programlisting">Report({
      arundelo = {NewPosts = 39, Replies = 19},
      kwj = {NewPosts = 22, Replies = 81},
      leethax0r = {NewPosts = 5325, Replies = 0}})</pre><p>The output should be this:</p><pre class="programlisting">USERNAME    NEW POSTS     REPLIES
arundelo           39          19
leethax0r        5325           0
kwj                22          81</pre></li></ol></div><p><span class="strong"><strong>How It Works</strong></span></p><p>The <code class="literal">string.format</code> function takes as its first argument a <span class="emphasis"><em>format string</em></span> that includes <span class="emphasis"><em>format placeholders</em></span> like <code class="literal">"%-15s"</code> and <code class="literal">"%6d"</code>. It returns a string constructed by replacing the placeholders by the rest of the <code class="literal">string.format</code> arguments.<a id="IDX-CHP-5-0036" class="indexterm"></a></p><p>All format placeholders start with the <code class="literal">%</code> character. A placeholder that ends in the character <code class="literal">s</code> inserts the corresponding arguments as a string:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("--&gt;%s&lt;--", "arundelo"))</code></strong>
--&gt;arundelo&lt;--</pre><p>A number that's between the <code class="literal">%</code> and the <code class="literal">s</code> uses spaces to pad the string out to that many characters:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("--&gt;%15s&lt;--", "arundelo"))</code></strong>
--&gt;     arundelo&lt;--</pre><p>A <code class="literal">-</code> (minus sign) in front of the number left-justifies the string:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("--&gt;%-15s&lt;--", "arundelo"))</code></strong>
--&gt;arundelo       &lt;--</pre><p>A placeholder that ends in the character <code class="literal">d</code> inserts the corresponding argument as a decimal integer:</p><pre class="programlisting"><strong class="userinput"><code>print(string.format("--&gt;%d&lt;--", 39))</code></strong>
--&gt;39&lt;--</pre><p>A number in between the <code class="literal">%</code> and the <code class="literal">d</code> uses spaces to pad the number out to that many characters (numbers can also be left-justified just like strings, but that's not done in this example):</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("--&gt;%6d&lt;--", 39))</code></strong>
--&gt;    39&lt;--</pre><p>There should be a one-to-one correspondence between placeholders and extra arguments ("extra arguments" here refer to arguments after the format string). The first placeholder corresponds to the first extra argument, the second placeholder to the second extra argument, and so on:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("%-15s %6d %6d", "arundelo", 39, 19))</code></strong>
arundelo             39       19</pre></div><p>Apart from its ability to format strings and numbers to certain lengths, <code class="literal">string.format</code> is also a useful alternative to string concatenation. Both of the following two lines insert the variables <code class="literal">Link</code> and <code class="literal">LinkText</code> into an HTML <code class="literal">&lt;a&gt;</code> (anchor) element. The second has the disadvantage of greater length, but it's arguably more readable, especially after your eye gets used to picking out the two format placeholders:<a id="IDX-CHP-5-0037" class="indexterm"></a></p><pre class="programlisting">Anchor = '&lt;a href="' .. Link .. '"&gt;' .. LinkText .. '&lt;/a&gt;'

Anchor = string.format('&lt;a href="%s"&gt;%s&lt;/a&gt;', Link, LinkText)</pre><p>This readability advantage ramps up the more alternating literal strings and variables you're dealing with. If you find yourself using <code class="literal">string.format</code> a lot in a particular piece of code, you can give it a shorter name, like this:</p><pre class="programlisting">local Fmt = string.format</pre><p>A single percent sign in <code class="literal">string.format</code>'s output is represented by two consecutive ones in the format string, as in the following example. This <code class="literal">%%</code> pseudo-placeholder is the only exception to the one-to-one correspondence between format placeholders and the rest of the <code class="literal">string.format</code> arguments:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("We gave %d%%!", 110))</code></strong>
We gave 110%!</pre><p>When necessary, <code class="literal">string.format</code> converts strings to numbers and numbers to strings, but any other conversions need to be done by hand. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("%d-%s", "50", 50))</code></strong>
50-50
&gt; <strong class="userinput"><code>print(string.format("%s", {}))</code></strong>
stdin:1: bad argument #2 to 'format' (string expected, got table)
stack traceback:
       [C]: in function 'format'
       stdin:1: in main chunk
       [C]: ?
&gt; <strong class="userinput"><code>print(string.format("%s", tostring({})))</code></strong>
table: 0x4927e8</pre><p>The %d placeholder only works for integers. For fractional numbers, use <code class="literal">%f</code> as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("We gave %f percent!", 99.44))</code></strong>
We gave 99.440000 percent!</pre><p>By default, six digits are printed after the decimal point. To control this, supply a <span class="emphasis"><em>precision</em></span>, which should be an integer preceded by a dot. For example:</p><pre class="programlisting"><strong class="userinput"><code>&gt;print(string.format("%.0f | %.1f | %.2f | %.3f",</code></strong>
&gt;&gt;   <strong class="userinput"><code>99.44, 99.44, 99.44, 99.44))</code></strong>
99 | 99.4 | 99.44 | 99.440</pre><p>If there's a <span class="emphasis"><em>width</em></span> (the number used to control column widths in the previous Try-It-Out example), put it before the precision. The width includes any digits after the decimal point, and the decimal point itself, if there is one. Here's an example:</p><div class="blockquote"><blockquote class="blockquote"><p>For readability, this example uses a square-bracket string, as covered in <a class="link" href="ch02.html" title="Chapter 2. First Steps">Chapter 2</a>.</p></blockquote></div><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format([[</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%5.0f&lt;-- width: 5; precision: 0</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%5.1f&lt;-- width: 5; precision: 1</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%5.2f&lt;-- width: 5; precision: 2]], 99.44, 99.44, 99.44))</code></strong>
--&gt;   99&lt;-- width: 5; precision: 0
--&gt; 99.4&lt;-- width: 5; precision: 1
--&gt;99.44&lt;-- width: 5; precision: 2</pre><p>If either a string or a number is longer than the width allotted for it, it will spill over—no characters or digits will be removed:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- Print some usernames in a 15-character column:</code></strong>
&gt; <strong class="userinput"><code>print(string.format([[</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%-15s&lt;--</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%-15s&lt;--</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%-15s&lt;--</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%-15s&lt;--]],</code></strong>
&gt;&gt;   <strong class="userinput"><code>"arundelo", "kwj", "leethax0r", "reallylongusername"))</code></strong>
--&gt;arundelo       &lt;--
--&gt;kwj            &lt;--
--&gt;leethax0r      &lt;--
--&gt;reallylongusername&lt;--
&gt; <strong class="userinput"><code>-- Print various numbers in a 4-character column:</code></strong>
&gt; <strong class="userinput"><code>print(string.format([[</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%6.1f&lt;--</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%6.1f&lt;--</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%6.1f&lt;--]], 1, 99.44, 123456789))</code></strong>
--&gt;    1.0&lt;--
--&gt;   99.4&lt;--
--&gt; 123456789.0&lt;--</pre><p>If you give a <code class="literal">%s</code> placeholder a precision, it's treated as a maximum width—characters will be trimmed from the end of the string to make it fit. The following strings are printed with a width (the minimum width) of <code class="literal">2</code> and a precision (the maximum width) of <code class="literal">2</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format([[</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%2.2s&lt;--</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%2.2s&lt;--</code></strong>
&gt;&gt; <strong class="userinput"><code>--&gt;%2.2s&lt;--]], "a", "ab", "abc"))</code></strong>
--&gt; a&lt;--
--&gt;ab&lt;--
--&gt;ab&lt;--</pre><p>Along with the <code class="literal">-</code> (left-justification) character, you can place the following characters right after the percent sign (that is, before the width and precision, if any):</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- "+" -- all numbers are printed with a sign:</code></strong>
&gt; <strong class="userinput"><code>print(string.format("%+d", 1))</code></strong>
+1
&gt; <strong class="userinput"><code>-- " " -- use a space if a sign is omitted on a positive</code></strong>
&gt; <strong class="userinput"><code>-- number:</code></strong>
&gt; <strong class="userinput"><code>print(string.format("% d", 1))</code></strong>
1
&gt; <strong class="userinput"><code>-- "0" -- pad numbers with zeros instead of spaces:</code></strong>
&gt; <strong class="userinput"><code>print(string.format("%05d", 1))</code></strong>
00001
&gt; <strong class="userinput"><code>-- "#" -- various uses -- with %f, output always has a</code></strong>
&gt; <strong class="userinput"><code>-- decimal point; with %x, output always has "0x":</code></strong>
&gt; <strong class="userinput"><code>print(string.format("%#.0f", 1))</code></strong>
1.
&gt; <strong class="userinput"><code>print(string.format("%#x", 31))</code></strong>
0x1f</pre><p>These characters don't have to be in any particular order when combined. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("--&gt;%-+5d&lt;--", 11))</code></strong>
--&lt;+11   &gt;--
&gt; <strong class="userinput"><code>print(string.format("--&gt;%+-5d&lt;--", 11))</code></strong>
--&gt;+11   &lt;--</pre><p>The <code class="literal">%q</code> placeholder ("q" stands for quote) surrounds a string with double quotes, backslash-escapes any double quotes, backslashes, or newlines in it, and converts any zero bytes to <code class="literal">"\\000"</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("%q", [[backslash: \; double quote: "]]))</code></strong>
"backslash: \\; double quote: \""
&gt; <strong class="userinput"><code>print(string.format("%q", "\0\n"))</code></strong>
"\000\"</pre><p>In other words, it converts a string into a representation of that string usable in Lua source code:</p><pre class="programlisting">&gt; <strong class="userinput"><code>WeirdStr = "\"\\\n\0"</code></strong>
&gt; <strong class="userinput"><code>Fnc = loadstring(string.format("return %q", WeirdStr))</code></strong></pre><pre class="programlisting">&gt; <strong class="userinput"><code>print(Fnc() == WeirdStr)</code></strong>
true</pre><p>This lets you save data for subsequent use by formatting it as a valid Lua script and putting it into a file. When you want to retrieve the data, you load the file into a string, pass it to <code class="literal">loadstring</code>, and call the resulting function. (You'll see how to save and load files in the next section.)<a id="IDX-CHP-5-0038" class="indexterm"></a></p><p>This kind of data file can consist of a single return statement (like the string passed to <code class="literal">loadstring</code> in the previous example). It can also be a series of function calls whose arguments are the data in question, like this:</p><pre class="programlisting">Record{Username = "arundelo", NewPosts = 39, Replies = 19}
Record{Username = "kwj", NewPosts = 22, Replies = 81}
Record{Username = "leethax0r", NewPosts = 5325, Replies = 0}</pre><p>The function called (<code class="literal">Record</code> in this example) is one that you define to do what's necessary to make the data available to the main program. If this function is given to the <code class="literal">loadstring</code> function by <code class="literal">setfenv</code>, then there's no need for the data file to have access to any other functions.</p><p>If you want to save a table, you need to build up a string by splicing together the table's keys and values with the appropriate curly braces, square brackets, commas, and so on. <a class="link" href="ch07.html" title="Chapter 7. Using Modules">Chapter 7</a> has an example of this.</p><p>Other common placeholders include <code class="literal">%x</code> and <code class="literal">%X</code> for hexadecimal output, <code class="literal">%o</code> for octal output, <code class="literal">%e</code> and <code class="literal">%E</code> for scientific notation, <code class="literal">%g</code> and <code class="literal">%G</code> for automatic selection between scientific notation and standard notation, and <code class="literal">%i</code>, which is just a synonym for <code class="literal">%d</code>. Here are some examples:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("%%x: %x\t%%o: %o", 31, 31))</code></strong>
%x: 1f  %o: 37
&gt; <strong class="userinput"><code>print(string.format("%%e: %e\t%%g: %g", 3.1, 3.1))</code></strong>
%e: 3.100000e+00         %g: 3.1
&gt; <strong class="userinput"><code>print(string.format("%%e: %e\t%%g: %g", 11 ^ 13, 11 ^ 13))</code></strong>
%e: 3.452271e+13         %g: 3.45227e+13</pre><p>Placeholders that come in both uppercase and lowercase differ only in the case of any letters they might print. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.format("%x, %X", 255, 255))</code></strong>
ff, FF</pre><p>More detail on format strings is available in books on the C programming language, because the <code class="literal">string.format</code> format placeholders are almost exactly the same as those used by the C language's <code class="literal">printf</code> family of functions.</p><div class="blockquote"><blockquote class="blockquote"><p>The differences are as follows: C doesn't understand the <code class="literal">%q</code> placeholder, and Lua doesn't understand the <code class="literal">h, L</code>, or <code class="literal">l</code> modifiers, the <code class="literal">%n</code> or <code class="literal">%p</code> placeholders, or the <code class="literal">*</code> character used as a width or precision. To compensate for the second difference, you can build a format string in Lua at run time.</p></blockquote></div><p>A lot of <code class="literal">string.format</code>'s work is actually done by the C function <code class="literal">sprintf</code>. This means that you should not include any "\0" characters in strings you give to <code class="literal">string.format</code> (unless they'll be formatted by <code class="literal">%q</code> placeholders).</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="input_solidus_output"></a>Input/Output</h1></div></div></div><p>It's time to take a brief break from the string library, and detour through the topic of <span class="emphasis"><em>input/output</em></span> (<span class="emphasis"><em>I/O</em></span>). You've already used <code class="literal">print</code> for output, but <code class="literal">print</code> does things in addition to output data—it converts everything to strings, separates multiple arguments with tabs, and appends a newline. This is convenient for debugging because you can see what values a function returns, but a more fundamental output function is <code class="literal">io.write</code>. This function expects all of its arguments to be strings or numbers, and it outputs each of the arguments without adding anything. The &gt; character that appears to be at the end of the following output is really just the Lua prompt—it didn't get put on its own line because no newline was outputted:<a id="IDX-CHP-5-0039" class="indexterm"></a><a id="IDX-CHP-5-0040" class="indexterm"></a><a id="IDX-CHP-5-0041" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Str1, Str2 = "Alpha", "Bravo"</code></strong>
&gt; <strong class="userinput"><code>io.write(Str1, Str2)</code></strong>
AlphaBravo&gt;</pre><p>Here's the same thing, with a space and a newline:</p><pre class="programlisting">&gt; <strong class="userinput"><code>io.write(Str1, " ", Str2, "\n")</code></strong>
Alpha Bravo
&gt;</pre><p>And in the following, <code class="literal">io.write</code> is used like a <code class="literal">print</code> that uses neither the concatenation operator nor <code class="literal">table.concat</code>; (trace its execution for a few sample arguments so that you can see how it works, especially how it builds one line of output with several iterations of <code class="literal">io.write</code>):</p><pre class="programlisting">function Print(...)
     local ArgCount = select("#", ...)
     for I = 1, ArgCount do
       -- Only print a separator if one argument has already
       -- been printed:
     if I &gt; 1 then
       io.write("\t")
     end
     io.write(tostring(select(I, ...)))
   end
   io.write("\n")
 end</pre><p>The function <code class="literal">io.read</code> reads (by default) one line of input. Call it like so:</p><pre class="programlisting">Line = io.read()</pre><p>Your cursor will move to the next line, but there'll be no Lua prompt. Type some random text and press Enter. The Lua prompt will reappear. Print <code class="literal">Line</code> and you'll see that it contains whatever you typed.</p><p>To write to or read from a file, you need a <span class="emphasis"><em>handle</em></span> to that file. A file handle is an object with methods like <code class="literal">write</code> and <code class="literal">read</code>. Getting a handle to a file is called <span class="emphasis"><em>opening</em></span> the file.<a id="IDX-CHP-5-0042" class="indexterm"></a></p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="writing_to_and_reading_from_a_file"></a>Writing to and Reading from a File</h2></div></div></div><p>The following example will write to a file named <code class="literal">test.txt</code> in your current directory. (If you already have a file of this name that you don't want overwritten, move it or use a different name.) Do the following in the interpreter:<a id="IDX-CHP-5-0043" class="indexterm"></a><a id="IDX-CHP-5-0044" class="indexterm"></a><a id="IDX-CHP-5-0045" class="indexterm"></a><a id="IDX-CHP-5-0046" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>FileHnd, ErrStr = io.open("test.txt", "w")</code></strong>
&gt; <strong class="userinput"><code>print(FileHnd, ErrStr)</code></strong>
file (0x485ad4) nil
&gt; <strong class="userinput"><code>FileHnd:write("Line 1\nLine 2\nLine 3\n")</code></strong>
&gt; <strong class="userinput"><code>FileHnd:close()</code></strong>
&gt; <strong class="userinput"><code>FileHnd, ErrStr = io.open("test.txt")</code></strong>
&gt; <strong class="userinput"><code>print(FileHnd, ErrStr)</code></strong>
file (0x485ad4) nil
&gt; <strong class="userinput"><code>print(FileHnd:read())</code></strong>
Line 1
&gt; <strong class="userinput"><code>print(FileHnd:read())</code></strong>
Line 2
&gt; <strong class="userinput"><code>print(FileHnd:read())</code></strong>
Line 3
&gt; <strong class="userinput"><code>print(FileHnd:read())</code></strong>
nil
&gt; <strong class="userinput"><code>FileHnd:close()</code></strong>
&gt; <strong class="userinput"><code>print(os.remove("test.txt"))</code></strong>
true</pre><p>The first <code class="literal">io.open</code> argument is the name of the file to be opened. Its second argument, <code class="literal">"w"</code>, means that the file will be opened in <span class="emphasis"><em>write mode</em></span>, making it possible to write to it but not read from it. If the file is successfully opened, a handle to it will be returned, but if for some reason it can't be opened, then it returns a <code class="literal">nil</code> value and an error message. (You can print the file handle and the error message in the context of an actual program with something like <code class="literal">"if FileHnd then"</code>. There's an example of this in the next chapter.)</p><p>The file handle has a <code class="literal">write</code> method, which works just like <code class="literal">io.write</code>, but writes to the file instead of your screen. The following line writes three lines (each one terminated with a newline character) to the file:</p><pre class="programlisting">FileHnd:write("Line 1\nLine 2\nLine 3\n")</pre><p>After this, calling the file handle's <code class="literal">close</code> method <span class="emphasis"><em>closes</em></span> the file. This ensures that all output actually makes it to the hard drive, and that any system resources associated with the open file aren't tied up any longer than they need to be. After the file is closed, an attempt to use any of the handle's methods will cause an error.</p><p>Next, the file is reopened, but this time in read mode instead of write mode. (The second <code class="literal">io.open</code> argument defaults to <code class="literal">"r"</code>.)</p><p>The first three times <code class="literal">FileHnd:read</code> is called, it returns the file's three lines, one after the other. Notice that the newline characters marking the ends of these lines are <span class="emphasis"><em>not</em></span> returned. (You can tell this because, if they were returned, then <code class="literal">print</code> would appear to print an extra blank line after each line.)</p><p>The fourth time <code class="literal">FileHnd:read</code> is called, it returns <code class="literal">nil</code>, which means that the end of the file has been reached. The file is then closed with <code class="literal">FileHnd:close</code> and removed with <code class="literal">os.remove</code>, whose return value of <code class="literal">true</code> just means that the removal was successful. If you skip the removal step, you can look at <code class="literal">test.txt</code> in your text editor.<a id="IDX-CHP-5-0047" class="indexterm"></a><a id="IDX-CHP-5-0048" class="indexterm"></a><a id="IDX-CHP-5-0049" class="indexterm"></a><a id="IDX-CHP-5-0050" class="indexterm"></a><a id="IDX-CHP-5-0051" class="indexterm"></a><a id="IDX-CHP-5-0052" class="indexterm"></a><a id="IDX-CHP-5-0053" class="indexterm"></a></p><p>The first character of the second <code class="literal">io.open</code> argument must be an <code class="literal">r</code> (for read mode), a <code class="literal">w</code> (for write mode, which discards any contents the file may have already had), or an <code class="literal">a</code> (for append mode, which writes to the end of the file, preserving any previous contents). This letter can optionally be followed by (in any order) a "<code class="literal">+</code>" character and/or a "<code class="literal">b</code>" character. Including <code class="literal">"+"</code> opens the file in one of three different versions of read/write mode, depending on the first letter. Including <code class="literal">"b"</code> opens the file in <span class="emphasis"><em>binary mode</em></span> (specifically binary read, binary write, or binary append mode).<a id="IDX-CHP-5-0054" class="indexterm"></a><a id="IDX-CHP-5-0055" class="indexterm"></a><a id="IDX-CHP-5-0056" class="indexterm"></a></p><p>There's more discussion of the distinction between binary mode and text mode (the default) in <a class="link" href="ch13.html" title="Chapter 13. Interfacing Lua with Other Languages">Chapter 13</a>, but here's the essence. Some systems use something other than <code class="literal">"\n"</code> to mark the end of a line. Lua (actually, the C I/O library that Lua uses) does a translation that lets you ignore this and always use <code class="literal">"\n"</code>. That's a good thing, but if you're working with a file that isn't text, and you don't want the library messing with any bytes that happen to look like end-of-line markers, or if you have to deal with text files that were created on a system with a different end-of-line convention, a mode string with <code class="literal">"b"</code> turns off this translation.</p><p>If given no arguments, <code class="literal">read</code> (either <code class="literal">io.read</code> or the <code class="literal">read</code> method of a file handle) reads and returns one line (with no trailing <code class="literal">"\n"</code>) or returns <code class="literal">nil</code> on end-of-file. If it's given an argument, the argument should be one of the following:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"><col class="col2"></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Argument</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">"*l"</code></p></td><td style="text-align: left" valign="top"><p>Reads and returns one line (with no trailing <code class="literal">"\n"</code>) or returns <code class="literal">nil</code> on end-of-file.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">"*a"</code></p></td><td style="text-align: left" valign="top"><p>Reads and returns the whole file, minus anything that's already been read. This will be the empty string if the whole file has already been read.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">"*n"</code></p></td><td style="text-align: left" valign="top"><p>Reads and returns a number, or returns <code class="literal">nil</code> if a number can't be read (possibly because there's something other than whitespace that needs to be read first before a number can be reached).</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">a number</code></p></td><td style="text-align: left" valign="top"><p>Reads and returns a string with this many characters (or less, if end-of-file is reached). If end-of-file is reached without needing to read any characters, nil is returned.</p></td></tr></tbody></table></div><p><code class="literal">read</code> can be given multiple arguments, in which case it reads and returns multiple values.</p><p>The I/O library supplies the following three pre-opened file handles to virtual files (things that act like files, but don't actually reside on the hard disk):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">io.stdin</code> is the <span class="emphasis"><em>standard input</em></span> file handle (read-only). By default, it reads from the keyboard. <code class="literal">io.stdin:read</code> acts the same as <code class="literal">io.read</code>.<a id="IDX-CHP-5-0057" class="indexterm"></a></p></li><li class="listitem"><p><code class="literal">io.stdout</code> is the <span class="emphasis"><em>standard output</em></span> file handle (write-only). By default, it writes to the screen. <code class="literal">io.stdout:write</code> acts the same as <code class="literal">io.write</code>.<a id="IDX-CHP-5-0058" class="indexterm"></a></p></li><li class="listitem"><p><code class="literal">io.stderr</code> is the <span class="emphasis"><em>standard error</em></span> file handle (write-only). By default, it too writes to the screen.</p></li></ul></div><p>Now that you know the basics of I/O, you can write a script that works with files.<a id="IDX-CHP-5-0059" class="indexterm"></a></p><div class="sidebar"><a id="try_it_out_colon_sorting_and_eliminating"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Sorting and Eliminating Duplicate Lines in a File</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a file with the following contents, and save it as <span class="strong"><strong>sortuniq.lua</strong></span>:</p><pre class="programlisting">-- This script outputs all unique lines of a file, sorted.
-- It does no error checking!
--
-- Usage:
--
--   lua sortuniq.lua INFILE OUTFILE
--
-- If OUTFILE is not given, standard output will be used. If
-- no arguments are given, standard input and standard output
-- will be used.

-- Like pairs, but loops in order by key. (Unlike the
-- version in Chapter 4, this only handles all-string or
-- all-numeric keys.)
function SortedPairs(Tbl)
  local Sorted = {} -- A (soon to be) sorted array of Tbl's keys.
  for Key in pairs(Tbl) do
    Sorted[#Sorted + 1] = Key
  end
  table.sort(Sorted)
  local I = 0

  -- The iterator itself:
  return function()
    I = I + 1
    local Key = Sorted[I]
    return Key, Tbl[Key]
  end
end

function Main(InFilename, OutFilename)
  -- Make the lines of the input file (standard input if no
  -- name was given) keys of a table:
  local Lines = {}
  local Iter = InFilename and io.lines(InFilename) or io.lines()
  for Line in Iter do
    Lines[Line] = true
  end
  -- Get a handle to the output file (standard output if no
  -- name was given):
  local OutHnd = OutFilename
    and io.open(OutFilename, "w")
    or io.stdout
  -- Write each line in Lines to the output file, in order:
  for Line in SortedPairs(Lines) do
    OutHnd:write(Line, "\n")
  end
  OutHnd:close()
end

Main(...)</pre></li><li class="listitem"><p>Create a file with the following contents, and save it as <span class="strong"><strong>testin.txt</strong></span>:<a id="IDX-CHP-5-0060" class="indexterm"></a></p><pre class="programlisting">bravo
alpha
charlie
alpha
charlie
charlie
alpha</pre></li><li class="listitem"><p>At your shell, type this:</p><pre class="programlisting">lua sortuniq.lua testin.txt testout.txt</pre></li><li class="listitem"><p>Open the <code class="literal">testout.txt</code> file in your text editor. Here's what it should contain:</p><pre class="programlisting">alpha
bravo
charlie</pre></li></ol></div><p><span class="strong"><strong>How It Works</strong></span></p><p><code class="literal">io.lines</code> is an iterator factory. If given a filename, it opens that file and returns an iterator that loops through all lines in the file. If called with no argument, it returns an iterator that loops through all lines found on standard input (by default, the lines you type).</p><p><code class="literal">sortuniq.lua</code> is written to use either of these. If no input file is given as a command-line argument, <code class="literal">io.lines</code> would be called with no argument and loop through standard input. In the previous example, though, <code class="literal">InFilename</code> is <code class="literal">testin.txt</code>, each line of which is made a key in the table <code class="literal">Lines</code> inside the loop. This has the effect of ignoring duplicate lines:</p><pre class="programlisting">local Lines = {}
local Iter = InFilename and io.lines(InFilename) or io.lines()
for Line in Iter do
  Lines[Line] = true
end</pre><p>When the iterator hits the end of <code class="literal">testin.txt</code>, it closes the file right before the loop is exited. Next, <code class="literal">testout.txt</code> (the file named by <code class="literal">OutFilename</code>) is opened. Again, the following is done so that standard output will be used if no output file was specified on the command line:</p><pre class="programlisting">local OutHnd = OutFilename
   and io.open(OutFilename, "w")
   or io.stdout</pre><p>Next, the <code class="literal">SortedPairs</code> function loops through <code class="literal">Lines</code> in order by key, and each key is written to <code class="literal">testout.txt</code>, along with a newline— the <code class="literal">io.lines</code> iterator, like <code class="literal">io.read</code>, doesn't include newlines on the lines it returns:</p><pre class="programlisting">for Line in SortedPairs(Lines) do
  OutHnd:write(Line, "\n")
end</pre><p>Finally, <code class="literal">testout.txt</code> is closed and the program is exited.</p></div><p>If you don't supply an output file at the command line, then standard output is used, which means the output will get written right to your screen (as though <code class="literal">io.write</code> had been used instead of <code class="literal">OutHnd:write</code>). If you also omit the input file, then standard input is used, which means you can type the input instead of saving it in a file. (Use Ctrl+D or Ctrl+Z to send an EOF when you're done typing.)<a id="IDX-CHP-5-0061" class="indexterm"></a><a id="IDX-CHP-5-0062" class="indexterm"></a><a id="IDX-CHP-5-0063" class="indexterm"></a><a id="IDX-CHP-5-0064" class="indexterm"></a><a id="IDX-CHP-5-0065" class="indexterm"></a><a id="IDX-CHP-5-0066" class="indexterm"></a><a id="IDX-CHP-5-0067" class="indexterm"></a></p><p>Omitting the filenames also lets you use your shell's <span class="emphasis"><em>redirection operators</em></span> (<code class="literal">&lt;, &gt;</code>, and <code class="literal">|</code>) to make standard input come from a file or another program instead of your keyboard, and standard output go to a file or another program instead of your screen. For example, the following code:<a id="IDX-CHP-5-0068" class="indexterm"></a></p><pre class="programlisting">lua sortuniq.lua &lt; testin.txt &gt; testout.txt</pre><p>does the same thing as this:</p><pre class="programlisting">lua sortuniq.lua testin.txt testout.txt</pre><p>except that in the version with &lt;and&gt; , the shell opens <code class="literal">testin.txt</code> and <code class="literal">testout.txt</code> and <code class="literal">sortuniq.lua</code> just uses standard input and standard output.</p><p>This script does no error checking. If, for instance, the output file can't be created or is read-only, then the <code class="literal">io.open</code> will fail, and output will default to standard output with no explanation of why that happened. You'll learn how to check for and handle errors in the next chapter, but for now just remember that most I/O library functions will return <code class="literal">nil</code> and an error string if something unexpected happens.</p><p>For example, a file's <code class="literal">write</code> function simply triggers an error when you give it bad arguments or use it with a closed file, but when it doesn't trigger an error, it returns <code class="literal">true</code> or <code class="literal">nil</code> depending on whether it successfully wrote what you wanted it to write. If it returns a <code class="literal">nil</code> then the second return value will be an error message. Accidentally writing to a file opened in read mode gives the cryptic <code class="literal">"No error"</code>, and writing to a disk drive that has no more space might give an error message like <code class="literal">"No space left on device"</code>. The former is just a programmer error, but the latter is something that the program can't prevent. If a program doesn't check the <code class="literal">write</code> return values, it won't know if something like this happens. That's fine for scripts where the likelihood or harmfulness of a disk drive filling up is small, for example, but something mission-critical may merit more care.</p><p>Some functions (such as <code class="literal">io.open</code>), are more likely to fail in this way, so their return values should always be checked, except in interactive use or quick-and-dirty scripts where you can spot problems and fix them on the fly.</p><div class="blockquote"><blockquote class="blockquote"><p>When an I/O function returns <code class="literal">nil</code> and an error message, it also returns, as an undocumented third value, the numeric error code from C. Later in this chapter, you'll find out about the implications of using undocumented features.</p></blockquote></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="pattern-matching"></a>Pattern-Matching</h1></div></div></div><p>Other than the <code class="literal">string.dump</code> function (to be covered in <a class="link" href="ch10.html" title="Chapter 10. Looking Under the Hood">Chapter 10</a>), the rest of the functions in the string library are all for finding or replacing substrings. (In some cases, the substring being searched for is the entire string being searched.) A string being searched is called a <span class="emphasis"><em>subject</em></span>. A substring to be searched for is specified with a string called a <span class="emphasis"><em>pattern</em></span>, and the substring, if found, is called a <span class="emphasis"><em>match</em></span>.<a id="IDX-CHP-5-0069" class="indexterm"></a><a id="IDX-CHP-5-0070" class="indexterm"></a><a id="IDX-CHP-5-0071" class="indexterm"></a></p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="searching_for_a_specific_string"></a>Searching for a Specific String</h2></div></div></div><p>A single pattern can have different matches. For example, a pattern that searched for "sequences of 1 or more whitespace characters" would match both the <code class="literal">" "</code> and <code class="literal">"\t\n\t\n"</code> substrings, among others. However, you can also use a pattern to search for one specific match. In the simplest case, such a pattern is identical to the substring it matches, like this one:<a id="IDX-CHP-5-0072" class="indexterm"></a><a id="IDX-CHP-5-0073" class="indexterm"></a><a id="IDX-CHP-5-0074" class="indexterm"></a><a id="IDX-CHP-5-0075" class="indexterm"></a><a id="IDX-CHP-5-0076" class="indexterm"></a><a id="IDX-CHP-5-0077" class="indexterm"></a><a id="IDX-CHP-5-0078" class="indexterm"></a><a id="IDX-CHP-5-0079" class="indexterm"></a><a id="IDX-CHP-5-0080" class="indexterm"></a><a id="IDX-CHP-5-0081" class="indexterm"></a><a id="IDX-CHP-5-0082" class="indexterm"></a><a id="IDX-CHP-5-0083" class="indexterm"></a><a id="IDX-CHP-5-0084" class="indexterm"></a><a id="IDX-CHP-5-0085" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "The rain in Spain stays mainly in the plain."</code></strong>
&gt; <strong class="userinput"><code>print(string.gsub(Str, "ai", "oy"))</code></strong>
The royn in Spoyn stays moynly in the ployn. 4</pre><p><code class="literal">string.gsub</code> searches its first argument (the subject) for substrings that match the pattern given as its second argument, and replaces any that it finds with its third argument. Thus every occurence of <code class="literal">"ai"</code> in <code class="literal">Str</code> is replaced with <code class="literal">"oy"</code>. As a second result, <code class="literal">string.gsub</code> returns the number of substitutions done (<code class="literal">4</code> in this case).<a id="IDX-CHP-5-0086" class="indexterm"></a></p><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">gsub</code> stands for global substitute. It's global because all matches are replaced, not just the first one.</p></blockquote></div><p>If there are no matches, then no substitutions are done, meaning that <code class="literal">string.gsub</code> returns the subject and <code class="literal">0</code>. Here's an example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("A shrew in Kew glues newbies to a pew.",</code></strong>
&gt;&gt;   <strong class="userinput"><code>"ai", "oy"))</code></strong>
A shrew in Kew glues newbies to a pew. 0</pre><p>If a fourth argument is given, then at most that many substitutions are done (starting from the beginning of the string), like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "The rain in Spain stays mainly in the plain."</code></strong>
&gt; <strong class="userinput"><code>print(string.gsub(Str, "ai", "oy", 2))</code></strong>
The royn in Spoyn stays mainly in the plain.    2
&gt; <strong class="userinput"><code>print(string.gsub(Str, "ai", "oy", 999))</code></strong>
The royn in Spoyn stays moynly in the ployn.    4</pre><p>The replacement string can be a different length than the pattern, as shown here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub(Str, "ai", "izzai"))</code></strong>
The rizzain in Spizzain stays mizzainly in the plizzain.   4</pre><p>In particular, replacing matches with the empty string deletes them. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub(Str, "ai", ""))</code></strong>
The rn in Spn stays mnly in the pln.    4</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="matching_any_of_several_characters"></a>Matching Any of Several Characters</h2></div></div></div><p>How often have you been buying something online and seen a message like "when entering credit card number, please enter only numbers without spaces or dashes"? This is <span class="emphasis"><em>bad programming</em></span>—a user should be able to enter their credit card number with separators, so they can more easily double-check it. It takes only a few lines of code to allow this and still make sure the user didn't type in something that obviously isn't a credit card number.</p><div class="sidebar"><a id="try_it_out_colon_validating_credit_card"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Validating Credit Card Numbers</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Define the following function:<a id="IDX-CHP-5-0087" class="indexterm"></a><a id="IDX-CHP-5-0088" class="indexterm"></a><a id="IDX-CHP-5-0089" class="indexterm"></a></p><pre class="programlisting">-- Returns Str without any whitespace or separators, or nil
-- if Str doesn't satisfy a simple validity test:
function ValidateCreditCard(Str)
   Str = string.gsub(Str, "[ /,.-]", "")
   return string.find(Str, "^%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d$")
      and Str
end</pre></li><li class="listitem"><p>Test it out like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(ValidateCreditCard("1234123412341234"))</code></strong>
1234123412341234
&gt; <strong class="userinput"><code>print(ValidateCreditCard("1234 1234 1234 1234"))</code></strong>
1234123412341234
&gt; <strong class="userinput"><code>print(ValidateCreditCard("1234-1234-1234-1234"))</code></strong>
1234123412341234
&gt; <strong class="userinput"><code>print(ValidateCreditCard("1234-1234-1234-123"))</code></strong>
nil
&gt; <strong class="userinput"><code>print(ValidateCreditCard("221B Baker Street"))</code></strong>
nil</pre></li></ol></div><p><span class="strong"><strong>How It Works</strong></span></p><p>This example introduces several new concepts. The first one is that a pattern can include <span class="emphasis"><em>bracket classes</em></span>, which are lists of characters enclosed by square brackets. The bracket class <code class="literal">[ /,.-]</code> matches a character if it's a space, a slash, a comma, a dot, or a dash:<a id="IDX-CHP-5-0090" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("The rain? -- the plain!", "[ /,.-]", ""))</code></strong>
Therain?theplain! 6</pre><p>The user can use any of those characters as separators, anywhere in the credit card number, and <code class="literal">string.gsub</code> will remove them, but leave intact any digits, letters, or other characters:</p><pre class="programlisting">Str = string.gsub(Str, "[ /,.-]", "")</pre><p>After separators have been removed, the string will be considered valid only if it's nothing more and nothing less than 16 digits. <code class="literal">%d</code> is shorthand for the bracket class <code class="literal">[0123456789]</code>—it matches any decimal digit:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("52 pickup", "%d", "Digit"))</code></strong>
DigitDigit pickup      2
&gt; <strong class="userinput"><code>print(string.gsub("52 pickup", "%d%d", "TwoDigits"))</code></strong>
TwoDigits pickup       1</pre><div class="blockquote"><blockquote class="blockquote"><p>Patterns can include <code class="literal">%d</code> and other combinations of the percent sign with other characters. Although they look the same, these are unrelated to <code class="literal">string.format</code> placeholders.</p></blockquote></div><p>If a pattern's first character is <code class="literal">^</code> (a caret), it means that the rest of the pattern will only match at the beginning of the subject. In this example, not only is <code class="literal">"ab"</code> contained in <code class="literal">"abc"</code>, but <code class="literal">"ab"</code> is right at the beginning of <code class="literal">"abc"</code>, so a substitution is made:<a id="IDX-CHP-5-0091" class="indexterm"></a><a id="IDX-CHP-5-0092" class="indexterm"></a><a id="IDX-CHP-5-0093" class="indexterm"></a><a id="IDX-CHP-5-0094" class="indexterm"></a><a id="IDX-CHP-5-0095" class="indexterm"></a><a id="IDX-CHP-5-0096" class="indexterm"></a><a id="IDX-CHP-5-0097" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("abc", "^ab", "XX"))</code></strong>
XXc     1</pre><p>In the next example, <code class="literal">"bc"</code> is contained in <code class="literal">"abc"</code>, but it's not right at the beginning, so no substitution is made:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("abc", "^bc", "XX"))</code></strong>
abc     0</pre><p>The caret is said to <span class="emphasis"><em>anchor</em></span> the pattern at the beginning. A pattern is anchored at the end if it ends with <code class="literal">$</code> (a dollar sign):</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("abc", "ab$", "XX"))</code></strong>
abc     0
&gt; <strong class="userinput"><code>print(string.gsub("abc", "bc$", "XX"))</code></strong>
aXX     1</pre><p>So the pattern <code class="literal">"^%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d$"</code>, anchored both at the beginning and the end, matches a subject only if it contains 16 digits and nothing else.</p><p>The function <code class="literal">string.find</code> returns the positions of the first and last character of the <span class="emphasis"><em>first</em></span> match, or <code class="literal">nil</code> if there is no match:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.find("duck duck goose", "duck"))</code></strong>
1       4
&gt; <strong class="userinput"><code>print(string.find("duck duck goose", "goose"))</code></strong>
11      15
&gt; <strong class="userinput"><code>print(string.find("duck duck goose", "swan"))</code></strong>
nil</pre><p><code class="literal">ValidateCreditCard</code>, however, depends only on the fact that <code class="literal">string.find</code>'s first result will be true if there's a match and <code class="literal">nil</code> if there's no match. When this result is <code class="literal">and</code>ed with <code class="literal">Str</code> itself, the effect is that the function returns <code class="literal">nil</code> if <code class="literal">Str</code> is something other than 16 digits, and <code class="literal">Str</code> if it is 16 digits:</p><pre class="programlisting">return string.find(Str, "^%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d$")
and Str</pre></div><p>Characters like <code class="literal">[, %</code>, and <code class="literal">^</code> are called <span class="emphasis"><em>magic</em></span> characters, because they have special meanings rather than representing themselves the way a standard character does (for example, "<code class="literal">a</code>"). To match a magic character, escape it with a percent sign. For example, <code class="literal">"%["</code> matches <code class="literal">"[", "%^"</code> matches <code class="literal">"^", "%%"</code> matches <code class="literal">"%"</code>, and so on, as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- If not for the extra %, this would give an error message:</code></strong>
&gt; <strong class="userinput"><code>print(string.gsub("90%, 100%, 110%", "110%%", "a lot!"))</code></strong>
90%, 100%, a lot!        1</pre><pre class="programlisting">&gt; <strong class="userinput"><code>-- If not for the %, this would replace the zero-length</code></strong>
&gt; <strong class="userinput"><code>-- string before the 3:</code></strong>
&gt; <strong class="userinput"><code>print(string.gsub("3^10", "%^", " to the power of "))</code></strong>
3 to the power of 10 1</pre><p>All magic characters are punctuation characters. This means that nonpunctuation characters—including letters, digits, whitespace, and control characters—always represent themselves and don't need to be percent-escaped.<a id="IDX-CHP-5-0098" class="indexterm"></a><a id="IDX-CHP-5-0099" class="indexterm"></a><a id="IDX-CHP-5-0100" class="indexterm"></a><a id="IDX-CHP-5-0101" class="indexterm"></a><a id="IDX-CHP-5-0102" class="indexterm"></a><a id="IDX-CHP-5-0103" class="indexterm"></a><a id="IDX-CHP-5-0104" class="indexterm"></a></p><p>Backslash-escaping is decoded when a chunk is compiled, so the pattern-matching functions don't even know about it. The pattern <code class="literal">"\\"</code> contains only one character (the backslash), which it matches. If you have trouble separating percent-escaping and backslash-escaping in your mind, you can quote the troublesome pattern with square brackets: <code class="literal">[[\]]</code>.</p><p>Not all punctuation characters are magic, but a punctuation character (or any nonalphanumeric character) escaped by a percent sign always represents itself, whether it's normally magic or not. In the following example, both <code class="literal">"@"</code> and <code class="literal">"%@"</code> match the at-sign, which is not magic:<a id="IDX-CHP-5-0105" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("somebody@example.com", "@", " AT "))</code></strong>
somebody AT example.com 1
&gt; <strong class="userinput"><code>print(string.gsub("somebody@example.com", "%@", " AT "))</code></strong>
somebody AT example.com 1</pre><p>The reasoning behind this is that anytime you want to match a punctuation character, you don't have to remember whether it's magic or not, you can just go ahead and escape it. This also applies to characters that are only magic in certain contexts. For example, the dollar sign has its magic anchoring meaning only at the very end of a pattern, and anywhere else it represents itself, but rather than thinking about that, you can feel free to escape it wherever it occurs if you don't want it to be magic. Here's how:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("I have $5.", "$%d", "some money"))</code></strong>
I have some money. 1
&gt; <strong class="userinput"><code>print(string.gsub("I have $5.", "%$%d", "some money"))</code></strong>
I have some money. 1</pre><p>The individual units of a pattern are called <span class="emphasis"><em>pattern items</em></span>. Pattern items that produce matches that are one character in length are called <span class="emphasis"><em>character classes</em></span>. Some character classes are themselves one character long ("<code class="literal">a</code>"), and some are longer ("<code class="literal">%d</code>", "<code class="literal">[ /,.-]</code>").<a id="IDX-CHP-5-0106" class="indexterm"></a><a id="IDX-CHP-5-0107" class="indexterm"></a></p><p>In addition to character classes, you've seen pattern items with zero-character matches ("<code class="literal">^</code>" and "<code class="literal">$</code>"). In the next section, you'll see how to make pattern items whose matches are longer than one character. All this complexity can make it hard to decode patterns, but a useful technique is to write them down on scratch paper and break them into their elements. For example, you could diagram the <code class="literal">"p[aeiou]t"</code> pattern as shown in <a class="link" href="ch05.html#figure_5-1" title="Figure 5.1. Figure 5-1">Figure 5-1</a>.</p><p>If it wasn't obvious from the pattern itself, it's easy to see from this diagram that <code class="literal">"p[aeiou]t"</code> will match any of the character sequences "pat," "pet," "pit," "pot," and "put" (wherever they may occur in the subject, because there's no anchoring).<a id="IDX-CHP-5-0108" class="indexterm"></a><a id="IDX-CHP-5-0109" class="indexterm"></a><a id="IDX-CHP-5-0110" class="indexterm"></a><a id="IDX-CHP-5-0111" class="indexterm"></a></p><div class="figure"><a id="figure_5-1"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0501.png" height="437" alt="Figure 5-1" width="689"></div></div><p class="title"><strong>Figure 5.1. Figure 5-1</strong></p></div><p>Bracket classes have a few other features. One is that you can specify a <span class="emphasis"><em>range</em></span> of characters, with the lowest character in the range followed by a <code class="literal">-</code> (hyphen) character and the highest character in the range (with "lowest" and "highest" being defined in terms of <code class="literal">string.byte</code>). In the following example, <code class="literal">"[0-4]"</code> is equivalent to <code class="literal">"[01234]"</code>, and <code class="literal">"[a-e]"</code> is equivalent to <code class="literal">"[abcde</code>]":</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("0123456789", "[0-4]", "n"))</code></strong>
nnnnn56789 5
&gt; <strong class="userinput"><code>Str = "the quick brown fox jumps over the lazy dog"</code></strong>
&gt; <strong class="userinput"><code>print(string.gsub(Str, "[a-e]", "!"))</code></strong>
th! qui!k !rown fox jumps ov!r th! l!zy !og 7</pre><p>Actually, although <code class="literal">"[0-9]"</code> is guaranteed to match all and only the decimal digits, the meaning of other ranges is dependent on your system's character set. Chances are, however, that your system uses the ASCII character set or some superset of it, so that <code class="literal">"[a-z]"</code> matches all and only the 26 lowercase letters of the English alphabet, and <code class="literal">"[A-Z]"</code> matches the 26 uppercase letters. This will be assumed in the examples.</p><p>Because the hyphen has a magic meaning inside bracket classes, it generally needs to be escaped to be included in a bracket class: <code class="literal">"[a%-z]"</code> matches the letter <code class="literal">a</code>, the hyphen, and the letter <code class="literal">z</code>. The only reason that you didn't need to escape the hyphen in <code class="literal">"[ /,.-]"</code> (from the <code class="literal">ValidateCreditCard</code> example) because it did not have a character to its right, so it was in a nonmagical position. Alternatively, you could have written that bracket class as <code class="literal">"[ /,.%-]"</code>.</p><p>You can combine ranges with other ranges, and with other things in a bracket class. <code class="literal">"[a-emnv-z]"</code> matches the letters <code class="literal">a</code> through <code class="literal">e</code>, the letters <code class="literal">m</code> and <code class="literal">n</code>, and the letters <code class="literal">v</code> through <code class="literal">z</code>.<a id="IDX-CHP-5-0112" class="indexterm"></a></p><p>If a bracket class starts with <code class="literal">^</code> (a caret), it matches all characters that would <span class="emphasis"><em>not</em></span> be matched without the caret. <code class="literal">"[aeiou]"</code> matches all vowels, so <code class="literal">"[^aeiou]"</code> matches any character that <span class="emphasis"><em>isn't</em></span> a vowel in the following example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "the quick brown fox jumps over the lazy dog"</code></strong>
&gt; <strong class="userinput"><code>print(string.gsub(Str, "[^aeiou]", ""))</code></strong>
euioouoeeao     32</pre><p>There are other character classes that, like <code class="literal">"%d"</code>, use a percent sign followed by a letter and match some predefined category of characters. A complete list is provided later in the chapter, but here is an example that uses "<code class="literal">%a</code>" (letters), "<code class="literal">%u</code>" (uppercase letters), and "<code class="literal">%l</code>" (lowercase letters):</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "abc Abc aBc abC ABc AbC aBC ABC"</code></strong>
&gt; <strong class="userinput"><code>print(string.gsub(Str, "%u%l%l", "Xxx"))</code></strong>
abc Xxx aBc abC ABc AbC aBC ABC 1
&gt; <strong class="userinput"><code>print(string.gsub(Str, "%a%a%a", "!!!"))</code></strong>
!!! !!! !!! !!! !!! !!! !!! !!! 8</pre><p>Just as <code class="literal">"%d"</code> is another way of writing <code class="literal">"[0-9]", "%l"</code> is another way of writing <code class="literal">"[a-z]"</code> and <code class="literal">"%a"</code> is another way of writing <code class="literal">"[A-Za-z]"</code>. Unlike bracket classes, which are based on your system's character set, character classes like <code class="literal">"%a"</code> are based on your system's locale settings, so they may give different results with non-English characters.</p><p>Unfortunately, a full explanation of locales and other character-encoding issues is outside the scope of this book, but the following example (which may not work as-is on your system) shows that the <code class="literal">%a</code> character class and the <code class="literal">string.upper</code> function use the current locale. The example uses the <code class="literal">os.setlocale</code> function to manipulate the <code class="literal">ctype</code> locale setting, which governs the categorization of characters:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- Change the ctype (character type) locale, saving the</code></strong>
&gt; <strong class="userinput"><code>-- current one:</code></strong>
&gt; <strong class="userinput"><code>OrigCtype = os.setlocale(nil, ctype)</code></strong>
&gt; <strong class="userinput"><code>print(OrigCtype)</code></strong>
C
&gt; <strong class="userinput"><code>-- Set the ctype locale to Brazilian Portuguese:</code></strong>
&gt; <strong class="userinput"><code>print(os.setlocale("pt_BR", "ctype"))</code></strong>
pt_BR
&gt; <strong class="userinput"><code>-- Test [A-Za-z] versus %a:</code></strong>
&gt; <strong class="userinput"><code>Str = "Pontif\237cia Universidade Cat\243lica do Rio de Janeiro"</code></strong>
&gt; <strong class="userinput"><code>print(Str)</code></strong>
Pontifícia Universidade Católica do Rio de Janeiro
&gt; <strong class="userinput"><code>print(string.gsub(Str, "[A-Za-z]", "."))</code></strong>
......í... ............ ...ó.... .. ... .. .......            42
&gt; <strong class="userinput"><code>print(string.gsub(Str, "%a", "."))</code></strong>
.......... ............ ........ .. ... .. .......            44
&gt; <strong class="userinput"><code>-- Also test string.upper:</code></strong>
&gt; <strong class="userinput"><code>print(string.upper(Str))</code></strong>
PONTIFíCIA UNIVERSIDADE CATÓLICA DO RIO DE JANEIRO</pre><pre class="programlisting">&gt; <strong class="userinput"><code>-- Go back to the original ctype locale:</code></strong>
&gt; <strong class="userinput"><code>print(os.setlocale(OrigCtype, "ctype"))</code></strong>
C
&gt; <strong class="userinput"><code>-- Test string.upper again, with the original ctype locale</code></strong>
&gt; <strong class="userinput"><code>-- which, being "C", will not recognize the non-English</code></strong>
&gt; <strong class="userinput"><code>-- characters:</code></strong>
&gt; <strong class="userinput"><code>print(string.upper(Str))</code></strong>
PONTIFíCIA UNIVERSIDADE CATóLICA DO RIO DE JANEIRO</pre><div class="blockquote"><blockquote class="blockquote"><p>Locales use 8-bit character encodings, where each character is one byte. A more flexible encoding system is Unicode. In Unicode's UTF-8 format, ASCII characters ("regular" characters) are one byte long and other characters are two or more bytes. Lua has no built-in support for Unicode (for example, it measures string length in bytes), but it does nothing to prevent you from using Unicode. In UTF-8, the character <code class="literal">í</code> happens to be represented as <code class="literal">"\195\173"</code>, so if the string <code class="literal">"Pontif\195\173cia"</code> is written to a file, and that file is opened with a text editor that reads it as UTF-8, then the editor will show "<code class="literal">Pontifícia</code>."<a id="IDX-CHP-5-0113" class="indexterm"></a><a id="IDX-CHP-5-0114" class="indexterm"></a><a id="IDX-CHP-5-0115" class="indexterm"></a><a id="IDX-CHP-5-0116" class="indexterm"></a><a id="IDX-CHP-5-0117" class="indexterm"></a><a id="IDX-CHP-5-0118" class="indexterm"></a><a id="IDX-CHP-5-0119" class="indexterm"></a><a id="IDX-CHP-5-0120" class="indexterm"></a><a id="IDX-CHP-5-0121" class="indexterm"></a></p><p>To do more complicated things with Unicode and other character encodings, try the Selene Unicode library (<code class="literal">slnunicode</code>), available at <code class="literal">luaforge.net</code>. For more information on Unicode and other character encoding issues, check out the Joel Spolsky article at <code class="systemitem">joelonsoftware.com/articles/Unicode.html</code>.<a id="IDX-CHP-5-0122" class="indexterm"></a></p></blockquote></div><p><code class="literal">"%D"</code> matches any character that isn't a digit, <code class="literal">"%L"</code> matches any character that isn't a lowercase letter, and "%A" matches any character that isn't alphabetical. In fact, any pattern item that is a percent sign followed by a lowercase letter has a counterpart with an uppercase letter that matches all the characters not matched by the lowercase version.</p><p>Any character class that isn't itself a bracket class can be included in a bracket class. This includes character classes like "<code class="literal">%d</code>" and "<code class="literal">%a</code>"; both <code class="literal">"[%d.]"</code> and <code class="literal">"[0-9.]"</code> match digits and decimal points. However, the two endpoints of a hyphen-separated range must be single characters (representing themselves), not longer character classes like <code class="literal">"%d", "%a", "%%"</code>, or <code class="literal">"%]"</code>.</p><p>The only characters that are magic inside a bracket class are <code class="literal">"-", "^", "]"</code>, and <code class="literal">"%"</code>, and of these, only <code class="literal">"%"</code> is magic in all positions. But unless it's the endpoint of a range, a punctuation character can be escaped even when that's not strictly necessary, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("!@#$%^&amp;*", "[%!%@%#%$]", "."))</code></strong>
....%^&amp;*       4</pre><p>As with patterns as a whole, you can understand complex bracket classes better if you diagram them. Often, all you need to do is show how the parts are divided up. For example, <a class="link" href="ch05.html#figure_5-2" title="Figure 5.2. Figure 5-2">Figure 5-2</a> is a diagram of <code class="literal">"[aq-z%]%d]"</code>—it makes clear that the characters matched are the letter <code class="literal">a</code>, the letters <code class="literal">q</code> through <code class="literal">z</code>, the <code class="literal">]</code> character, and all digits.</p><div class="figure"><a id="figure_5-2"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0502.png" height="53" alt="Figure 5-2" width="279"></div></div><p class="title"><strong>Figure 5.2. Figure 5-2</strong></p></div><p>To match any character at all, including whitespace and control characters, use the <code class="literal">.</code> (dot) character class. Here are some examples:<a id="IDX-CHP-5-0123" class="indexterm"></a><a id="IDX-CHP-5-0124" class="indexterm"></a><a id="IDX-CHP-5-0125" class="indexterm"></a><a id="IDX-CHP-5-0126" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.find("abc", "a.c"))</code></strong>
1       3
&gt; <strong class="userinput"><code>print(string.find("a c", "a.c"))</code></strong>
1       3
&gt; <strong class="userinput"><code>print(string.find("a!c", "a.c"))</code></strong>
1       3
&gt; <strong class="userinput"><code>print(string.find("a\0c", "a.c"))</code></strong>
1       3
&gt; <strong class="userinput"><code>-- It matches one and only one character:</code></strong>
&gt; <strong class="userinput"><code>print(string.find("abbc", "a.c"))</code></strong>
nil
&gt; <strong class="userinput"><code>print(string.find("ac", "a.c"))</code></strong>
nil</pre><p>A pattern cannot contain the character <code class="literal">"\0"</code>. To match a zero, use <code class="literal">"%z"</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("a\0b\0c", "%z", "Z"))</code></strong>
aZbZc    2</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="matches_of_varying_lengths"></a>Matches of Varying Lengths</h2></div></div></div><p>In the previous section, you could always tell just by looking at a pattern how long its match would be. Many patterns need to match varying quantities of characters. An example of this is <span class="emphasis"><em>squeezing</em></span> whitespace, which turns all runs of one or more whitespace characters into a single space.<a id="IDX-CHP-5-0127" class="indexterm"></a></p><div class="sidebar"><a id="try_it_out_colon_squeezing_whitespace"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Squeezing Whitespace</strong></p></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Define the following function:</p><pre class="programlisting">-- Squeezes whitespace:
function Squeeze(Str)
  return (string.gsub(Str, "%s+", " "))
end</pre></li><li class="listitem"><p>Run this test code:</p><pre class="programlisting">TestStrs = {
   "nospaces",
   "alpha bravo charlie",
   " alpha bravo charlie ",
   "\nalpha\tbravo\tcharlie\na\tb\tc",
   [[
     alpha
     bravo
     charlie]]}
 for _, TestStr in ipairs(TestStrs) do
   io.write("UNSQUEEZED: &lt;", TestStr, "&gt;\n")
   io.write(" SQUEEZED: &lt;", Squeeze(TestStr), "&gt;\n\n")
 end</pre></li></ol></div><p>The output should be as follows:<a id="IDX-CHP-5-0128" class="indexterm"></a><a id="IDX-CHP-5-0129" class="indexterm"></a><a id="IDX-CHP-5-0130" class="indexterm"></a><a id="IDX-CHP-5-0131" class="indexterm"></a></p><pre class="programlisting">UNSQUEEZED: &lt;nospaces&gt;
SQUEEZED: &lt;nospaces&gt;

UNSQUEEZED: &lt;alpha bravo charlie&gt;
  SQUEEZED: &lt;alpha bravo charlie&gt;

UNSQUEEZED: &lt; alpha bravo charlie &gt;
  SQUEEZED: &lt; alpha bravo charlie &gt;

UNSQUEEZED: &lt;
alpha   bravo    charlie
a       b        c&gt;
  SQUEEZED: &lt; alpha bravo charlie a b c&gt;

UNSQUEEZED: &lt;    alpha
    bravo
    charlie&gt;
SQUEEZED: &lt; alpha bravo charlie&gt;</pre></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-012"></a>How It Works</h3></div></div></div><p>The <code class="literal">%s</code> character class matches a whitespace character (<code class="literal">"\t", "\n", "\v", "\f", "\r"</code>, and <code class="literal">" "</code>, plus any other whitespace characters defined by your locale). A character class followed by <code class="literal">+</code> (the plus sign) is a single pattern item that matches one or more (as many as possible) of that character class. Therefore, <code class="literal">"%s+"</code> matches sequences of consecutive whitespace characters in this example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.find("abc xyz", "%s+"))</code></strong>
4       4
&gt; <strong class="userinput"><code>print(string.find("abc xyz", "%s+"))</code></strong>
4       6</pre><p>The characters do not all have to be the same, as shown here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.find("abc\n \txyz", "%s+"))</code></strong>
4       6</pre><p><code class="literal">Squeeze</code>'s <code class="literal">string.gsub</code> call replaces any such sequences with a single space. (The parentheses around the call are there to keep <code class="literal">string.gsub</code>'s second value from being returned.)</p><p><code class="literal">+</code> works with any character class. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("aaa bbb aaa ccc", "a+", "X"))</code></strong>
X bbb X ccc     2
&gt; <strong class="userinput"><code>print(string.gsub("aaa bbb aaa ccc", "[ab]+", "X"))</code></strong>
X X X ccc       3</pre><p>Matches never overlap. When <code class="literal">"a+"</code> grabs all three occurrences of <code class="literal">a</code> at the beginning of <code class="literal">"aaa bbb aaa ccc"</code>, it starts looking for the next match at the fourth character, not the second.</p><p><code class="literal">*</code> (the asterisk, or star) is similar to <code class="literal">+</code>, except it matches <span class="emphasis"><em>0 or more</em></span> characters. In the following example, <code class="literal">"^[%a_][%w_]*$"</code> matches Lua identifiers and keywords (<code class="literal">%w</code> matches "word" characters, which are letters and numbers):<a id="IDX-CHP-5-0132" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Strs = {"Str1", "_G", "function", "1st", "splunge?",</code></strong>
&gt;&gt;   <strong class="userinput"><code>"alpha bravo charlie", '"global" substitution'}</code></strong>
&gt; <strong class="userinput"><code>for _, Str in ipairs(Strs) do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(string.format("%q is %sa valid identifier or keyword",</code></strong>
&gt;&gt;      <strong class="userinput"><code>Str, string.find(Str, "^[%a_][%w_]*$") and "" or "NOT "))</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
"Str1" is a valid identifier or keyword
"_G" is a valid identifier or keyword
"function" is a valid identifier or keyword
"1st" is NOT a valid identifier or keyword
"splunge?" is NOT a valid identifier or keyword
"alpha bravo charlie" is NOT a valid identifier or keyword
"\"global\" substitution" is NOT a valid identifier or keyword</pre><p><a class="link" href="ch05.html#figure_5-3" title="Figure 5.3. Figure 5-3">Figure 5-3</a> is a diagram of "^[%a_][%w_]*$".</p><div class="figure"><a id="figure_5-3"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0503.png" width="427" alt="Figure 5-3" height="598"></div></div><p class="title"><strong>Figure 5.3. Figure 5-3</strong></p></div><p>Notice that the <code class="literal">*</code> only applies to the character class right before it. This is also true of <code class="literal">+</code>, and of <code class="literal">-</code> and <code class="literal">?</code>, the two other similar magic characters you'll soon learn.<a id="IDX-CHP-5-0133" class="indexterm"></a><a id="IDX-CHP-5-0134" class="indexterm"></a><a id="IDX-CHP-5-0135" class="indexterm"></a><a id="IDX-CHP-5-0136" class="indexterm"></a></p><div class="blockquote"><blockquote class="blockquote"><p>If you know what regular expressions are, then you've already figured out that patterns are the Lua equivalent. The limitation on what length modifiers like <code class="literal">*</code> can apply to is one of the things that keep Lua patterns from being full-fledged regular expressions, a choice that was made intentionally, to keep the string library small and simple. You can simulate most regular expression features through a clever use of Lua patterns.</p></blockquote></div><p>When <code class="literal">string.find</code> finds a zero-length match, the start and end positions it returns will be the positions of (respectively) the characters after and before the match. Generally, such a match is at the beginning of the string, so the positions are <code class="literal">1</code> and <code class="literal">0</code>. Zero-length matches can be confusing. The first of the following <code class="literal">string.finds</code> matches <code class="literal">"aa"</code>, but the second one matches the empty string at the beginning of <code class="literal">"aabb"</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.find("aabb", "a*"))</code></strong>
1       2
&gt; <strong class="userinput"><code>print(string.find("aabb", "b*"))</code></strong>
1       0</pre><p>This is because searches always start at the beginning of the subject. When the pattern is <code class="literal">"a*"</code>, Lua tries to find any occurrences of the letter <code class="literal">a</code> at the beginning of the subject string. In this example, it finds two. When the pattern is <code class="literal">"b*"</code>, Lua tries to find any occurrences of <code class="literal">b</code> at the beginning of the subject string. In this too, it succeeds, but only by finding zero <code class="literal">b</code>'s—the empty string.</p><p><code class="literal">string.find</code> finds just the first match, so only if Lua fails to find a match at the beginning of the subject does it look for one at the second character. If it fails there, it looks at the third, and so on. A <code class="literal">string.gsub</code> can replace multiple matches. Some of them may be empty strings, but none of them will overlap. Of the matches in the following example, all but the second-to-last are empty strings:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("aabb", "b*", "&lt;match&gt;"))</code></strong>
&lt;match&gt;a&lt;match&gt;a&lt;match&gt;&lt;match&gt;  4</pre><p>Sometimes a search finds substrings that look like matches but turn out not to be. For example, this function trims (removes) any whitespace from the end of a string:</p><pre class="programlisting">-- Trims trailing whitespace:
function TrimRight(Str)
  return (string.gsub(Str, "%s+$", ""))
end</pre><p>If given <code class="literal">" A B C "</code> (that's two spaces before and after each letter), the example returns <code class="literal">" A B C"</code>. Here's what <code class="literal">string.gsub</code> needs to do behind the scenes for this to work: It grabs as many whitespace characters as it can starting at character 1 of the subject. (This is two whitespace characters.) Then it checks whether it's hit the end of the subject. It hasn't, so it tries grabbing one less whitespace character for a total of one. This of course doesn't get it to the end of the subject either, and because grabbing zero whitespace characters is not an option with <code class="literal">+</code>, it gives up on finding a match at character 1 of the subject and goes through the same business at character 2. This doesn't result in a match either, so it moves on to character 3, where it can give up immediately, because character 3 is not a whitespace character. This whole process continues down the subject string until a match is finally found at character 10 (right after the <code class="literal">C</code>).</p><p>In the previous example, <code class="literal">string.gsub</code> looks at some characters more than once. Character 2 gets looked at once as a continuation of a potential match at character 1, and again as the beginning of a potential match. This is called <span class="emphasis"><em>backtracking</em></span>.<a id="IDX-CHP-5-0137" class="indexterm"></a><a id="IDX-CHP-5-0138" class="indexterm"></a><a id="IDX-CHP-5-0139" class="indexterm"></a><a id="IDX-CHP-5-0140" class="indexterm"></a><a id="IDX-CHP-5-0141" class="indexterm"></a><a id="IDX-CHP-5-0142" class="indexterm"></a></p><p>By comparison, the <code class="literal">Squeeze</code> function from earlier in this chapter had a <code class="literal">string.gsub</code> that used the same pattern except without the <code class="literal">$</code> anchor. Given the same subject string, it would grab as many whitespace characters as it could starting at character 1, and because this would be a match, it could immediately jump to character 3. It knows just by looking at each character in the subject whether that character is the start of a match or not, and it also doesn't have to backtrack to see how long the match is.</p><p>If a pattern match seems to be a slow spot in your program, try to rewrite it to reduce or eliminate backtracking. The version of <code class="literal">TrimRight</code> given earlier is fine for short strings, but it will be noticeably slow if used to trim a sufficiently long string (perhaps read in from a file) with lots of runs of consecutive whitespace in it. There are a few ways to write <code class="literal">TrimRight</code> to avoid backtracking. One is to look at as many characters of the string as necessary, starting at the end and working towards the beginning, like this:</p><pre class="programlisting">-- Trims trailing whitespace:
function TrimRight(Str)
  -- By searching from the end backwards, find the position
  -- of the last nonwhitespace character:
  local I = #Str
  while I &gt; 0 and string.find(string.sub(Str, I, I), "%s") do
    I = I - 1
  end
  return string.sub(Str, 1, I)
end</pre><p>The <code class="literal">-</code> (hyphen or minus sign) is just like <code class="literal">*</code> except that <code class="literal">*</code> matches as many characters as possible, and <code class="literal">-</code> matches as few as possible. Both the patterns in the following example match two vertical bar characters and the characters in between them, but the first one finds the biggest match it can, whereas the second finds the smallest it can:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.find("|abc|def|", "%|.*%|"))</code></strong>
1       9
&gt; <strong class="userinput"><code>print(string.find("|abc|def|", "%|.-%|"))</code></strong>
1       5</pre><p>Because <code class="literal">*</code> and <code class="literal">+</code> match as many characters as possible, they are called <span class="emphasis"><em>greedy</em></span>. In contrast, <code class="literal">-</code> is called <span class="emphasis"><em>nongreedy</em></span>.</p><p><code class="literal">string.find</code> always finds the first match in the subject, no matter whether greedy or nongreedy matching is used. In the following example, both the greedy pattern and the nongreedy matches find <code class="literal">"&lt;lengthy&gt;"</code>, even though <code class="literal">"&lt;short&gt;"</code> has less characters:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "blah&lt;lengthy&gt;blah&lt;short&gt;blah"</code></strong>
&gt; <strong class="userinput"><code>print(string.find(Str, "%&lt;%a*%&gt;"))</code></strong>
5       13
&gt; <strong class="userinput"><code>print(string.find(Str, "%&lt;%a-%&gt;"))</code></strong>
5       13</pre><p>Also, the greedy/nongreedy distinction controls <span class="emphasis"><em>how long</em></span> a match will be, but not <span class="emphasis"><em>whether</em></span> a match will be found. If <code class="literal">*</code> finds a match, then <code class="literal">-</code> will find one too, and vice versa.<a id="IDX-CHP-5-0143" class="indexterm"></a><a id="IDX-CHP-5-0144" class="indexterm"></a><a id="IDX-CHP-5-0145" class="indexterm"></a><a id="IDX-CHP-5-0146" class="indexterm"></a><a id="IDX-CHP-5-0147" class="indexterm"></a><a id="IDX-CHP-5-0148" class="indexterm"></a></p><p>A character class followed by <code class="literal">?</code> (a question mark) matches zero or one of that character class. In the following example, this is used to match either <code class="literal">"Mr"</code> or <code class="literal">"Mr."</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("Mr. Smith and Mr Smythe", "Mr%.?", "Mister"))</code></strong>
Mister Smith and Mister Smythe 2</pre><p><code class="literal">?</code> is greedy in this example—it matched the dot in <code class="literal">"Mr."</code> even though nothing after it forced it to.</p><p><code class="literal">*, +, -</code>, and <code class="literal">?</code> are all of the magic characters used to control the length of a match. Here's a summary:<a id="IDX-CHP-5-0149" class="indexterm"></a></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"><col class="col2"></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>To Match</p></th><th style="text-align: left" valign="bottom"><p>Do</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>Exactly one character</p></td><td style="text-align: left" valign="top"><p>Use a character class by itself</p></td></tr><tr><td style="text-align: left" valign="top"><p>Exactly <span class="emphasis"><em>n</em></span> characters</p></td><td style="text-align: left" valign="top"><p>Use <span class="emphasis"><em>n</em></span> character classes in a row</p></td></tr><tr><td style="text-align: left" valign="top"><p>Zero or more characters, as many as possible</p></td><td style="text-align: left" valign="top"><p>Follow the character class with <code class="literal">*</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>One or more characters, as many as possible</p></td><td style="text-align: left" valign="top"><p>Follow the character class with <code class="literal">+</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>Zero or more characters, as few as possible</p></td><td style="text-align: left" valign="top"><p>Follow the character class with <code class="literal">-</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>Zero or one characters, as many as possible</p></td><td style="text-align: left" valign="top"><p>Follow the character class with <code class="literal">?</code></p></td></tr></tbody></table></div><p>These magic characters can be combined for other match lengths. For example, <code class="literal">"%a%a%a%a?%a?%a?"</code> matches three to six letters, and <code class="literal">"%a%a%a%a*"</code> matches three or more letters.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="captures"></a>Captures</h2></div></div></div><p>Selected parts of a match can be <span class="emphasis"><em>captured</em></span>, which means they can be separated from the rest of the match. This allows one pattern to do the work of several.</p><p>The <code class="literal">FriendlyDate</code> function used in following example takes a date formatted as <code class="literal">yyyy-mm-dd</code>; captures that date's year, month, and day; and returns the same date in a more user-friendly format. First, define the <code class="literal">FriendlyDate</code> helper function, <code class="literal">Ordinal</code>, and <code class="literal">FriendlyDate</code> itself, like this:<a id="IDX-CHP-5-0150" class="indexterm"></a></p><pre class="programlisting">-- Returns the ordinal form of N:
function Ordinal(N)
   N = tonumber(N)
   local Terminator = "th"
   assert(N &gt; 0, "Ordinal only accepts positive numbers")
   assert(math.floor(N) == N, "Ordinal only accepts integers")
   if string.sub(N, −2, −2) ~= "1" then
     local LastDigit = N % 10
     if LastDigit == 1 then
       Terminator = "st"
     elseif LastDigit == 2 then
       Terminator = "nd"</pre><pre class="programlisting">elseif LastDigit == 3 then
       Terminator = "rd"
    end
  end
  return N .. Terminator
end

-- Returns a user-friendly version of a date string.  (Assumes
-- its argument is a valid date formatted yyyy-mm-dd.)
function FriendlyDate(DateStr)
  local Year, Month, Day = string.match(DateStr,
    "^(%d%d%d%d)%-(%d%d)%-(%d%d)$")
  Month = ({"January", "February", "March", "April", "May",
    "June", "July", "August", "September", "October",
    "November", "December"})[tonumber(Month)]
  return Month .. " " .. Ordinal(Day) .. ", " .. Year
end</pre><p>Then try it out like this:<a id="IDX-CHP-5-0151" class="indexterm"></a><a id="IDX-CHP-5-0152" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>print(FriendlyDate("1964-02-09"))</code></strong>
February 9th, 1964
&gt; <strong class="userinput"><code>print(FriendlyDate("2007-07-13"))</code></strong>
July 13th, 2007
&gt; <strong class="userinput"><code>-- FriendlyDate assumes its argument is valid. It complains</code></strong>
&gt; <strong class="userinput"><code>-- about some invalid arguments, but not all of them:</code></strong>
&gt; <strong class="userinput"><code>print(FriendlyDate("9999-99-99"))</code></strong>
stdin:7: attempt to concatenate local 'Month' (a nil value)
stack traceback:
        stdin:7: in function 'FriendlyDate'
        stdin:1: in main chunk
        [C]: ?
&gt; <strong class="userinput"><code>print(FriendlyDate("0000-12-99"))</code></strong>
December 99th, 0000</pre><p>Parentheses within a pattern are used to capture parts of the match. The <code class="literal">string.match</code> function returns all captures from the first match it finds, or <code class="literal">nil</code> if no match is found:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Pat = "(%a)(%a*)"</code></strong>
&gt; <strong class="userinput"><code>print(string.match("123 alpha bravo charlie", Pat))</code></strong>
a       lpha
&gt; <strong class="userinput"><code>print(string.match("123", Pat))</code></strong>
nil</pre><p>In <code class="literal">FriendlyDate</code>, the pattern given to <code class="literal">string.match</code> captures the year, month, and day, which will be <code class="literal">nil</code> if <code class="literal">DateStr</code> is incorrectly formatted, as shown here:</p><pre class="programlisting">-- Returns a user-friendly version of a date string. (Assumes
-- its argument is a valid date formatted yyyy-mm-dd.)
function FriendlyDate(DateStr)
  local Year, Month, Day = string.match(DateStr,
    "^(%d%d%d%d)%-(%d%d)%-(%d%d)$")
  Month = ({"January", "February", "March", "April", "May",</pre><pre class="programlisting">"June", "July", "August", "September", "October",
    "November", "December"})[tonumber(Month)]
  return Month .. " " .. Ordinal(Day) .. ", " .. Year
end</pre><p>After the year, month, and day are in hand, it's just a matter of turning the month from a number to a name, and turning the date from, e.g., <code class="literal">"01"</code> to <code class="literal">"1st"</code>.<a id="IDX-CHP-5-0153" class="indexterm"></a><a id="IDX-CHP-5-0154" class="indexterm"></a><a id="IDX-CHP-5-0155" class="indexterm"></a><a id="IDX-CHP-5-0156" class="indexterm"></a><a id="IDX-CHP-5-0157" class="indexterm"></a><a id="IDX-CHP-5-0158" class="indexterm"></a><a id="IDX-CHP-5-0159" class="indexterm"></a><a id="IDX-CHP-5-0160" class="indexterm"></a><a id="IDX-CHP-5-0161" class="indexterm"></a></p><p><code class="literal">string.find</code> also returns any captures, after its first two return values. For example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.find("123 alpha bravo charlie", "(%a)(%a*)"))</code></strong>
5       9       a       lpha</pre><div class="blockquote"><blockquote class="blockquote"><p>Lua 5.0 didn't have <code class="literal">string.match</code>. In its place, use <code class="literal">string.find</code> (ignoring its first two return values).</p></blockquote></div><p>If <code class="literal">string.match</code> is given a pattern with no captures, it returns the entire (first) match like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.match("123 alpha bravo charlie", "%a+"))</code></strong>
alpha</pre><p>If one capture contains another, they are ordered according to the position of the first parenthesis like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.match("abcd", "(((%a)(%a))((%a)(%a)))"))</code></strong>
abcd     ab      a      b      cd      c      d</pre><p>If <code class="literal">()</code> is used as a capture, then the position in the subject is captured—more specifically, the position of the next character. The position at the end of a pattern is the length of the subject plus one, as shown here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.match("abcd", "()(%a+)()"))</code></strong>
1        abcd        5</pre><p>A position capture is a number, such as the following:<a id="IDX-CHP-5-0162" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>print(type(string.match("abcd", "ab()cd")))</code></strong>
number</pre><p>All other captures are strings, although they may look like numbers or be empty strings, as shown in the following example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(type(string.match("1234", "(%d+)")))</code></strong>
string
&gt; <strong class="userinput"><code>print(string.match("1234", "(%a*)") == "")</code></strong>
true</pre><p>A <code class="literal">*, +, -</code>, or <code class="literal">?</code> character must be directly after its character class, with no intervening capture parentheses. Similarly, a <code class="literal">^</code> or <code class="literal">$</code> anchor character must be the very first or last character in its pattern. In the current implementation of Lua, the patterns <code class="literal">"(%a)*"</code> and <code class="literal">"(^%a)"</code> are both valid, but they have different meanings then you might expect. <code class="literal">"(%a)*"</code> means "capture a letter that is followed by a star" in the following example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.match("ab*cd", "(%a)*"))</code></strong>
b</pre><p>And <code class="literal">"(^%a)"</code> means "capture a caret and a letter" here:<a id="IDX-CHP-5-0163" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.match("a^z", "(^%a)"))</code></strong>
^z</pre><p>The equivalent patterns that give the star and the caret their magic meanings are <code class="literal">"(%a*)"</code> and <code class="literal">"^(%a)"</code> in the following example::</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.match("ab*cd", "(%a*)"))</code></strong>
ab
&gt; <strong class="userinput"><code>print(string.match("a^z", "^(%a)"))</code></strong>
a</pre><p>A percent followed by <code class="literal">1</code> through <code class="literal">9</code> represents that capture, so <code class="literal">%1</code> is the first capture. This means that in the following example, <code class="literal">"(%a+) %1"</code> matches two consecutive identical words separated by a space (the pattern translates to "match and capture a word, match a space, match the first capture"):</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub("Paris in the the spring",</code></strong>
&gt;&gt;   <strong class="userinput"><code>"(%a+) %1", "WORD WORD"))</code></strong>
Paris in WORD WORD spring 1</pre><p>A capture used within the pattern that captured it is said to be <span class="emphasis"><em>replayed</em></span>. You cannot replay a capture inside itself, because this would cause an infinite regress. If you try to do so, you get the following error:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.match("blah", "(%1)"))</code></strong>
stdin:1: invalid capture index
stack traceback:
        [C]: in function 'match'
        stdin:1: in main chunk
        [C]: ?</pre><p>You can also access captures within a <code class="literal">string.gsub</code> replacement string. For example (<code class="literal">%%</code> represents a literal percent sign):<a id="IDX-CHP-5-0164" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Percents = "90 percent, 100 percent, 110 percent"</code></strong>
&gt; <strong class="userinput"><code>print(string.gsub(Percents, "(%d+) percent", "%1%%"))</code></strong>
90%,  100%,  110% 3</pre><p>In a replacement string, <code class="literal">%0</code> stands for the whole match, as in this example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "alpha, bravo, charlie"</code></strong>
&gt; <strong class="userinput"><code>print(string.gsub(Str, "%a+", "&lt;%0&gt;"))</code></strong>
&lt;alpha&gt;, &lt;bravo&gt;, &lt;charlie&gt;      3</pre><div class="blockquote"><blockquote class="blockquote"><p>Lua 5.0 didn't understand <code class="literal">%0</code>. The whole match, if desired, had to be explicitly captured.</p></blockquote></div><p>Because percent signs are magic in replacement strings, any replacement string supplied by a user or otherwise generated at run time must be percent-escaped automatically, like so:</p><pre class="programlisting">Str = string.gsub(Str, "%%", "%%%%")</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="matching_balanced_delimiters"></a>Matching Balanced Delimiters</h2></div></div></div><p>Parentheses, curly braces, and square brackets, as used in Lua, are examples of <span class="emphasis"><em>delimiters</em></span>, because they mark the beginning and end of whatever they surround. You use them in pairs, so that each open delimiter has a corresponding close delimiter. Delimiters that are paired in this way are said to be <span class="emphasis"><em>balanced</em></span>, and Lua offers a pattern item that matches them. This pattern item is four characters long: the first two characters are "<code class="literal">%b</code>", and the next two are the open delimiter and the close delimiter. For example, <code class="literal">"%b()"</code> matches balanced parentheses, <code class="literal">"%b{}"</code> matches balanced curly braces, and <code class="literal">"%b[]"</code> matches balanced square brackets. The two characters after <code class="literal">%b</code> always represent themselves—any magic meaning they might have is ignored.<a id="IDX-CHP-5-0165" class="indexterm"></a><a id="IDX-CHP-5-0166" class="indexterm"></a><a id="IDX-CHP-5-0167" class="indexterm"></a><a id="IDX-CHP-5-0168" class="indexterm"></a><a id="IDX-CHP-5-0169" class="indexterm"></a><a id="IDX-CHP-5-0170" class="indexterm"></a><a id="IDX-CHP-5-0171" class="indexterm"></a><a id="IDX-CHP-5-0172" class="indexterm"></a></p><p>Here's an example that converts the two top-level pairs into <code class="literal">"balanced"</code>:</p><div class="blockquote"><blockquote class="blockquote"><p>To get at the inner pairs, you'd only need to grab the top-level pairs and run <code class="literal">"%b()"</code> on them.</p></blockquote></div><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "((a b) (b c)) ((c d) (e f))"</code></strong>
&gt; <strong class="userinput"><code>print(string.gsub(Str, "%b()", "balanced"))</code></strong>
balanced balanced       2</pre><p>For comparison, here are three attempts to do this without the <code class="literal">%b</code> pattern item, where the first would work if there was only one pair of parentheses, and the second two would work if there were no nested pairs:</p><pre class="programlisting">&gt; <strong class="userinput"><code>print(string.gsub(Str, "%(.*%)", "imbalanced"))</code></strong>
imbalanced      1
&gt; <strong class="userinput"><code>print(string.gsub(Str, "%(.-%)", "imbalanced"))</code></strong>
imbalanced imbalanced) imbalanced imbalanced)   4
&gt; <strong class="userinput"><code>print(string.gsub(Str, "%([^()]*%)", "imbalanced"))</code></strong>
(imbalanced imbalanced) (imbalanced imbalanced) 4</pre><p>The <code class="literal">%b</code> delimiters can be any characters (other than <code class="literal">"\0"</code>). For example, a <code class="literal">"%b %"</code> pattern would match delimited strings that begin with a space and end with a percent sign.</p><p>A string like <code class="literal">'{"a", "}", "z"}'</code> would confuse <code class="literal">"%b{}"</code>, because it doesn't know not to treat the quoted <code class="literal">"}"</code> as a delimiter. If you run into this situation, and you can figure out which delimiter characters should be ignored, then you can use the trick of converting them to characters you know will be unused (such as <code class="literal">"\1"</code> and <code class="literal">"\2"</code>), doing the <code class="literal">%b</code> matching, and then converting them back.</p><div class="blockquote"><blockquote class="blockquote"><p>It might be easier to just arrange for the string you're looking at to be a valid Lua table constructor. To do this, you can prepend <code class="literal">"return"</code> to it, apply <code class="literal">loadstring</code> to it, give the resulting function an empty environment with <code class="literal">setfenv</code>, and call the function (using <code class="literal">pcall</code> to guard against errors, as described in the next chapter). The function's return value will be the table described by the table constructor.</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="more_on_string.find_comma_string.match_c"></a>More on string.find, string.match, and string.gsub</h2></div></div></div><p>There are a few more features of <code class="literal">string.find, string.match</code>, and <code class="literal">string.gsub</code> that need to be covered. After you learn them, you'll know everything there is to know about these functions.</p><p><code class="literal">string.find</code> and <code class="literal">string.match</code> both take a third argument, which is a number that specifyies which character of the subject to start the search at. Any matches that start before this character will be ignored. For example:<a id="IDX-CHP-5-0173" class="indexterm"></a><a id="IDX-CHP-5-0174" class="indexterm"></a><a id="IDX-CHP-5-0175" class="indexterm"></a><a id="IDX-CHP-5-0176" class="indexterm"></a><a id="IDX-CHP-5-0177" class="indexterm"></a><a id="IDX-CHP-5-0178" class="indexterm"></a><a id="IDX-CHP-5-0179" class="indexterm"></a><a id="IDX-CHP-5-0180" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Subj, Pat = "abc &lt;--&gt; xyz", "(%a+)"</code></strong>
&gt; <strong class="userinput"><code>-- Start searching at character 2 ("b"):</code></strong>
&gt; <strong class="userinput"><code>print(string.match(Subj, Pat, 2))</code></strong>
bc
&gt; <strong class="userinput"><code>-- Start searching at character 5 ("&lt;"):</code></strong>
&gt; <strong class="userinput"><code>print(string.match(Subj, Pat, 5))</code></strong>
xyz</pre><p>A caret anchors the pattern at the beginning of the search, not the beginning of the subject, as follows:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Subj, Pat = "aa ab ac", "^(a%a)"</code></strong>
&gt; <strong class="userinput"><code>-- Character 4 is an "a", so this matches:</code></strong>
&gt; <strong class="userinput"><code>print(string.match(Subj, Pat, 4))</code></strong>
ab
&gt; <strong class="userinput"><code>-- Character 5 is not an "a", so this doesn't match:</code></strong>
&gt; <strong class="userinput"><code>print(string.match(Subj, Pat, 5))</code></strong>
nil</pre><p>Returned string positions are reckoned from the beginning of the subject (not the beginning of the search) like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Subj = "aa ab ac"</code></strong>
&gt; <strong class="userinput"><code>print(string.find(Subj, "(a%a)", 6))</code></strong>
7       8       ac
&gt; <strong class="userinput"><code>print(string.match(Subj, "()(a%a)()", 6))</code></strong>
7       ac      9</pre><p>If the fourth <code class="literal">string.find</code> argument is true, it will ignore the magic meanings of characters in its second argument, treating it as a plain old string rather than a pattern:</p><div class="blockquote"><blockquote class="blockquote"><p>To give a fourth argument, you need to give a third; use <code class="literal">1</code> if you want the search to start at the beginning of the subject as usual.</p></blockquote></div><pre class="programlisting">&gt; <strong class="userinput"><code>-- Both of these look for a caret, an "a", a percent sign,</code></strong>
&gt; <strong class="userinput"><code>-- and another "a":</code></strong>
&gt; <strong class="userinput"><code>print(string.find("characters: ^a%a", "^a%a", 1, true))</code></strong>
13      16
&gt; <strong class="userinput"><code>print(string.find("ab", "^a%a", 1, true))</code></strong>
nil</pre><p>So far, the <code class="literal">string.gsub</code> replacement argument (the third argument) has always been a string. That string can include captures, but sometimes that's not enough power to do what you want to do. For smarter replacements, the replacement argument can be a function or a table. If it's a function, it is called on each match with the match's captures as arguments, and the match is replaced with the function's return value. In the following example, the first letter and the rest of the letters of each word are captured, and the first letter is capitalized:<a id="IDX-CHP-5-0181" class="indexterm"></a><a id="IDX-CHP-5-0182" class="indexterm"></a><a id="IDX-CHP-5-0183" class="indexterm"></a><a id="IDX-CHP-5-0184" class="indexterm"></a><a id="IDX-CHP-5-0185" class="indexterm"></a><a id="IDX-CHP-5-0186" class="indexterm"></a></p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "If it ain't broke, don't fix it."</code></strong>
&gt; <strong class="userinput"><code>Str = string.gsub(Str, "(%a)([%a'-]*)",</code></strong>
&gt;&gt;   <strong class="userinput"><code>function(First, Rest)</code></strong>
&gt;&gt;     <strong class="userinput"><code>return string.upper(First) .. Rest</code></strong>
&gt;&gt;   <strong class="userinput"><code>end)</code></strong>
&gt; <strong class="userinput"><code>print(Str)</code></strong>
If It Ain't Broke, Don't Fix It.</pre><p>If there are no captures, the whole match is passed to the function. If the function returns <code class="literal">nil</code> or <code class="literal">false</code>, no replacement is done. Both these points are demonstrated by the following example, which turns <code class="literal">"cat"</code> into <code class="literal">"dog"</code>, but makes no change to other words that contain <code class="literal">"cat"</code>:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "concatenate cathy ducat cat"</code></strong>
&gt; <strong class="userinput"><code>Str = string.gsub(Str, "%a+",</code></strong>
&gt;&gt;   <strong class="userinput"><code>function(Match)</code></strong>
&gt;&gt;       <strong class="userinput"><code>return Match == "cat" and "dog"</code></strong>
&gt;       <strong class="userinput"><code>end)</code></strong>
&gt; <strong class="userinput"><code>print(Str)</code></strong>
concatenate cathy ducat dog</pre><div class="blockquote"><blockquote class="blockquote"><p>In Lua 5.0, if the replacement function returned <code class="literal">nil</code> or <code class="literal">false</code>, the match was replaced with the empty string.</p></blockquote></div><p>If the <code class="literal">string.gsub</code> replacement argument is a table, then the first capture—or the whole match, if there are no captures—is used to index the table, and the match is replaced with the value at that index, unless it's <code class="literal">nil</code> or <code class="literal">false</code>, in which case no replacement is done. Here's an example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "dog bites man"</code></strong>
&gt; <strong class="userinput"><code>Str = string.gsub(Str, "%a+", {dog = "man", man = "dog"})</code></strong>
&gt; <strong class="userinput"><code>print(Str)</code></strong>
man bites dog</pre><div class="blockquote"><blockquote class="blockquote"><p>In Lua 5.0, the replacement argument could only be a string or a function.</p></blockquote></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="iterating_through_all_matches"></a>Iterating Through All Matches</h2></div></div></div><p>There's one more function in the string library: <code class="literal">string.gmatch</code> (where <code class="literal">gmatch</code> stands for global match). <code class="literal">string.match</code> only sees the first match, but <code class="literal">string.gmatch</code> lets you get at all the matches. It does this by iterating through the matches—like <code class="literal">pairs</code> and <code class="literal">ipairs</code>, it's an iterator factory.</p><p>The following example of <code class="literal">string.gmatch</code> is an HTML <span class="emphasis"><em>tokenizer</em></span>. Most computer languages are composed, at one level, of <span class="emphasis"><em>tokens</em></span>. These are the units in terms of which the language's syntax is defined (Lua tokens include literal strings, keywords, parentheses, commas, and so on.) The example separates a string of HTML (the language used to write web pages) into tokens. Specifically, it returns a table of HTML tags and what's in between those tags. An HTML tag consists of characters delimited by open and close angle brackets (<code class="literal">&lt;&gt;</code>), like <code class="literal">&lt;this&gt;</code>. (This is a crude tokenizer—an industrial-strength HTML tokenizer would take us too far off topic.)<a id="IDX-CHP-5-0187" class="indexterm"></a><a id="IDX-CHP-5-0188" class="indexterm"></a></p><p>Here's the example, which defines the <code class="literal">string.gmatch</code> function:</p><pre class="programlisting">-- Turns a string of HTML into an array of tokens. (Each
-- token is a tag or a string before or after a tag; literal
-- open angle brackets cannot occur outside of tags, and
-- literal close angle brackets cannot occur inside them.)
function TokenizeHtml(Str)
  local Ret = {}
  -- Chop off any leading nontag text:
  local BeforeFirstTag, Rest = string.match(Str, "^([^&lt;]*)(.*)")
  if BeforeFirstTag ~= "" then
    Ret[1] = BeforeFirstTag
  end
  -- Get all tags and anything in between or after them:
  for Tag, Nontag in
    string.gmatch(Rest, "(%&lt;[^&gt;]*%&gt;)([^&lt;]*)")
  do
    Ret[#Ret + 1] = Tag
    if Nontag ~= "" then
      Ret[#Ret + 1] = Nontag
    end
  end
  return Ret
end</pre><p>Now, try it out:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Html = "&lt;p&gt;Some italicized text.&lt;/p&gt;"</code></strong>
&gt; <strong class="userinput"><code>for _, Token in ipairs(TokenizeHtml(Html)) do print(Token) end</code></strong>
&lt;p&gt;
Some
&lt;i&gt;
italicized
&lt;/i&gt;
text.&lt;/p&gt;</pre><p>First, <code class="literal">TokenizeHtml</code> separates its argument into two parts: the possibly empty string before the first tag (if there is a first tag), and the possibly empty remainder of the string:</p><pre class="programlisting">function TokenizeHtml(Str)
   local Ret = {}
   local BeforeFirstTag, Rest = string.match(Str, "^([^&lt;]*)(.*)")
   if BeforeFirstTag ~= "" then
     Ret[1] = BeforeFirstTag
   end</pre><p>Notice that this match cannot fail, even on an empty string. Also notice that, if there's at least one tag in <code class="literal">Str</code>, the <code class="literal">BeforeFirstTag</code> string will be as long as it needs to be to include everything that comes before the tag, because greedy matching is used.</p><p>After it saves the data before the first tag (if it's nonempty), <code class="literal">string.gmatch</code> can loop through the rest of the string. <code class="literal">string.gmatch</code> takes a subject and a pattern. It returns an iterator that, on each iteration, returns the captures from the pattern's next match in the subject. In this case, the pattern is as follows:</p><pre class="programlisting">"(%&lt;[^&gt;]*%&gt;)([^&lt;]*)"</pre><p><a class="link" href="ch05.html#figure_5-4" title="Figure 5.4. Figure 5-4">Figure 5-4</a> shows how this pattern can be diagrammed.</p><div class="figure"><a id="figure_5-4"></a><div class="figure-contents"><div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/0504.png" width="549" alt="Figure 5-4" height="708"></div></div><p class="title"><strong>Figure 5.4. Figure 5-4</strong></p></div><p>The two captures returned by the iterator are given the names <code class="literal">Tag</code> and <code class="literal">Nontag</code>. In this example, the <code class="literal">string.gmatch</code> function specifies that <code class="literal">Tag</code> will never be the empty string (at a minimum, it will be <code class="literal">"&lt;&gt;"</code>), and if two tags are next to each other, then <code class="literal">Nontag</code> will be empty, in which case won't be put into <code class="literal">Ret</code>:<a id="IDX-CHP-5-0189" class="indexterm"></a></p><pre class="programlisting">for Tag, Nontag in
  string.gmatch(Rest, "(%&lt;[^&gt;]*%&gt;)([^&gt;]*)")
do
  Ret[#Ret + 1] = Tag
  if Nontag ~= "" then
    Ret[#Ret + 1] = Nontag
  end
end</pre><p>The loop does an iteration for each match, so if there are no tags to be found, then it will do zero iterations and <code class="literal">Ret</code> will have only one or zero elements.</p><div class="blockquote"><blockquote class="blockquote"><p>In Lua 5.0, <code class="literal">string.gmatch</code> was named <code class="literal">string.gfind</code> (but was otherwise identical).</p></blockquote></div><p>If the pattern given to <code class="literal">string.gmatch</code> has no captures, the iterator will return the whole match:</p><pre class="programlisting">&gt; <strong class="userinput"><code>for Letter in string.gmatch("1st 2nd 3rd", "%a") do</code></strong>
&gt;&gt;   <strong class="userinput"><code>print(Letter)</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
s
t
n
d
r
d</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="tricks_for_the_tricky"></a>Tricks for the Tricky</h2></div></div></div><p>Sometimes when you can't write a pattern to match what you want to match, you can get around this by matching a little more than you need to, and then ignoring the match if it's a false positive. This is the approach used in the previous cat-to-dog example:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "concatenate cathy ducat cat"</code></strong>
&gt; <strong class="userinput"><code>Str = string.gsub(Str, "%a+",</code></strong>
&gt;&gt;   <strong class="userinput"><code>function(Match)</code></strong>
&gt;&gt;       <strong class="userinput"><code>return Match == "cat" and "dog"</code></strong>
&gt;&gt;   <strong class="userinput"><code>end)</code></strong>
&gt; <strong class="userinput"><code>print(Str)</code></strong>
concatenate cathy ducat dog</pre><p>This approach would also work for tasks such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Changing <code class="literal">"cat", "dog"</code>, and <code class="literal">"bird"</code>, but not other words, to <code class="literal">"animal"</code></p></li><li class="listitem"><p>Matching "cat" case-insensitively without using <code class="literal">"[Cc][Aa][Tt]"</code></p></li><li class="listitem"><p>Matching 3-to-10-letter words</p></li></ul></div><p>Another technique is to use a modified version of the subject. In the following, the pattern <code class="literal">"%Wcat%W"</code> even finds the word "cat" at the end of the subject, because the concatenated newlines ensure that it can't be at the <span class="emphasis"><em>very</em></span> end (or the very beginning):</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "concatenate cathy ducat cat"</code></strong>
&gt; <strong class="userinput"><code>Count = 0</code></strong>
&gt; <strong class="userinput"><code>for _ in string.gmatch("\n" .. Str .. "\n", "%Wcat%W") do</code></strong>
&gt;&gt;   <strong class="userinput"><code>Count = Count + 1</code></strong>
&gt;&gt; <strong class="userinput"><code>end</code></strong>
&gt; <strong class="userinput"><code>io.write("'cat' occurs ", Count, " time(s)\n")</code></strong>
'cat' occurs 1 time(s)</pre><p>Another technique is to capture positions and use them to look around inside the subject, like this:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "concatenate cathy ducat cat"</code></strong>
&gt; <strong class="userinput"><code>Str = string.gsub(Str, "()cat()",</code></strong>
&gt;&gt;   <strong class="userinput"><code>function(Pos1, Pos2)</code></strong>
&gt;&gt;    <strong class="userinput"><code>Pos1 = Pos1 - 1 -- The character before the match</code></strong>.
&gt;&gt;    <strong class="userinput"><code>-- Is the match at the beginning of the string or</code></strong>
&gt;&gt;    <strong class="userinput"><code>-- preceded by a nonword character?</code></strong>
&gt;&gt;      <strong class="userinput"><code>if Pos1 == 0 or string.find(Str, "^%W", Pos1) then</code></strong>
&gt;&gt;      <strong class="userinput"><code>-- Is it also at the end of the string or followed by</code></strong>
&gt;&gt;      <strong class="userinput"><code>-- a nonword character?</code></strong>
&gt;&gt;      <strong class="userinput"><code>if Pos2 &gt; #Str or string.find(Str, "^%W", Pos2) then</code></strong>
&gt;&gt;        <strong class="userinput"><code>return "dog"</code></strong>
&gt;&gt;     <strong class="userinput"><code>end</code></strong>
&gt;&gt;   <strong class="userinput"><code>end</code></strong>
&gt;&gt; <strong class="userinput"><code>end)</code></strong>
&gt; <strong class="userinput"><code>print(Str)</code></strong>
concatenate cathy ducat dog</pre><p>In the case of matching a whole word, there's yet another technique—the undocumented <span class="emphasis"><em>frontier</em></span> pattern item, which is shown here:</p><pre class="programlisting">&gt; <strong class="userinput"><code>Str = "concatenate cathy ducat cat"</code></strong>
&gt; <strong class="userinput"><code>Str = string.gsub(Str, "%f[%w]cat%f[%W]",</code></strong>
&gt;&gt;     <strong class="userinput"><code>function(Match)</code></strong>
&gt;&gt;     <strong class="userinput"><code>return Match == "cat" and "dog"</code></strong>
&gt;&gt;  <strong class="userinput"><code>end)</code></strong>
&gt; <strong class="userinput"><code>print(Str)</code></strong>
concatenate cathy ducat dog</pre><p><code class="literal">%f</code> is followed by a bracket class. It matches an empty string that comes after a character not in the class and before one that is in the class, but the empty string matched can also be at the beginning or end of the subject. The pattern <code class="literal">"%f[a]a"</code> matches any "<code class="literal">a</code>" that isn't preceded by another "<code class="literal">a</code>," and the pattern <code class="literal">"a%f[^a]"</code> matches any "<code class="literal">a</code>" that isn't followed by another "<code class="literal">a</code>."</p><p>The fact that <code class="literal">%f</code> is undocumented means that it may—without notice—change or disappear altogether in a subsequent release of Lua. It also means that there's no explicit guarantee of its behavior, and it may act unexpectedly when used in unusual situations such as this one:</p><pre class="programlisting">&gt; <strong class="userinput"><code>-- This should find the empty string at the beginning of the</code></strong>
&gt; <strong class="userinput"><code>-- subject, but it doesn't (due to an implementation quirk):</code></strong>
&gt; <strong class="userinput"><code>print(string.find("\0", "%f[%z]"))</code></strong>
nil</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="magic_characters_chart"></a>Magic Characters Chart</h2></div></div></div><p>Here's a chart of all the magic characters and magic character sequences that patterns can contain:<a id="IDX-CHP-5-0190" class="indexterm"></a><a id="IDX-CHP-5-0191" class="indexterm"></a><a id="IDX-CHP-5-0192" class="indexterm"></a><a id="IDX-CHP-5-0193" class="indexterm"></a><a id="IDX-CHP-5-0194" class="indexterm"></a><a id="IDX-CHP-5-0195" class="indexterm"></a><a id="IDX-CHP-5-0196" class="indexterm"></a><a id="IDX-CHP-5-0197" class="indexterm"></a><a id="IDX-CHP-5-0198" class="indexterm"></a><a id="IDX-CHP-5-0199" class="indexterm"></a><a id="IDX-CHP-5-0200" class="indexterm"></a><a id="IDX-CHP-5-0201" class="indexterm"></a><a id="IDX-CHP-5-0202" class="indexterm"></a><a id="IDX-CHP-5-0203" class="indexterm"></a></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"><col class="col2"></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Character</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">%</code></p></td><td style="text-align: left" valign="top"><p>Escapes the magic character that follows it</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">.</code></p></td><td style="text-align: left" valign="top"><p>Matches any character</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%a</code></p></td><td style="text-align: left" valign="top"><p>Matches a letter</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%c</code></p></td><td style="text-align: left" valign="top"><p>Matches a control character</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%d</code></p></td><td style="text-align: left" valign="top"><p>Matches a decimal digit</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%l</code></p></td><td style="text-align: left" valign="top"><p>Matches a lowercase letter</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%p</code></p></td><td style="text-align: left" valign="top"><p>Matches a punctuation character</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%s</code></p></td><td style="text-align: left" valign="top"><p>Matches a whitespace character</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%u</code></p></td><td style="text-align: left" valign="top"><p>Matches an uppercase letter</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%w</code></p></td><td style="text-align: left" valign="top"><p>Matches a word character (a letter or a number)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%x</code></p></td><td style="text-align: left" valign="top"><p>Matches a hexadecimal digit</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%z</code></p></td><td style="text-align: left" valign="top"><p>Matches a <code class="literal">"\0"</code> character</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%A, %C, %D</code>, etc.</p></td><td style="text-align: left" valign="top"><p>Matches any character not matched by <code class="literal">%a, %c, %d</code>, etc.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">[abc]</code></p></td><td style="text-align: left" valign="top"><p>Matches a, b, or c</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">[A-Ea-e%d]</code></p></td><td style="text-align: left" valign="top"><p>Matches A through E, a through e, or a digit</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">[^abc]</code></p></td><td style="text-align: left" valign="top"><p>Matches any character other than a, b, or c</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">*</code></p></td><td style="text-align: left" valign="top"><p>Makes the preceding character class match zero or more characters (greedy)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">+</code></p></td><td style="text-align: left" valign="top"><p>Makes the preceding character class match one or more characters (greedy)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">-</code></p></td><td style="text-align: left" valign="top"><p>Makes the preceding character class match zero or more characters (nongreedy)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">?</code></p></td><td style="text-align: left" valign="top"><p>Makes the preceding character class match zero or one character(s) (greedy)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">^</code></p></td><td style="text-align: left" valign="top"><p>Anchors the pattern at the beginning</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">$</code></p></td><td style="text-align: left" valign="top"><p>Anchors the pattern at the end</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%1, %2</code>, etc.</p></td><td style="text-align: left" valign="top"><p>Matches the first capture, second capture, etc. (up to 9)</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%b(), %b&lt;&gt;</code>, etc.</p></td><td style="text-align: left" valign="top"><p>Matches balanced parentheses, angle brackets, etc.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">%f[%a_], %f[^AEIOUaeiou]</code>, etc.</p></td><td style="text-align: left" valign="top"><p>Undocumented—matches the empty string ("frontier") at the transition from something not matched by the given bracket class to something matched by it.</p></td></tr></tbody></table></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="summary-013"></a>Summary</h1></div></div></div><p>In this chapter, you learned all the functions in the string library (except for <code class="literal">string.dump</code>, which is covered in <a class="link" href="ch10.html" title="Chapter 10. Looking Under the Hood">Chapter 10</a>), along with a few in the I/O library. Here are the highlights:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You can convert the case of strings with <code class="literal">string.lower</code> and <code class="literal">string.upper</code>.</p></li><li class="listitem"><p>You can obtain substrings with <code class="literal">string.sub</code>.</p></li><li class="listitem"><p>You can format strings with <code class="literal">string.format</code>, whose first argument is a format string with placeholders (which start with a percent sign).</p></li><li class="listitem"><p>You get more fine-grained control over output with <code class="literal">io.write</code>, and over standard input with <code class="literal">io.read</code>.</p></li><li class="listitem"><p>When you use <code class="literal">io.open</code> to open a file, it returns a file handle—an object with <code class="literal">read, write</code>, and <code class="literal">close</code> methods.</p></li><li class="listitem"><p>You perform pattern matching with magic characters such as <code class="literal">%, ^</code>, and <code class="literal">*</code>.</p></li><li class="listitem"><p>Anchoring (which you do with <code class="literal">^</code> and <code class="literal">$</code>) forces a match to be at the beginning and/or end of the subject string (or the searched part of the subject string, if a third argument is given to <code class="literal">string.find</code> or <code class="literal">string.match</code>).</p></li><li class="listitem"><p>Greedy matching ("<code class="literal">*</code>", "<code class="literal">+</code>", and "<code class="literal">?</code>") matches as many characters as possible. Nongreedy matching ("<code class="literal">-</code>") matches as few as possible. Either way, each match will be as close to the beginning of the searched part of the subject string as possible.</p></li><li class="listitem"><p><code class="literal">string.gsub</code> does substitution on all matches of a pattern.</p></li><li class="listitem"><p><code class="literal">string.find</code> finds the first match.</p></li><li class="listitem"><p><code class="literal">string.match</code> returns the captures from the first match.</p></li><li class="listitem"><p><code class="literal">string.gmatch</code> returns an iterator that loops through all matches.</p></li></ul></div><p>At this point, you have all the tools you need to start writing real programs, except that the programs you write may not be very robust. In the next chapter, you'll learn how to prevent errors, or to keep them from stopping your program cold when they do happen. To test your understanding of this chapter, you can do the following exercises (answers are in the appendix).</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-014"></a>Exercises</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Write a function that takes an n-character string and returns an n-element array whose elements are the string's characters (in order).</p></li><li class="listitem"><p>Write the format string <code class="literal">Frmt</code> so that the following:</p><pre class="programlisting">for _, Name in ipairs({"Lynn", "Jeremy", "Sally"}) do
  io.write(string.format(Frmt, Name))
end</pre><p>will print this:</p><pre class="programlisting">Lynn
Jeremy
 Sally</pre></li><li class="listitem"><p>Write a comparison function that allows <code class="literal">table.sort</code> to sort in "dictionary order." Specifically, case distinctions and any characters other than letters or numbers should be ignored, unless they are the only ways in which two strings differ.</p><pre class="programlisting">&gt; <strong class="userinput"><code>Names = {"Defoe", "Deforest", "Degas", "de Forest"}</code></strong>
&gt; <strong class="userinput"><code>table.sort(Names, DictCmp)</code></strong>
&gt; <strong class="userinput"><code>for _, Name in ipairs(Names) do print(Name) end</code></strong>
Defoe
Deforest
de Forest
Degas</pre></li><li class="listitem"><p>Write a function that starts up a subinterpreter that prints a prompt, reads a line, and prints the result(s) of evaluating the expression(s) typed onto that line. Typing a line with nothing but the word "<code class="literal">quit</code>" should exit the subinterpreter.</p><pre class="programlisting">&gt; <strong class="userinput"><code>ExprInterp()</code></strong>
expression&gt; <strong class="userinput"><code>2 + 2</code></strong>
4
expression&gt; <strong class="userinput"><code>true, false, nil</code></strong>
true    false   nil
expression&gt; <strong class="userinput"><code>string.gsub("somewhere", "[Ss]", "%0h")</code></strong>
shomewhere      1
expression&gt; <strong class="userinput"><code>quit</code></strong>
&gt;</pre><p>There's no need to check for errors in what is typed (you'll learn how to do this in the next chapter) or to special-case empty lines. (Hint: This exercise doesn't require any pattern matching.)</p></li><li class="listitem"><p>The <code class="literal">TrimRight</code> function given in this chapter trims off trailing whitespace. Write its counterpart: <code class="literal">TrimLeft</code>, a function that trims leading whitespace.</p></li><li class="listitem"><p>Does <code class="literal">TrimLeft</code> ever need to do any backtracking?</p></li><li class="listitem"><p>Write an <code class="literal">Interpolate</code> function that replaces dollar signs followed by identifiers with the value of the named global variable.</p><pre class="programlisting">&gt; <strong class="userinput"><code>Where, Who, What =</code></strong>
&gt;&gt;   <strong class="userinput"><code>"in xanadu", "kubla khan", "a stately pleasure-dome"</code></strong>
&gt; <strong class="userinput"><code>print(Interpolate("$Where did $Who\n$What decree"))</code></strong>
in xanadu did kubla khan
a stately pleasure-dome decree
&gt; print(Interpolate("string = $string, asdf = $asdf"))
string = table: 0x481dd0, asdf = nil</pre></li></ol></div></div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="ch04.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">4. Working with Tables</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="ch06.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">6. Handling and Avoiding Errors</div>
        </a>
    
  
  </div>


        
    </section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag">
        
        

        
          <p>You have 6 days left in your trial, Michaelschiner. Subscribe today. <a href="https://learning.oreilly.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
        
        

      </div>

    
    



        
      </div>
      
        

<footer class="pagefoot t-pagefoot">
  <a href="ch05.html#" class="icon-up" onclick="window.Appcues.track('JumpTop_HeronBook')"><div class="visuallyhidden">Back to top</div></a>
  <ul class='js-footer-nav'>
  
    
    <li><a href="https://learning.oreilly.com/public/support/">Support</a></li>
    
    <li><a href="https://learning.oreilly.com/accounts/logout/">Sign Out</a></li>
    
  
  
  </ul>
  <span class="copyright">&#169; 2021 <a href="https://learning.oreilly.com/" target="_blank">O'Reilly Media, Inc</a>.</span>
  
    
    <a href="https://www.oreilly.com/terms/">Terms of Service</a> 
     / 
    
    <a href="https://learning.oreilly.com/privacy">Privacy Policy</a> 
    
    
  
</footer>

      
    
    <script src="https://learning.oreilly.com/jsi18n/web/" charset="utf-8"></script>
    <script src="https://learning.oreilly.com/library/jsi18n/appcache/" charset="utf-8"></script>
  </body>
</html>
