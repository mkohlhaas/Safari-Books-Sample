<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch13.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch13.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch13.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch13.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><!--<![endif]--><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="author" content="O'Reilly Media" /><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9780470069172"/><link rel="shortcut icon" href="https://www.oreilly.com/favicon.ico" /><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"/><meta property="twitter:account_id" content="4503599627559754" /><link rel="shortcut icon" href="https://learning.oreilly.com/favicon.ico" type="image/x-icon"><link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic' rel='stylesheet' type='text/css'><title>13. Interfacing Lua with Other Languages - Beginning Lua Programming</title><link rel="stylesheet" href="https://learning.oreilly.com/static/CACHE/css/output.5bdb4fcb2aad.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://learning.oreilly.com/static/css/annotator.e3b0c44298fc.css"/><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book"></style><script> // <![CDATA[
    var g = {
      position_cache: {
        
          "chapter": "/api/v1/book/9780470069172/chapter/ch13.html",
          "book_id": "9780470069172",
          "chapter_uri": "ch13.html",
          "position": 0,
          "user_uuid": "ce47de5b-ce80-49f0-b5cd-c60d3d33b198",
          "next_chapter_uri": "/library/view/beginning-lua-programming/9780470069172/ch14.html"
        
      },
      title: "Beginning Lua Programming",
      author_list: "Aaron Brown, Kurt Jung",
      format: "book",
      source: "application/epub+zip",
      is_system_book: true,
      is_public: false,
      loaded_from_server: true,
      allow_scripts: false,
      has_mathml: false
    };
    // ]]></script><script src="https://learning.oreilly.com/static/js/src/modernizr.8e35451ddb64.js"></script><script>
    
      

      
        
          window.PUBLIC_ANNOTATIONS = true;
        
      

      window.MOBILE_PUBLIC_ANNOTATIONS = false;

    

    
      window.PRIVACY_CONTROL_OVERRIDE = false;
    

      window.PRIVACY_CONTROL_SWITCH = true;

      window.PUBLISHER_PAGES = true;

      window.SBO = {
        "constants": {
          "SITB_ENDPOINT": "/api/v2/sitb/",
          "SEARCH_SELECT_ENDPOINT": "https://learning.oreilly.com/api/v2/search/select/",
        }
      };
  </script><link rel="canonical" href="ch13.html"/><meta name="description" content="Chapter 13. Interfacing Lua with Other Languages Lua has a flexible mechanism for binding to program elements written in languages other than Lua. As you saw in the preceding chapter, ... "><meta property="og:title" content="13. Interfacing Lua with Other Languages" /><meta itemprop="isPartOf" content="/library/view/beginning-lua-programming/9780470069172/" /><meta itemprop="name" content="13. Interfacing Lua with Other Languages" /><meta property="og:url" itemprop="url" content="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch13.html" /><meta property="og:site_name" content="Safari" /><meta property="og:image" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9780470069172/" /><meta property="og:description" itemprop="description" content="Chapter 13. Interfacing Lua with Other Languages Lua has a flexible mechanism for binding to program elements written in languages other than Lua. As you saw in the preceding chapter, ... "><meta itemprop="inLanguage" content="en" /><meta itemprop="publisher" content="Wrox" /><meta property="og:type" content="book" /><meta property="og:book:isbn" itemprop="isbn" content="9780470069172" /><meta property="og:book:author" itemprop="author" content="Aaron Brown" /><meta property="og:book:author" itemprop="author" content="Kurt Jung" /><meta property="og:book:tag" itemprop="about" content="Core Programming" /><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@OReillyMedia"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><noscript><meta http-equiv="refresh" content="0; URL=https://learning.oreilly.com/library/no-js/" /></noscript><script>
    var dataLayer = window.dataLayer || [];

    
      window.medalliaVsgUserIdentifier = 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198';
      dataLayer.push({userIdentifier: 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198'});
      dataLayer.push({loggedIn: 'yes'});

      
        window.medalliaVsgAccountIdentifier = '29964b7b-68d8-4532-9a9b-32e089689c1f';
        

        window.medalliaVsgIsIndividual = true;
        
          
          dataLayer.push({learningAccountType: 'free trial'});
          
        

        
      
    

    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5P4V6Z');
    (function () {
      var VERSION = 'V1.1';
      var AUTHOR = 'Awwad';
      if (!window.GtmHelper)
        window.GtmHelper = function () {
          var instance = this;
          var loc = document.location;
          this.version = VERSION;
          this.author = AUTHOR;
          this.readCookie = function (name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
              var c = ca[i];
              while (c.charAt(0) == ' ') c = c.substring(1, c.length);
              if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
          };
          this.createCookie = function (name, value, days, cookieDomain) {
            var domain = "";
            var expires = "";

            if (days) {
              var date = new Date();
              date.setTime(date.getTime() + Math.ceil(days * 24 * 60 * 60 * 1000));
              var expires = " expires=" + date.toGMTString() + ";";
            }

            if (typeof (cookieDomain) != 'undefined')
              domain = " domain=" + cookieDomain + "; ";

            document.cookie = name + "=" + value + ";" + expires + domain + "path=/";
          };

          this.isDuplicated = function (currentTransactionId) {
            // the previous transaction id:
            var previousTransIdValue = this.readCookie("previousTransId");

            if (currentTransactionId === previousTransIdValue) {
              return true; // Duplication
            } else {
              return false;
            }
          };
        }
    })()
  </script><script defer src="https://learning.oreilly.com/static/js/build/vendor.0eac897f11ed.js"></script><script defer src="https://learning.oreilly.com/static/js/build/reader.c745ea9296ac.js"></script></head>


<body class="reading sidenav nav-collapsed  scalefonts">

    
  <noscript> 
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
            height="0" width="0"
            style="display:none;visibility:hidden">
    </iframe>
  </noscript>



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        

  


<a href="ch13.html#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li><a href="https://learning.oreilly.com/home/" class="l0 nav-icn"><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.738 14H9.254v-3.676a.617.617 0 0 0-.621-.613H7.39a.617.617 0 0 0-.62.613V14H4.284a.617.617 0 0 1-.622-.613V10.22c0-.327.132-.64.367-.87l3.547-3.493a.627.627 0 0 1 .875 0l3.54 3.499c.234.229.366.54.367.864v3.167a.617.617 0 0 1-.62.613zM7.57 2.181a.625.625 0 0 1 .882 0l5.77 5.692-.93.92-5.28-5.209-5.28 5.208-.932-.919 5.77-5.692z" /></svg><span>Home</span></a></li><li class="search"><a href="ch13.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"/></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="ch13.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"/></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li class="flyout-parent"><a
                href="ch13.html#"
                class="l1 nav-icn "
                
              ><?xml version="1.0" encoding="UTF-8"?><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M8,8 C6.34321755,8 5.00013,6.65691245 5.00013,5.00013 C5.00013,3.34334755 6.34321755,2.00026001 8,2.00026001 C9.65678245,2.00026001 10.99987,3.34334755 10.99987,5.00013 C10.99987,6.65691245 9.65678245,8 8,8 Z M2.33024571,11.3523547 L2.33774538,11.3523547 C3.7622187,9.70968996 5.82947484,8.76608166 8.00374984,8.76608166 C10.1780248,8.76608166 12.245281,9.70968996 13.6697543,11.3523547 C13.8892083,11.6177474 14.0062813,11.9530021 13.99974,12.2973138 L13.99974,13.99974 L2.00026001,13.99974 L2.00026001,12.2973138 C1.99371867,11.9530021 2.11079172,11.6177474 2.33024571,11.3523547 Z" id="path-1"></path></svg><span>Your O&#39;Reilly</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/profile/"
                    class="l2 nav-icn"
                    
                  ><span>Profile</span></a></li><li><a
                    href="https://learning.oreilly.com/history/"
                    class="l2 nav-icn"
                    
                  ><span>History</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/"
                    class="l2 nav-icn"
                    
                  ><span>Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/u/ce47de5b-ce80-49f0-b5cd-c60d3d33b198/"
                    class="l2 nav-icn"
                    
                  ><span>Highlights</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/answers/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M2.31032699,3.75609006 C4.65421571,1.41371359 8.45302454,1.41472092 10.7955702,3.75860838 C13.1381158,6.10249583 13.1369405,9.90130261 10.7930518,12.243847 C8.44916311,14.5863913 4.65018639,14.5852161 2.30780867,12.2413286 C-0.0346204845,9.89749489 -0.0334929936,6.09853298 2.31032699,3.75609006 Z M8.8198605,4.98016308 C7.34193969,3.86924672 5.23410194,3.98609692 3.88914868,5.33104946 C3.12814393,6.09032122 2.72818176,7.13880077 2.79015179,8.21201133 C2.79115912,8.23064692 2.79233434,8.24928252 2.79350956,8.26791811 L2.79350956,8.26791811 C2.83179539,8.8307976 2.9944077,9.37404287 3.26947292,9.86201677 L3.26947292,9.86201677 L2.77621706,11.7027432 C2.7699968,11.7259241 2.77662063,11.7506624 2.79359185,11.7676337 C2.8105631,11.7846049 2.83530144,11.7912287 2.85848233,11.7850085 L2.85848233,11.7850085 L4.69400524,11.2922565 C5.26306363,11.6167344 5.90703177,11.786885 6.56209849,11.7858479 C8.64827865,11.7858479 10.3395879,10.094542 10.3395879,8.00836292 C10.3405204,6.84135608 9.80105674,5.73967784 8.87862141,5.02482134 L8.87862141,5.02482134 L8.82825492,4.98654283 Z M13.7933062,2 C14.7073496,2.00009863 15.4482759,2.74110484 15.4482759,3.65514822 C15.4482759,4.32460943 15.0449926,4.92814782 14.4264842,5.18432286 C13.8079757,5.44049789 13.096053,5.29885769 12.6226979,4.82545158 C12.1493429,4.35204547 12.0077795,3.64010743 12.2640213,3.02162665 C12.5202631,2.40314587 13.123845,1.99992776 13.7933062,2 Z"/></svg><span>Answers</span></a></li><li class="flyout-parent"><a
                href="ch13.html#"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z"/></g></svg><span>Explore</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/topics/"
                    class="l2 nav-icn"
                    
                  ><span>All Topics</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;formats=case%20study&amp;formats=learning%20path&amp;formats=live%20online%20training&amp;formats=notebook&amp;formats=oriole&amp;formats=video&amp;sort=popularity&amp;facet_json=true&amp;page=0&amp;collection_type=expert"
                    class="l2 nav-icn"
                    
                  ><span>Most Popular Titles</span></a></li><li><a
                    href="https://learning.oreilly.com/recommendations/"
                    class="l2 nav-icn"
                    
                  ><span>Recommended</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;sort=publication_date&amp;facet_json=true&amp;page=0"
                    class="l2 nav-icn"
                    
                  ><span>Early Releases</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/discover/"
                    class="l2 nav-icn"
                    
                  ><span>Shared Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/resource-centers/"
                    class="l2 nav-icn"
                    
                  ><span>Resource Centers</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch13.html#"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M12.8 3.2A1.2 1.2 0 0 1 14 4.4v8.4a1.2 1.2 0 0 1-1.2 1.2H3.2A1.2 1.2 0 0 1 2 12.8V4.4a1.2 1.2 0 0 1 1.2-1.2h1.2V2h1.2v1.2h4.8V2h1.2v1.2h1.2zm-9.6 9.6h9.6V6.2H3.2v6.6zM8 9.5a1.35 1.35 0 1 1 0-2.7 1.35 1.35 0 0 1 0 2.7zm2.7 2.148v.552H5.3v-.552c0-.321.124-.634.355-.858a3.358 3.358 0 0 1 4.69 0c.23.224.355.537.355.858z" /></svg><span>Live Events</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/attend/"
                    class="l2 nav-icn"
                    
                  ><span>All Events</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/architectural-katas/"
                    class="l2 nav-icn"
                    
                  ><span>Architectural Katas</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/ai/"
                    class="l2 nav-icn"
                    
                  ><span>AI &amp; ML</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/strata/"
                    class="l2 nav-icn"
                    
                  ><span>Data Sci &amp; Eng</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/oscon/"
                    class="l2 nav-icn"
                    
                  ><span>Programming</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/infrastructure-ops/"
                    class="l2 nav-icn"
                    
                  ><span>Infra &amp; Ops</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/software-architecture/"
                    class="l2 nav-icn"
                    
                  ><span>Software Arch</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch13.html#"
                class="l1 nav-icn "
                
              ><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.6467109,4.35328907 L14.7964612,7.51003884 C15.0678463,7.78304342 15.0678463,8.22395603 14.7964612,8.49696061 L11.6467109,11.6467109 L10.6597892,10.6597892 L13.3055794,8 L10.6597892,5.34021084 L11.6467109,4.35328907 Z M4.35328907,11.6467109 L1.20353875,8.48996116 C0.932153749,8.21695658 0.932153749,7.77604397 1.20353875,7.50303939 L4.35328907,4.35328907 L5.34021084,5.34021084 L2.69442057,8 L5.34021084,10.6597892 L4.35328907,11.6467109 Z M5.84417089,11.4997226 L8.67194674,4.50027742 L10.1838269,4.50027742 L7.35605105,11.4997226 L5.84417089,11.4997226 Z" id="Mask"></path></svg><span>Interactive</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=content-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Scenarios</span></a></li><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=sandbox-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Sandboxes</span></a></li><li><a
                    href="https://learning.oreilly.com/interactive/?classification=jupyter-notebook"
                    class="l2 nav-icn"
                    
                  ><span>Jupyter Notebooks</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/certifications/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M12.912 9.18L14 8.014l-1.088-1.18a.304.304 0 01-.075-.268L13.195 5l-1.535-.463a.313.313 0 01-.194-.194l-.462-1.537-1.565.358c-.09.03-.194 0-.269-.074L8.007 2 6.845 3.09a.303.303 0 01-.269.074l-1.565-.358-.462 1.537a.313.313 0 01-.194.194L2.82 5l.358 1.567a.26.26 0 01-.075.269L2 8.015l1.088 1.164c.075.075.09.18.075.269l-.358 1.567 1.535.463c.09.03.164.104.194.194l.462 1.537 1.565-.358c.015 0 .045-.015.075-.015.075 0 .15.03.209.074L8.007 14l1.163-1.09a.303.303 0 01.269-.074l1.565.358.462-1.537a.313.313 0 01.194-.194L13.195 11l-.358-1.567a.338.338 0 01.075-.254zm-6.046 1.37L4.41 8.26l1.16-1.244 1.767 1.649L10.4 5.6l1.202 1.202-4.242 4.243-.495-.495z"/></svg><span>Certifications</span></a></li><li ><a
                href="https://learning.oreilly.com/preferences/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"/></g></svg><span>Settings</span></a></li><li ><a
                href="https://learning.oreilly.com/public/support/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M7.363 6.656a2.692 2.692 0 0 1-2.681-2.703c0-1.493 1.2-2.703 2.681-2.703a2.692 2.692 0 0 1 2.682 2.703c0 1.493-1.2 2.703-2.682 2.703zm4.023 2.027c-1.852 0-3.352 1.513-3.352 3.379H2v-1.534c-.006-.31.099-.612.295-.852a6.666 6.666 0 0 1 9.09-.993zm-.543.676h1.12v.304c.003.284.16.543.408.676a.766.766 0 0 0 .77 0l.303-.176.556.966-.302.176a.772.772 0 0 0-.362.676v.08a.772.772 0 0 0 .362.677l.302.21-.556.965-.302-.175a.766.766 0 0 0-.771 0 .778.778 0 0 0-.409.675v.352h-1.106v-.372a.778.778 0 0 0-.409-.676.766.766 0 0 0-.77 0l-.303.176-.556-.912.302-.176a.772.772 0 0 0 .362-.676v-.04-.04a.772.772 0 0 0-.362-.676l-.302-.176.556-.966.289.155a.766.766 0 0 0 .77 0 .778.778 0 0 0 .41-.676V9.36zm1.562 2.703c0-.271-.108-.531-.3-.722a1.001 1.001 0 0 0-.72-.292 1.01 1.01 0 0 0-.992 1.023 1.01 1.01 0 0 0 1.01 1.004 1.01 1.01 0 0 0 1.002-1.013z" /></svg><span>Support</span></a></li><li ><a
                href="https://get.oreilly.com/email-signup.html"
                class="l1 nav-icn "
                target=&quot;_blank&quot;
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.564 2.263l2.172 2.174c.17.168.264.397.264.636V11a.6.6 0 0 1-.6.6h-.6V6.2h-6V2.6a.6.6 0 0 1 .6-.6h3.527c.239 0 .468.095.637.263zM2.6 14a.6.6 0 0 1-.6-.6V6.8a.6.6 0 0 1 .6-.6h1.903a1.2 1.2 0 0 1 .849.352L6.2 7.4H11a.6.6 0 0 1 .6.6v5.4a.6.6 0 0 1-.6.6H2.6zM11 5h1.8L11 3.2V5z" /></svg><span>Newsletters</span></a></li><li ><a
                href="https://learning.oreilly.com/accounts/logout/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.613 12.63A.607.607 0 0 1 2 12.03V3.602C2 3.269 2.274 3 2.613 3h5.515v1.204H3.226v7.223h4.902v1.203H2.613zM5.677 9.02V6.611h4.903V4.926a.301.301 0 0 1 .19-.274.31.31 0 0 1 .33.063l2.722 2.673a.594.594 0 0 1 0 .849L11.1 10.909a.31.31 0 0 1-.331.063.301.301 0 0 1-.19-.274V9.02H5.677z" /></svg><span>Sign Out</span></a></li></ul></div></li></ul></nav></header>



      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="ch13.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Beginning Lua Programming
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="ch13.html#" title="Search in archive" class="js-search-controls search-controls" onclick="window.Appcues.track('SearchBook_HeronBook')"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9780470069172/chapter/ch13.html"><div class="js-collections-dropdown collections-dropdown menu-bit-cards" onclick="window.Appcues.track('AddPlaylist_HeronBook')"></div></div></li><li class="js-font-control-panel font-control-activator"><a href="ch13.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size" onclick="window.Appcues.track('ChangeFont_HeronBook')"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="ch13.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share" onclick="window.Appcues.track('Share_HeronBook')"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a
        class="twitter share-button t-twitter"
        target="_blank"
        aria-label="Share this section on Twitter"
        title="Share this section on Twitter"
      
        href="https://twitter.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch13.html&text=Beginning%20Lua%20Programming&via=OReillyMedia"
      ><span>Twitter</span></a></li><li><a
        class="facebook share-button t-facebook"
        target="_blank"
        aria-label="Share this section on Facebook"
        title="Share this section on Facebook"
        href="https://www.facebook.com/sharer/sharer.php?u=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch13.html"
      ><span>Facebook</span></a></li><li><a
        class="googleplus share-button t-googleplus"
        target="_blank"
        aria-label="Share this secton on Google Plus"
        title="Share this secton on Google Plus"
        href="https://plus.google.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch13.html"
      ><span>Google Plus</span></a></li><li><a
        class="email share-button t-email"
        aria-label="Share this section via email"
        title="Share this section via email"
      
        href="mailto:?subject=Safari: 13.%20Interfacing%20Lua%20with%20Other%20Languages&body=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch13.html%0D%0Afrom Beginning%20Lua%20Programming%0D%0A"
      ><span>Email</span></a></li></ul></li><!-- endif request.user.is_authenticated -->
      </ul>
    </div>

      
          
      

    <section role="document">
        
        




  <script defer src="https://learning.oreilly.com/static/js/build/djangoMessagesPage.bfaca9fd8619.js"></script>


        <script src="https://fast.appcues.com/48743.js"></script>
<script>
  var userId = "ce47de5b-ce80-49f0-b5cd-c60d3d33b198";

  var userObject = {
    firstName: "Michael",
    segment: "Trial",
    admin: "False",
    profileCreatedOn: "2021-05-13",
    academic: ""
  };
  window.Appcues.identify(userId, userObject);
  window.Appcues.page();

  setTimeout(function () {
    window.Appcues.track('ViewingBook_HeronBook')
  }, 20000);
</script>


	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="ch12.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">12. Using Community Libraries</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="ch14.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">14. Managing Information with Databases</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="interfacing_lua_with_other_languages"></a>Chapter 13. Interfacing Lua with Other Languages</h1></div></div></div><p>Lua has a flexible mechanism for binding to program elements written in languages other than Lua. As you saw in the preceding chapter, functions in libraries written in C can be made available to your Lua programs through Lua's C application programming interface (C API or simply API). In this chapter, you delve a little deeper into this interface and learn the basics of writing routines in C that can be used in conjunction with Lua. This includes the following:<a id="IDX-CHP-13-0001" class="indexterm"></a><a id="IDX-CHP-13-0002" class="indexterm"></a><a id="IDX-CHP-13-0003" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Embedding Lua in an application</p></li><li class="listitem"><p>Extending Lua with C functions</p></li><li class="listitem"><p>Manipulating the virtual stack in C</p></li><li class="listitem"><p>Passing values between Lua and C</p></li><li class="listitem"><p>Storing Lua values in C</p></li><li class="listitem"><p>Guarding against errors in your C code</p></li><li class="listitem"><p>Structuring the binding layer</p></li></ul></div><p>Although the focus in this chapter is the C programming language, most mainstream implementations of compiled languages like C++ and Pascal are compatible with the C calling convention — these languages work fine with Lua. In this chapter, references to C programs and libraries are intended to include those that are written in other compatible languages as well.</p><p>If you are unfamiliar with C, take a moment to skim through some of the C examples. It should provide ample grounds for appreciating the clean, readable syntax of Lua.</p><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="how_c_programs_use_lua"></a>How C Programs Use Lua</h1></div></div></div><p>Lua's C API can be used both by a host application that <span class="emphasis"><em>embeds</em></span> Lua and by libraries that <span class="emphasis"><em>extend</em></span> Lua. The distinction between these two ways of using Lua can be blurred somewhat because a host application often provides its own functions to extend Lua, and extension libraries can contain their own independent Lua instances. Nevertheless, understanding the distinction can help you make the right design decisions when developing your applications.<a id="IDX-CHP-13-0004" class="indexterm"></a><a id="IDX-CHP-13-0005" class="indexterm"></a></p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="embedding_lua"></a>Embedding Lua</h2></div></div></div><p>Lua is packaged as a library. It doesn't include a <code class="literal">main</code> function (the entry point of a C application) and can't run apart from a host application. The standalone Lua interpreter that you use throughout this book is one such host application. It has a relatively small main source file that uses Lua's API but doesn't itself add anything to the Lua core. In this way, it embeds Lua. Its job is to manage the way scripts are submitted to Lua — either interactively or noninteractively — and the way Lua's output is delivered.</p><p>The distinguishing hallmark of an embedding application is that it calls <code class="literal">lua_open</code> to create and initialize a Lua state. If this function succeeds, it returns a pointer to the newly created state structure. This pointer is used as the first argument to all other functions in the API. When an embedding application is finished running Lua scripts with a particular state, it finalizes and destroys the state by calling <code class="literal">lua_close</code>.<a id="IDX-CHP-13-0006" class="indexterm"></a></p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="extending_lua"></a>Extending Lua</h2></div></div></div><p>The Lua API supports the extension of a Lua state by allowing C functions to be called from scripts. There are two basic ways this can happen:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An embedding application can register extension functions directly.</p></li><li class="listitem"><p>A running script can, usually with a call to <code class="literal">require</code>, load and transfer control to a C library that in turn registers its extension functions.</p></li></ul></div><p>In both cases, the Lua state that is extended is already active in the context of a host application.</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="embedding_or_extending_colon_which_is_be"></a>Embedding or Extending: Which Is Best?</h2></div></div></div><p>If you're developing a library that will perform services for an application, you'll be extending Lua. If, however, you're developing an application, you've got a choice between embedding Lua and extending it. A number of factors have a bearing on which path you choose, including the following:<a id="IDX-CHP-13-0007" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Will your program use Lua only intermittently, for example, to run user-provided helper scripts or to interpret a configuration script?</p></li><li class="listitem"><p>Does your application need to modify the behavior of the standalone Lua interpreter, for example, to specify which libraries are loaded or which functions are present within a library?</p></li><li class="listitem"><p>Does your application run in a special environment, such as one that doesn't support dynamic linking of libraries?</p></li></ul></div><p>If none of these characteristics apply to your application, there are compelling reasons for you to configure it as an extension library. Doing so preserves Lua's flexibility and modularity to the greatest extent, which often leads to serendipitous opportunities for your program to interoperate with other libraries, and will conform to standard usage patterns that developers expect when working with your application. Designing, or redesigning, your application as a library can require a fair amount of effort up front, especially with regard to initialization and finalization sequences and event handling. But after the initial work is done, libraries are generally no harder to maintain than an embedding application.<a id="IDX-CHP-13-0008" class="indexterm"></a><a id="IDX-CHP-13-0009" class="indexterm"></a><a id="IDX-CHP-13-0010" class="indexterm"></a></p><p>The standalone Lua interpreter needs to be modified to work well with some platforms. For example, programs that use the Windows graphical user interface don't have a <code class="literal">main</code> function and don't, by default, handle standard streams in the expected manner. If you develop for a platform like this, your best choice may be to write your own embedding application, but preserve the behavior of the standalone Lua interpreter as much as possible. Resist the temptation to put application-specific code into the interpreter — usually, this is best placed in a library.</p><p>A case for embedding Lua applies to programs like the Zeus programmer's editor. Here, Zeus is an already self-contained application and Lua is used to run scripts provided by end users to automate tasks. Another case is the Plua application for Palm devices, which you will explore in <a class="link" href="ch18.html" title="Chapter 18. Carrying Lua with You">Chapter 18</a>. The Palm OS has certain restrictions that prevent a standard Lua interpreter from being installed.<a id="IDX-CHP-13-0011" class="indexterm"></a></p></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="communicating_between_lua_and_c"></a>Communicating Between Lua and C</h1></div></div></div><p>In the previous chapter, you compiled a minimal interpreter from <code class="literal">min.c</code> found in the <code class="literal">etc</code> subdirectory of the Lua source package. When doing that, you saw that a C function needs to conform to a certain prototype to be callable from Lua. This prototype is specified in the following declaration within Lua's principal header file, <code class="literal">lua.h</code>:</p><pre class="programlisting">typedef int (*lua_CFunction) (lua_State *L);</pre><p>.A C function of type <code class="literal">lua_CFunction</code> can be either of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="emphasis"><em>loader function</em></span>, which is exported from a library and called by Lua when the library is loaded<a id="IDX-CHP-13-0012" class="indexterm"></a></p></li><li class="listitem"><p>An <span class="emphasis"><em>extension function</em></span>, which is registered with a Lua state so that it can be called like any other Lua function<a id="IDX-CHP-13-0013" class="indexterm"></a></p></li></ul></div><p>After an extension function is registered, the function can be called from a Lua program or, using the Lua API, from within C. Within the Lua program, the function is indistinguishable from one written completely in Lua.</p><p>In <a class="link" href="ch03.html" title="Chapter 3. Extending Lua with Functions">Chapter 3</a>, you became familiar with the call stack used by Lua. A C extension or loader function has a similar runtime structure — the virtual stack — available to it through the Lua API. When the C function is first called, this stack is empty except for any arguments that were passed to the function from Lua. The leftmost argument passed occupies position one in the stack. This stack can contain values of any Lua type, including <code class="literal">nil</code>. It is used to manage operations such as setting up Lua function calls, accessing and manipulating tables, and returning values to the caller.<a id="IDX-CHP-13-0014" class="indexterm"></a></p><p>The proper use of the virtual stack is one of the keys to writing a Lua extension in C. The stack is of limited size, so when you're using deeply recursive routines, you may need to lengthen it with the <code class="literal">lua_checkstack</code> function. More typically, you need to take care not to inadvertently fill up the stack with temporary values that should have been removed after use.</p><p>High-level programming languages like Lua and C handle stack operations transparently. When it comes to interfacing Lua and C, however, you'll have to be aware of the virtual stack and what it looks like at each statement. You should get in the habit of writing stack snapshots in the form of single-line comments. For example, the following comment indicates that you expect a table and a string to occupy positions one and two of the stack:</p><pre class="programlisting">// Stk: Tbl? Str?</pre><p>When a verification has been made, for example with the <code class="literal">lua_istable</code> function, the question mark of the verified value can be removed as follows:</p><pre class="programlisting">// Stk: Tbl Str?</pre><p>Often, you'll have a deeply occupied stack, or will write a helper function, and will be concerned only with the top of the stack. Lua facilitates stack access in these situations by letting you use a negative index to effectively count from the top of the stack. When using negative indexes, index −1 refers to the topmost item, index −2 the second from top item, and so on. Three consecutive dots can be used in a stack diagram to denote the presence of zero or more stack items that will be preserved in the current set of statements. Here's an example:</p><pre class="programlisting">// Stk: ... TitleStr MsgStr</pre><p>In this example, index −1 refers to the message string, and index −2 refers to the title string. The objective of these diagrams is to help the programmer keep the stack in balance and to keep track of positions. Some operations such as manipulating table fields in a loop can generate quite a lot of stack activity, and in these cases, any technique that helps you monitor where values are on the stack is of some value.</p><p>Returning values to the caller occurs with the virtual stack. You use the Lua API to place the return values at the top of the stack, with the rightmost value occupying the top position. You do not need to clear the stack before setting this up. Lua handles all items beneath the return values on the stack properly. The integer value that is returned by the C extension function is used by Lua to determine the number of Lua values to return to the caller. For example, suppose you want to return two values — <code class="literal">nil</code> and an error message — to the caller of your extension function. Assume that the stack already contains a number and a table in its topmost positions. The following code fragment accomplishes this:</p><pre class="programlisting">// Stk: Id NameTbl
lua_pushnil(L);
// Stk: Id NameTbl nil
lua_pushfstring(L, "Error locating user %d", Id);
// Stk: Id NameTbl nil ErrStr
return 2;</pre><p>Stack diagrams make handling multiple return values properly somewhat easier. This is especially the case when different sets of values are conditionally returned.<a id="IDX-CHP-13-0015" class="indexterm"></a></p><p>In addition to the customary push and pop functions, Lua provides functions for removing, replacing, inserting, copying, and retrieving values on the stack at any valid position.</p><p>You may want to explore the use of tools that can automatically generate bindings from specially marked up C or C++. For example, SWIG (<code class="literal"><code class="systemitem">www.swig.org</code></code>) processes a specially prepared interface file and generates a source file that is linked to your application.<a id="IDX-CHP-13-0016" class="indexterm"></a></p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="communicating_between_lua_and"></a></h2></div></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_stacking_gymnastics"></a>Try It Out: Stacking Gymnastics</h3></div></div></div><p>In this exercise, you create a C extension function that does the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Receives zero or more integers as arguments</p></li><li class="listitem"><p>Verifies that each argument is an integer</p></li><li class="listitem"><p>Juggles some of these values using the Lua API and, after each maneuver, prints a diagram of the stack</p></li><li class="listitem"><p>Returns some values</p></li></ul></div><p>In addition to exploring various stack operations, this library illustrates the essential framework of an extension module written in C.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a new C file with the following contents:</p><pre class="programlisting">#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
#include &lt;stdio.h&gt;

#define STACKOP(Code) (Code), LclStackPrint(L, #Code)

/* * */

static void LclStackPrint(
   lua_State *L,
   const char * Str)

{ // LclStackPrint
   int J, Top;

   printf("%-26s [", Str);
   Top = lua_gettop(L);
   for (J = 1; J &lt;= Top; J++) {
     if (lua_isnil(L, J)) printf(" - ");
     else printf(" %d ", lua_tointeger(L, J));
   } // J
   printf("]\n");
} // LclStackPrint

/* * */

static int LclStackLook(
    lua_State *L)

    // three integers &lt;- stack.look(zero or more integers)

{ // LclStackLook
    int J, Top;

    for (J = 1, Top = lua_gettop(L); J &lt;= Top; J++)</pre><pre class="programlisting">luaL_checkinteger(L, J);
 LclStackPrint(L, "Initial stack");
 STACKOP(lua_settop(L, 3));
 STACKOP(lua_settop(L, 5));
 STACKOP(lua_pushinteger(L, 5));
 STACKOP(lua_pushinteger(L, 4));
 STACKOP(lua_replace(L, −4));
 STACKOP(lua_replace(L, 5));
 STACKOP(lua_remove(L, 3));
 STACKOP(lua_pushinteger(L, 3));
 STACKOP(lua_insert(L, −3));
 STACKOP(lua_pushvalue(L, 2));
 STACKOP(lua_pop(L, 1));
 return 3;
} // LclStackLook

/* * */

int luaopen_stacklook(
    lua_State *L)

{ // luaopen_stacklook
   static const luaL_reg Map[] = {
       {"look", LclStackLook},
       {NULL, NULL}
 };

 luaL_register(L, "stack", Map);
 return 1;
} // luaopen_stacklook</pre></li><li class="listitem"><p>Save the file as <code class="literal">stacklook.c</code>.</p></li><li class="listitem"><p>Compile the file into a shared library. On Linux and other Unix-type systems, run the following:</p><pre class="programlisting">cc -o stacklook.so -shared -Wall stacklook.c</pre><p>On Windows, run the following:</p><pre class="programlisting">cl /c /Zl /Zd /Yd /MD /W4 /DWIN32 stacklook.c
link /dll /out:stacklook.dll /base:0x68100000 /machine:ix86 <div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/U002.png" alt="Try It Out: Stacking Gymnastics" width="12" height="12"></div>
   /export:luaopen_stacklook stacklook.obj msvcrt.lib lua5.1.lib</pre></li><li class="listitem"><p>With your editor, create a new Lua file with the following contents:</p><pre class="programlisting">package.cpath = "./?.so;./?.dll"
require "stacklook"

print("stack.look", stack.look(1, 2, 3, 4, 5, 6, 7))</pre></li><li class="listitem"><p>Save it as <code class="literal">look.lua</code>.</p></li><li class="listitem"><p>Run this script with the standalone Lua interpreter, as follows:</p><pre class="programlisting">lua look.lua</pre></li></ol></div><p>The output is this:</p><pre class="programlisting">Initial stack          [ 1 2 3 4 5 6 7 ]
lua_settop(L, 3)       [ 1 2 3 ]
lua_settop(L, 5)       [ 1 2 3 - - ]
lua_pushinteger(L, 5)  [ 1 2 3 - - 5 ]
lua_pushinteger(L, 4)  [ 1 2 3 - - 5 4 ]
lua_replace(L, −4)     [ 1 2 3 4 - 5 ]
lua_replace(L, 5)      [ 1 2 3 4 5 ]
lua_remove(L, 3)       [ 1 2 4 5 ]
lua_pushinteger(L, 3)  [ 1 2 4 5 3 ]
lua_insert(L, −3)      [ 1 2 3 4 5 ]
lua_pushvalue(L, 2)    [ 1 2 3 4 5 2 ]
lua_pop(L, 1)          [ 1 2 3 4 5 ]
stack.look      3     4    5</pre></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-037"></a>How It Works</h3></div></div></div><p>The sequence of steps taken when this script is run follows a pattern that is common to many extension libraries.</p><p>This is the first line to be executed in the script:</p><pre class="programlisting">package.cpath = "./?.so;./?.dll"</pre><p>It restricts Lua's search for C libraries to the current directory. This is appropriate here because, as a demonstration, the <code class="literal">stacklook</code> library won't be copied to the Lua library directory.</p><p>The next line engages Lua's package system to search for and load the <code class="literal">stacklook</code> module:</p><pre class="programlisting">require "stacklook"</pre><p>The steps taken here are summarized in <a class="link" href="ch07.html" title="Chapter 7. Using Modules">Chapter 7</a>.</p><p>Lua joins the string <code class="literal">luaopen_</code> with the name of the module and calls the function with that name in the loaded library, passing it a pointer to the active Lua state. Here, the function <code class="literal">luaopen_stacklook</code> is called. That function must be visible to Lua when it links with the library. When linking the dynamic link library on Windows, the following switch is used to satisfy this requirement:</p><pre class="programlisting">/export:luaopen_stacklook</pre><p>Notice that <code class="literal">luaopen_stacklook</code> receives only the state pointer as an argument. When a C function is called by Lua (either a loader function like this one, or a C extension function), it receives arguments that were passed to it on the virtual stack.</p><p>The <code class="literal">luaopen_stacklook</code> function is where the extension function <code class="literal">LclStackLook</code> is registered with Lua. This can be done in a number of ways, but a standard way of doing it is to use <code class="literal">luaL_register</code>. This function places the extension functions you specify into a namespace table and associates them with the names you want them to have in Lua. The current program uses it as follows:</p><pre class="programlisting">luaL_register(L, "stack", Map);</pre><p>As always with Lua API functions other than <code class="literal">lua_open</code>, the Lua state pointer is passed as the first argument. The convention of naming this pointer <code class="literal">L</code> is used here. The second argument is the name of the table to use as a namespace. In this case, <code class="literal">stack</code> is used. If a name is specified that doesn't identify a table and isn't a key in the <code class="literal">package.loaded</code> table, a new table with the specified name will be created. Alternatively, you can arrange to place a table at the top of the stack using the Lua API and specify <code class="literal">NULL</code> for this argument, in which case the table will be used. The third and last argument is the address of an array of records of type <code class="literal">luaL_Reg</code>. Records of this type pair a name with an extension function. The last element in this array must contain <code class="literal">NULL</code> values to mark the end of the array. In this case, the array is named <code class="literal">Map</code> and contains only two elements: the record that pairs the function <code class="literal">LclStackLook</code> with the name "look", and the terminating record. The call to <code class="literal">luaL_register</code> associates <code class="literal">stack.look</code> with the C function <code class="literal">LclStackLook</code> and leaves the <code class="literal">stack</code> table at the top of the stack.<a id="IDX-CHP-13-0017" class="indexterm"></a></p><p>The following line indicates that <code class="literal">luaopen_stacklook</code> is to return the virtual stack's topmost value, that is, the <code class="literal">stack</code> table, as the return value from <code class="literal">require</code>:</p><pre class="programlisting">return 1;</pre><p>If <code class="literal">luaopen_stacklook</code> returned <code class="literal">0</code> instead, then <code class="literal">require</code> would have returned nothing.</p><p>After <code class="literal">luaopen_stacklook</code> returns, control is transferred back to <code class="literal">look.lua</code>. The next line to be executed is as follows:</p><pre class="programlisting">print("stack.look", stack.look(1, 2, 3, 4, 5, 6, 7))</pre><p>This function calls <code class="literal">stack.look</code> with a number of integer arguments and prints the values that this function returns. Nothing in this setup makes a distinction between a C function and a Lua function — that's a detail that the Lua engine takes care of. Like every C extension function, <code class="literal">LclStackLook</code> is called with the single state pointer argument and a new virtual stack containing the passed arguments.</p><p>When <code class="literal">stack.look</code> is called, control is transferred back to the C library, this time to the function <code class="literal">LclStackLook</code>. The first operation it performs is to verify the passed-in arguments:</p><pre class="programlisting">for (J = 1, Top = lua_gettop(L); J &lt;= Top; J++)
    luaL_checkinteger(L, J);</pre><p>Like all Lua functions that begin with <code class="literal">luaL_</code>, the <code class="literal">luaL_checkinteger</code> function is an auxiliary function — it is not part of the formal API but a helper function that uses API functions. And like all Lua functions that begin with <code class="literal">luaL_check</code>, this function verifies some characteristic about the virtual stack. In this particular case, a check is made to verify that each argument is an integer. If it is, the integer is returned (and ignored in this case); otherwise, an error is generated.</p><p>The effect of the various stack functions should be clear from the program output. The <code class="literal">lua_settop</code> function lets you specify the number of values on the stack. As shown in the first two <code class="literal">lua_settop</code> calls, reducing the stack top effectively clears the truncated values. These can't be recovered by increasing the stack top. The functions beginning with <code class="literal">lua_push</code> increase the top position by one and place the specified value in that location. The <code class="literal">lua_replace</code> function moves the top value to another position, overwriting the value currently in that location. The <code class="literal">lua_insert</code> function is similar, except that room for the moved value is made by moving every item above it up by one. To remove one or more items from the top of the stack, call <code class="literal">lua_pop</code>. To remove an item from a specified location in the stack, call <code class="literal">lua_remove</code>.</p><p>The following line indicates that three values are to be returned from <code class="literal">stack.look</code>, with the topmost value on the stack corresponding to the rightmost value returned:<a id="IDX-CHP-13-0018" class="indexterm"></a><a id="IDX-CHP-13-0019" class="indexterm"></a><a id="IDX-CHP-13-0020" class="indexterm"></a><a id="IDX-CHP-13-0021" class="indexterm"></a><a id="IDX-CHP-13-0022" class="indexterm"></a><a id="IDX-CHP-13-0023" class="indexterm"></a><a id="IDX-CHP-13-0024" class="indexterm"></a><a id="IDX-CHP-13-0025" class="indexterm"></a></p><pre class="programlisting">return 3;</pre><p>Just like the loader function, an extension function returns values to Lua on the virtual stack. The integer return value of the C function indicates the number of items at the top of the stack that will be transferred as return values to the Lua function.</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="calling_lua_from_c"></a>Calling Lua from C</h1></div></div></div><p>A function written in Lua or one written in C and registered with a Lua state is a Lua value of type <span class="emphasis"><em>function</em></span>. As such, it can be managed on the stack like any other Lua value.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="obtaining_a_lua_function"></a>Obtaining a Lua Function</h2></div></div></div><p>You can place a function value on the virtual stack in a number of ways, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Pass a function as an argument to a C function</p></li><li class="listitem"><p>Retrieve a function from a global variable or namespace table</p></li><li class="listitem"><p>Create a function from C code using the <code class="literal">lua_pushcfunction</code> or <code class="literal">lua_pushcclosure</code> functions</p></li><li class="listitem"><p>Load some Lua code as a chunk using the <code class="literal">lua_load, luaL_loadstring</code> or <code class="literal">luaL_loadfile</code> functions</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="calling_a_lua_function"></a>Calling a Lua Function</h2></div></div></div><p>To call a Lua function, do the following:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Push the function on the stack.</p></li><li class="listitem"><p>Push the arguments to the function, left to right, on the stack.</p></li><li class="listitem"><p>Call <code class="literal">lua_call</code> with the state pointer, the number of arguments you have just pushed, and the number of results to receive from the called function.</p></li></ol></div><p>The following example assumes that a function like the following is located at position 1 on the stack:</p><pre class="programlisting">local function MouseClick(X, Y, Button)
    print("Mouse click", X, Y, Button)
end</pre><p>This would be the case if, for example, the function was passed as the first argument to a C function. For example:</p><pre class="programlisting">// Stk: ...
lua_pushvalue(L, 1);
// Stk: ... Fnc
lua_pushinteger(L, X);</pre><pre class="programlisting">// Stk: ... Fnc X
lua_pushinteger(L, Y);
// Stk: ... Fnc X Y
lua_pushstring(L, Btn == 1 ? "left" : Btn == 2 ? "right" : "middle");
// Stk: ... Fnc X Y BtnStr
lua_call(L, 3, 0);
// Stk: ...</pre><p>When <code class="literal">lua_call</code> is called, the arguments and the function are popped from the stack. Any values that are returned from the function are adjusted to the specified result count and pushed on the stack. In this example, the result count is zero, so any values that the called function returns will be thrown away. If a result count is specified that is greater than the number of values actually returned, <code class="literal">nil</code>s are pushed to take up the slack. If you want to receive as many values as the function returns, specify <code class="literal">LUA_MULTRET</code> for the result count. If you do this, you'll want to call <code class="literal">lua_gettop</code> before you push the function and again after the function returns to ascertain the number actually returned.<a id="IDX-CHP-13-0026" class="indexterm"></a><a id="IDX-CHP-13-0027" class="indexterm"></a></p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="protected_calls"></a>Protected Calls</h2></div></div></div><p>You can call a Lua function in protected mode — in other words, call the function and handle the error if one is generated. For this, use the <code class="literal">lua_pcall</code> function. This function is like <code class="literal">lua_call</code> except that it returns a status code and has an additional argument: the location on the stack of an error handler. The return code is zero if the function succeeds. In this case, the return values will be pushed just as <code class="literal">lua_call</code> would do. If an error occurs, <code class="literal">LUA_ERRRUN, LUA_ERRMEM</code>, or <code class="literal">LUA_ERRERR</code> will be returned, and only a single error message will be pushed on the stack, regardless of the value specified for the result count.<a id="IDX-CHP-13-0028" class="indexterm"></a></p><p>The error handler is a function that will be called when an error occurs, before the stack has been truncated to its state as of the call to <code class="literal">lua_pcall</code>. It receives as its single argument an error message, and returns a single value: the revised error message. Typically, an error handler will call on the services of <code class="literal">debug.traceback</code> to augment the error message with stack information. To avoid having an error handler called, specify 0 for its stack location. Otherwise, you need to arrange to have the error handler placed on the stack so you can specify its position when calling <code class="literal">lua_pcall</code>.</p><p>Here's an example of making a protected call. It is assumed that the function to call is located at position 1, and that <code class="literal">debug.traceback</code> has been placed in position 2.</p><pre class="programlisting">// Stk: ...
lua_pushvalue(L, 1);
// Stk: ... Fnc
lua_pushinteger(L, X);
// Stk: ... Fnc X
lua_pushinteger(L, Y);
// Stk: ... Fnc X Y
lua_pushstring(L, Btn == 1 ? "left" : Btn == 2 ? "right" : "middle");
// Stk: ... Fnc X Y BtnStr
Code = lua_pcall(L, 3, 0, 2);
if (Code) {
  // Stk: ... ErrStr
  printf("%s occurred.\n%s\n",
    Code == LUA_ERRRUN ? "A runtime error" :
    Code == LUA_ERRMEM ? "A memory error" : "An error handling error",</pre><pre class="programlisting">lua_tostring(L, −1));
  lua_pop(L, 1);
  // Stk: ...
} // if
// Stk: ...</pre><p>Now, when the following Lua function from the preceding example is called:<a id="IDX-CHP-13-0029" class="indexterm"></a><a id="IDX-CHP-13-0030" class="indexterm"></a><a id="IDX-CHP-13-0031" class="indexterm"></a><a id="IDX-CHP-13-0032" class="indexterm"></a><a id="IDX-CHP-13-0033" class="indexterm"></a></p><pre class="programlisting">local function MouseClick(X, Y, Button)
  print("Mouse click", X, Y, Button)
  error("Intentionally generated error")
end</pre><p>it produces output like this:</p><pre class="programlisting">Mouse click 245 168 right
A runtime error occurred.
test.lua:7: Intentionally generated error
stack traceback:
  [C]: in function 'error'
  test.lua:7: in function &lt;test.lua:5&gt;
  [C]: in function 'run'
  test.lua:11: in main chunk
  [C]: ?</pre><p>Lua takes care of cleaning up items on the stack left after an error, just as it does when no errors occur.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="working_with_userdata"></a>Working with Userdata</h1></div></div></div><p>The <span class="emphasis"><em>userdata</em></span> basic type maps to memory that is only accessible in C. In fact, unless the userdata has been extended with metatables, all a Lua script can do with one is to assign it to a variable and to check whether it is identical to another variable. From within C, the <code class="literal">lua_touserdata</code> function is used to retrieve the pointer associated with the userdata.</p><p>Userdata comes in two varieties: light and full. A low-calorie userdata is created with the <code class="literal">lua_pushlightuserdata</code> function. It simply maps the new userdata to a pointer that you provide to the API — Lua does not allocate any memory for it and won't allow you to extend it with metatables. A full userdata is much more useful for the purposes of an extension library. You create it with a call to <code class="literal">lua_newuserdata</code>, passing it the obligatory state pointer and the size of the memory you want to have allocated. Always use the C program's <code class="literal">sizeof</code> operator to specify the size of the record you'll associate with the userdata. The calling C program receives the address of the full userdata, and the userdata value is pushed on the virtual stack.</p><p>Metatables are used both to define operations for a userdata and to classify it as an instance of a particular user-defined type. For example, if you use a full userdata to encapsulate a printer connection, you'll want to provide relevant methods that can be called from Lua. Furthermore, you don't want to confuse a printer userdata with a database userdata. Lua's auxiliary library helps by letting you give a name to the user-defined type, such as <code class="literal">printer</code>. You can create a metatable for this purpose with the <code class="literal">luaL_newmetatable</code> function. A good place to create a metatable is in an extension library's loader function. It's also convenient to set the metatable's <code class="literal">__index</code> metamethod to the metatable itself. This way, you can use <code class="literal">luaL_register</code> to register any methods you want to associate with the user-defined type directly in the metatable.</p><p>The <code class="literal">__gc</code> garbage collection metamethod is a particularly useful mechanism for cleaning up the resources that a userdata may have open in C. Where appropriate, it is good practice to provide a <code class="literal">close</code> method for your userdata types. However, the <code class="literal">close</code> method may not have been called when the userdata is collected as garbage. You can check for this condition in the <code class="literal">__gc</code> metamethod and finalize resources if necessary.</p><div class="sidebar"><a id="try_it_out_colon_the_life_and_times_of_a"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: The Life and Times of a Userdata</strong></p></div></div></div><p>This exercise implements some of a userdata's rites of passage from cradle to grave, including its creation, association with a metatable, access from Lua, and destruction.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a new C file with the following contents:</p><pre class="programlisting">#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
#include &lt;stdio.h&gt;

#define CnExampleStr "example"

typedef struct {
    int Val;
    int Open;
} ExampleType, * ExamplePtrType;

/* * */

static ExamplePtrType LclExamplePtrGet(
    lua_State *L,
    int StkPos)

    /* Returns example pointer if value at position StkPos is valid and open,
    otherwise an error is generated. */

{  // LclExamplePtrGet
   ExamplePtrType ExamplePtr = luaL_checkudata(L, StkPos, CnExampleStr);
    if (! ExamplePtr-&gt;Open)
      luaL_error(L, "attempt to use a closed " CnExampleStr);
    return ExamplePtr;
} // LclExamplePtrGet

/* * */

static int LclExampleStr(
    lua_State *L)

    // "example" &lt;- tostring(ExampleHnd)

{  // LclExampleStr
   ExamplePtrType ExamplePtr;</pre><pre class="programlisting">// Stk: ExampleHnd?
    ExamplePtr = luaL_checkudata(L, 1, CnExampleStr);
    if (ExamplePtr-&gt;Open)
    lua_pushfstring(L, CnExampleStr " (%d)", ExamplePtr-&gt;Val);
    else lua_pushfstring(L, CnExampleStr " (%d, closed)", ExamplePtr-&gt;Val);
    // Stk: ExampleHnd IdStr
    return 1;
}  // LclExampleStr

/* * */

static int LclExampleGet(
    lua_State *L)

    // Val &lt;- ExampleHnd:get()

{  // LclExampleGet
   ExamplePtrType ExamplePtr = LclExamplePtrGet(L, 1);
   // Stk: ExampleHnd
   lua_pushnumber(L, ExamplePtr-&gt;Val);
   printf("Retrieving value of " CnExampleStr " (%d)\n", ExamplePtr-&gt;Val);
   // Stk: ExampleHnd Val
   return 1;
}  // LclExampleGet

/* * */

static int LclExampleSet(
    lua_State *L)

    // OldVal &lt;- ExampleHnd:set(NewVal)

{  // LclExampleSet
   int Val;
   // Stk: ExampleHnd? NewVal?
   ExamplePtrType ExamplePtr = LclExamplePtrGet(L, 1);
   // Stk: ExampleHnd NewVal?
   Val = luaL_checkint(L, 2);
   // Stk: ExampleHnd NewVal
   printf("Setting value of " CnExampleStr " from %d to %d\n",
   ExamplePtr-&gt;Val, Val);
   lua_pushnumber(L, ExamplePtr-&gt;Val);
   // Stk: ExampleHnd NewVal OldVal
   ExamplePtr-&gt;Val = Val;
    return 1;
}  // LclExampleSet

/* * */

static int LclExampleClose(
    lua_State *L)

    // ExampleHnd:close()

{  // LclExampleClose</pre><pre class="programlisting">ExamplePtrType ExamplePtr = LclExamplePtrGet(L, 1);
   printf("Closing " CnExampleStr " (%d) explicitly\n", ExamplePtr-&gt;Val);
   ExamplePtr-&gt;Open = 0;
   return 0;
}  // LclExampleClose

/* * */

static int LclExampleGc(
    lua_State *L)

    // metatable(ExampleHnd).__gc(ExampleHnd)

{  // LclExampleGc
   ExamplePtrType ExamplePtr = luaL_checkudata(L, 1, CnExampleStr);
   if (ExamplePtr-&gt;Open) {
      printf("Collecting and closing " CnExampleStr " (%d)\n",
          ExamplePtr-&gt;Val);
      ExamplePtr-&gt;Open = 0;
 }  // if
 else printf("Collecting " CnExampleStr " (%d), already closed\n",
    ExamplePtr-&gt;Val);
 return 0;
}  // LclExampleGc

/* * */

static int LclExampleOpen(
    lua_State *L)

   // ExampleHnd &lt;- example.open(PosNum)

{  // LclExampleOpen
    int Val;
    ExamplePtrType ExamplePtr;

    // Stk: Val?
    Val = luaL_checkint(L, 1);
    // Stk: Val
    ExamplePtr = lua_newuserdata(L, sizeof(ExampleType));
    printf("Opening " CnExampleStr " (%d)\n", Val);
    // Stk: Val ExampleHnd
    ExamplePtr-&gt;Val = Val;
    ExamplePtr-&gt;Open = 1;
    luaL_getmetatable(L, CnExampleStr);
    // Stk: Val ExampleHnd metatable
    lua_setmetatable(L, −2);
    // Stk: Val ExampleHnd
    return 1;
}  // LclExampleOpen

/* * */

int luaopen_ud_example(
    lua_State *L)</pre><pre class="programlisting">{  // luaopen_ud_example

  static const luaL_reg MetaMap[] = {
    {"close", LclExampleClose},
    {"get", LclExampleGet},
    {"set", LclExampleSet},
    {"__tostring", LclExampleStr},
    {"__gc", LclExampleGc},
    {NULL, NULL}
  }; // MetaMap

  static const luaL_reg Map[] = {
    {"open", LclExampleOpen},
    {NULL, NULL}
  }; // Map

  // Stk: ModuleStr
  // Create metatable for handles of type "example"
  luaL_newmetatable(L, CnExampleStr);
  // Stk: ModuleStr Meta
  // Push copy of metatable
  lua_pushvalue(L, −1);
  // Stk: ModuleStr Meta Meta
  // Retrieve indexed fields from metatable itself
  lua_setfield(L, −2, "__index");
  // Stk: ModuleStr Meta
  // Register functions in metatable at top of stack
  luaL_register(L, NULL, MetaMap);
  // Stk: ModuleStr Meta
  luaL_register(L, "ud_example", Map);
  // Stk: ModuleStr Meta Namespace
  return 1;
} // luaopen_ud_example</pre></li><li class="listitem"><p>Save the file as <code class="literal">ud_example.c</code>.</p></li><li class="listitem"><p>Compile this extension into a shared library. On Linux and other Unix-type systems, run this command:</p><pre class="programlisting">cc -o ud_example.so -shared -Wall ud_example.c</pre><p>On the Windows platform, compile the extension as follows:</p><pre class="programlisting">cl /c /Zl /Zd /Yd /MD /W4 ud_example.c
link /dll /out:ud_example.dll /base:0x68200000 /machine:ix86 <div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/U002.png" alt="Try It Out: The Life and Times of a Userdata" width="12" height="12"></div>
   /export:luaopen_ud_example ud_example.obj msvcrt.lib lua5.1.lib</pre></li><li class="listitem"><p>Create a new Lua file with the following contents:</p><pre class="programlisting">package.cpath = "./?.so;./?.dll"
require "ud_example"

local HndA = ud_example.open(1)
local HndB = ud_example.open(2)
do -- local block
  local HndC = ud_example.open(3)</pre><pre class="programlisting">io.write(tostring(HndA), ", ", tostring(HndB), ", ", tostring(HndC), "\n")
  HndA:set(4)
  HndA:set(1)
  HndA:close()
  io.write("End of local block\n")
end
collectgarbage("collect")
io.write("End of script\n")</pre></li><li class="listitem"><p>Save this file as <code class="literal">ud.lua</code>.</p></li><li class="listitem"><p>Run this script from a command shell:</p><pre class="programlisting">lua ud.lua</pre><p>The script generates this output:</p><pre class="programlisting">Opening example (1)
Opening example (2)
Opening example (3)
example (1), example (2), example (3)
Setting value of example from 1 to 4
Setting value of example from 4 to 1
Closing example (1) explicitly
End of local block
Collecting and closing example (3)
End of script
Collecting and closing example (2)
Collecting example (1), already closed</pre></li></ol></div><p><span class="strong"><strong>How It Works</strong></span></p><p>This example implements a simple userdata whose only job is to store an integer and, on demand, return it. But the essential framework is the same as the implementation of more practical user-defined types. The important aspects of this are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The association of a userdata with a metatable to both extend its functionality and to identify it as a particular user-defined type</p></li><li class="listitem"><p>The access of userdata memory in C</p></li><li class="listitem"><p>The registration of the <code class="literal">__gc</code> metamethod so that a userdata will be eventually closed by the garbage collector if it isn't closed explicitly in a Lua script</p></li></ul></div><p>The script and the library follow a number of steps. Like the preceding Try It Out, this example is a demonstration that really doesn't belong in a standard Lua location, so the library search is restricted to the current directory. This is done with the following line:</p><pre class="programlisting">package.cpath = "./?.so;./?.dll"</pre><p>The following line loads the extension library and calls <code class="literal">luaopen_ud_example</code>:</p><pre class="programlisting">require "ud_example"</pre><p>This function calls <code class="literal">luaL_newmetatable</code> to create a metatable that will be shared by all userdata instances created in <code class="literal">ud_example</code> extension. The new metatable is associated with the name (which in this case is <code class="literal">example</code>) by which it can be retrieved later.</p><p>A userdata can't contain key/value pairs directly the way a Lua table can, but it can implement this behavior using the <code class="literal">__index</code> metamethod. For example, when a userdata is indexed in the following line, the <code class="literal">__index</code> metamethod that resolves the <code class="literal">get</code> method:</p><pre class="programlisting">Hnd:get()</pre><p>Here, the metatable itself is associated with the <code class="literal">"__index"</code> key, so that is where values are looked for by name.</p><p>The ordinary methods <code class="literal">close, get</code>, and <code class="literal">set</code> and the metamethods <code class="literal">__tostring</code> and <code class="literal">__gc</code> are placed into the metatable with the following line:</p><pre class="programlisting">luaL_register(L, NULL, MetaMap);</pre><p>Notice that the second argument to this function, the library name, is specified as <code class="literal">NULL</code>. This instructs the function to place the specified functions into the table that resides at the top of the stack, which in this case is the metatable.</p><p>The registration of the userdata methods is followed by the registration of the <code class="literal">ud_example</code> library's only function: <code class="literal">open</code>.</p><p>The return value of <code class="literal">1</code> indicates that the stack's topmost value, namely the namespace table containing the <code class="literal">open</code> function, is to be returned from the call to <code class="literal">require</code>.</p><p>Back in the <code class="literal">ud.lua</code> script, three example handles are created with calls to <code class="literal">ud_example.open</code>. To test the <code class="literal">__gc</code> metamethod, the third handle is created in a local block where it will be allowed to go out of scope without being explicitly closed.</p><p>The <code class="literal">LclExampleOpen</code> C function manages the opening of these example handles. After verifying that the passed argument is indeed an integer, the userdata is created with a call to <code class="literal">lua_newuserdata</code>. In this extension library, the returned userdata memory is mapped to a structure of ExampleType. The fields of this structure are initialized; the <code class="literal">Val</code> field receives the value of the passed-in argument, and the <code class="literal">Open</code> field is set to a non-zero value. These operations are just placeholders for what could be, in a library having more features, the initialization of resources such as database connections.</p><p>As a last step before returning the handle to the caller, the metatable is retrieved and assigned to the new userdata. The metatable that was created in the loader function is retrieved by name in the following line:</p><pre class="programlisting">luaL_getmetatable(L, CnExampleStr);</pre><p>The same metatable will be shared by all userdatas created by <code class="literal">ud_example.open</code>. The stack's topmost value, the new userdata, is returned by specifying a return value of <code class="literal">1</code>.</p><p>After receiving a handle to the new userdata, the Lua script can interact with it by calling its various methods. When a method such as <code class="literal">set</code> is called, the invoked C function calls on the helper function <code class="literal">LclExamplePtrGet</code> to retrieve a pointer to the structure associated with the userdata. This helper function first verifies that the specified argument is a userdata of the right type. It does this in the following line:<a id="IDX-CHP-13-0034" class="indexterm"></a><a id="IDX-CHP-13-0035" class="indexterm"></a></p><pre class="programlisting">ExamplePtrType ExamplePtr = luaL_checkudata(L, StkPos, CnExampleStr);</pre><p>This auxiliary function checks to make sure the value is a userdata and that its metatable is the one associated with the specified name (which in this example is <code class="literal">CnExampleStr</code>). If these criteria are met, <code class="literal">luaL_checkudata</code> returns a pointer to the memory structure associated with the userdata. If they aren't, an error is generated. The returned structure is then checked to verify that the handle is still open. This is strictly an extension issue — Lua doesn't know anything about the resources that you manage in the memory structure. If everything is as expected, <code class="literal">LclExamplePtrGet</code> returns the structure pointer to the caller; if not, an error is generated.</p><p>In the <code class="literal">ud.lua</code> script, the third handle is allowed to fall out of scope while it is still open. It can't be accessed by the Lua script and, because no copy of the userdata was stored in the C code, it can't be accessed by C. Lua consequently is able to classify the userdata as garbage. Lua calls the <code class="literal">__gc</code> metamethods of collectable userdata in the reverse order of their creation. When it is invoked in this library, the <code class="literal">LclExampleGc</code> C function has the chance to close its open resources.</p><p>Of the two remaining handles, one is closed explicitly and the other is left dangling when the script ends. Because the script ends normally, Lua's garbage collector is run one last time, and this is where the remaining open handle is closed.</p></div><p>Although a userdata's <code class="literal">__gc</code> metamethod is a good place to make sure resources have been finalized, garbage collection cycles may occur somewhat sporadically. It's usually prudent to include and document a <code class="literal">close</code> method in your library's interface so the Lua script can avoid taxing the system with too many open resources or situations where a resource needs to be closed for further processing.</p><p>Unlike Unix-type systems, Windows performs some character processing when it reads from and writes to text files. For example, when a linefeed control character (decimal value 10) is written in text mode, it is converted to a carriage return/linefeed pair (decimal values 13 and 10). The reverse is done when reading in text mode. Additionally, the Ctrl+Z control character (decimal value 26) is interpreted as the end of a file. Whatever arguments can be made for or against this type of character translation, programs that work with Windows need to deal with it. (Unix-like systems don't distinguish text files from other types of files.) Fortunately, when you're explicitly opening a file in Lua or C, you've got control over the mode it will be opened in, and you can avoid the consequences of having character translation occur on the wrong type of file by opening it in binary mode. Unfortunately, when Windows launches a program, it sets up the standard input, output and error file handles in text mode. This effectively prevents Windows programs from reading and writing binary data using the standard input and output streams in the default case.</p><p>In the following Try It Out, you extend the <code class="literal">io</code> library by working with the file userdata.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="working_with_userdat"></a></h2></div></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_setting_the_mode_of_fil"></a>Try It Out: Setting the Mode of Files</h3></div></div></div><p>Here, you extend Lua so that the mode of a file can be changed after it has been opened. You do it in such a way that it intentionally has no effect on Unix-like systems. Before proceeding, make sure your development system is set up as recommended in <a class="link" href="ch01.html" title="Chapter 1. Getting Situated">Chapter 1</a>.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Using your text editor, create a new file with the following C program:</p><pre class="programlisting">#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
#include &lt;string.h&gt;
#ifdef WIN32
#include &lt;io.h&gt;
#include &lt;fcntl.h&gt;
#endif

/* * */

static int LclIoModeSet(
    lua_State *L)

{  // LclIoModeSet
   FILE **StrmPtr = (FILE **) luaL_checkudata(L, 1, LUA_FILEHANDLE);
   if (*StrmPtr) {
      int Bin = 0;
      const char *ModeStr = luaL_checkstring(L, 2);
      if (0 == strcmp("binary", ModeStr)) Bin = 1;
      else if (0 != strcmp("text", ModeStr)) luaL_error(L, "expecting either "
         LUA_QL("binary") " or " LUA_QL("text") " mode");
#ifdef WIN32
      _setmode(_fileno(*StrmPtr), Bin ? _O_BINARY : _O_TEXT);
#endif
    }  // if
   else luaL_error(L, "attempt to access a closed file");
   return 0;
}  // LclIoModeSet

/* * */

int luaopen_iomode(
  lua_State *L)

{  // luaopen_iomode
   static const luaL_reg Map[] = {
       {"modeset", LclIoModeSet},
       {NULL, NULL}
   };

   luaL_register(L, LUA_IOLIBNAME, Map);
   return 1;
} // luaopen_iomode</pre></li><li class="listitem"><p>Save this file as <code class="literal">iomode.c</code>.</p></li><li class="listitem"><p>Compile this extension into a shared library. On Linux and other Unix-type systems, run this command:</p><pre class="programlisting">cc -o iomode.so -shared -Wall iomode.c</pre><p>On the Windows platform, compile the extension as follows:</p><pre class="programlisting">cl /c /Zl /Zd /Yd /MD /W4 /DWIN32 iomode.c
link /dll /out:iomode.dll /base:0x67900000 /machine:ix86 <div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/U002.png" alt="Try It Out: Setting the Mode of Files" width="12" height="12"></div>
   /export:luaopen_iomode iomode.obj msvcrt.lib lua5.1.lib</pre></li><li class="listitem"><p>Copy the generated module to your designated Lua library directory. On Unix-type systems, run this:</p><pre class="programlisting">cp iomode.so $LUA_DIR/</pre><p>On Windows, run this:</p><pre class="programlisting">xcopy iomode.dll "%LUA_DIR%\*.*"</pre></li><li class="listitem"><p>Create a new file with the following contents:</p><pre class="programlisting">local Arg = string.lower(arg[1] or "")
local Read = string.match(Arg, "r")
local Mode = string.match(Arg, "b") and "binary" or "text"

require "iomode"

io.modeset(io.stdout, Mode)
io.modeset(io.stdin, Mode)

if Read then
   local Str = io.read("*all")
   for J = 1, #Str do
       local Val = string.byte(Str, J, J)
       if Val &gt;= 32 then
         io.write("'", string.sub(Str, J, J), "' ")
       else
         io.write(string.format("0x%02x ", Val))
       end
     end
     io.write("\n")
   else -- Write
     io.write("1\0132\0103\0264")
   end</pre></li><li class="listitem"><p>Save this file as <code class="literal">iotest.lua</code>.</p></li><li class="listitem"><p>Test the library as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>Depending on your platform, the generated output you get may not look the same as shown here; that will be discussed shortly.</p></blockquote></div><pre class="programlisting"><strong class="userinput"><code>lua iotest.lua w | lua iotest.lua r</code></strong>
'1' 0x0d '2' 0x0a  '3'

<strong class="userinput"><code>lua iotest.lua wb | lua iotest.lua r</code></strong>
'1' 0x0d '2' 0x0a  '3'

<strong class="userinput"><code>lua iotest.lua w | lua iotest.lua rb</code></strong>
'1' 0x0d '2' 0x0d 0x0a '3' 0x1a '4'

<strong class="userinput"><code>lua iotest.lua wb | lua iotest.lua rb</code></strong>
'1' 0x0d '2' 0x0a '3' 0x1a '4'</pre></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-038"></a>How It Works</h3></div></div></div><p>Like the preceding examples, this one shows you the basic framework of an extension module written in C. It may seem like a lot of code to wrap around the <code class="literal">_setmode</code> and <code class="literal">_fileno</code> functions. But much of this is boilerplate code that is relatively unchanged from extension to extension. Additionally, you'll likely write helper functions to consolidate common statement sequences.</p><p>When the test script <code class="literal">iotest.lua</code> is run, the first three lines of the script examine the command line argument:</p><pre class="programlisting">local Arg = string.lower(arg[1] or "")
local Read = string.match(Arg, "r")
local Mode = string.match(Arg, "b") and "binary" or "text"</pre><p>If <code class="literal">r</code> or <code class="literal">R</code> is present, data is read from the standard input stream. If not, a series of bytes is written to the standard output stream. If <code class="literal">b</code> or <code class="literal">B</code> is present, binary mode is used; otherwise, text mode is used.</p><p>The next line of the test script handles the search for and loading of a Lua module:</p><pre class="programlisting">require "iomode"</pre><p>In this case, the dynamic link library <code class="literal">iomode.dll</code> or <code class="literal">iomode.so</code> is found and loaded.</p><p>The <code class="literal">luaopen_iomode</code> calls <code class="literal">luaL_register</code> to register <code class="literal">LclIoModeSet</code>. In this case, note that the name of an existing table is used for the <code class="literal">LUA_IOLIBNAME</code> namespace — this is Lua's symbolic name for the <code class="literal">io</code> table.</p><p>After <code class="literal">luaopen_iomode</code> returns, control is transferred back to <code class="literal">iotest.lua</code>. The next line to be executed is as follows:</p><pre class="programlisting">io.modeset(io.stdout, Mode)</pre><p>This function will set the mode of the standard output stream to either binary or text, depending on the argument passed to the script.</p><p>When <code class="literal">io.modeset</code> is called, control is transferred back to the C library, this time to the function <code class="literal">LclIoModeSet</code>. The first line it executes is this:</p><pre class="programlisting">FILE **StrmPtr = (FILE **) luaL_checkudata(L, 1, LUA_FILEHANDLE);</pre><p>This line verifies that the value at position one on the call stack (corresponding to the first argument passed to <code class="literal">io.modeset</code>) is in fact a file. If it is, the file (actually, a doubly indirected stream) is returned; otherwise an error is generated.</p><p>The userdata returned by <code class="literal">luaL_checkudata</code> is a pointer to a stream pointer. If the stream pointer is <code class="literal">NULL</code>, the file has been closed and an error with an appropriate message is generated. Otherwise, the <code class="literal">luaL_checkstring</code> function is used to verify that the second argument is a string. If it is, this function will return the string; otherwise, it will generate an error with a descriptive message.</p><p>It is extremely important that you do not modify string buffers that are held by Lua. Doing so would disrupt Lua's string interning mechanism with dire consequences for your program. Furthermore, any string pointer you obtain should be assumed valid only until control is returned to Lua.</p><div class="sidebar"><a id="about_the_file_value"></a><div class="titlepage"><div><div><p class="title"><strong>About the File Value</strong></p></div></div></div><p>At the shell prompt, if you execute the following:</p><pre class="programlisting">lua -e "print(io.stdin)"</pre><p>you see something like this:</p><pre class="programlisting">file (0x401d76e0)</pre><p>Lua has eight basic types and <code class="literal">file</code> isn't one of them. In fact, <code class="literal">io.stdin</code> is of type <code class="literal">userdata</code>. It is rendered by <code class="literal">tostring</code> (used by <code class="literal">print</code>) as <code class="literal">file</code> because of its particular metatable.</p><p>Usually, a C library defines its own userdatas. In this case, however, a userdata defined in the <code class="literal">io</code> library (the file <code class="literal">liolib.c</code> in the Lua source distribution) is used, because the function <code class="literal">LclIoModeSet</code> needs to operate on the underlying stream.</p></div><p>If the second argument is the binary or text string, a mode value is set accordingly; otherwise, an error is generated. Note that the error message uses the macro <code class="literal">LUA_QL</code> to provide standard quotes. This gives error messages a uniform appearance throughout Lua. The actual setting of the file mode takes place with the following lines:</p><pre class="programlisting">#ifdef WIN32
  _setmode(_fileno(*StrmPtr), Bin ? _O_BINARY : _O_TEXT);
#endif</pre><p>The fact that the real work of this binding occurs only on the Windows platform suggests that a Lua-only module could be implemented for Unix-like systems that could replace the <code class="literal">iomode</code> C library. At its simplest, it could consist of the following lines:</p><pre class="programlisting">function io.modeset(Hnd, Mode) end
return io</pre><p>Additional argument checking could be done to increase compatibility with the Windows library.</p><p>The following line indicates that no value is to be returned from <code class="literal">io.modeset</code>:</p><pre class="programlisting">return 0;</pre><p>The next line to be executed in the script is this:</p><pre class="programlisting">io.modeset(io.stdin, Mode)</pre><p>It follows the same sequence as the one preceding it in the script, except that it is the standard input stream that is modified.</p><p>The remainder of the script serves as a test of the <code class="literal">io.modeset</code> extension. If the script is to read the standard input stream (<code class="literal">r</code> or <code class="literal">R</code> is included as a command line argument to the script), the following code is run:</p><pre class="programlisting">local Str = io.read("*all")
for J = 1, #Str do
  local Val = string.byte(Str, J, J)
  if Val &gt;= 32 then
    io.write("'", string.sub(Str, J, J), "' ")
  else
    io.write(string.format("0x%02x ", Val))
  end
end
io.write("\n")</pre><p>Everything in the stream is read into a string, and each character in this string is visited in a loop. If the character is printable, it is displayed in quotes; otherwise, its value is displayed in hexadecimal.</p><p>If the script is to write a sequence to standard output (a <code class="literal">w</code> or <code class="literal">W</code> is included in the command line argument to the script), the following line is run:</p><pre class="programlisting">io.write("1\0132\0103\0264")</pre><p>This writes the following seven characters:</p><pre class="programlisting">1 <em class="replaceable"><code>carriage return</code></em> 2 <em class="replaceable"><code>linefeed</code></em> 3 <em class="replaceable"><code>Ctrl+Z</code></em> 4</pre><p>You specify the control characters using Lua's standard escape sequence in which a one-, two-, or three-digit decimal value follows a backslash. (Three digits are required if a decimal digit follows the sequence, as it does in each of the previous cases.)</p><p>To test the behavior of the extension library from a Windows command shell, the script is invoked in write mode, and its output is piped to the same script invoked in read mode. The four permutations of text and binary mode (text-text, binary-text, text-binary, and binary-binary) reveal how Windows translates certain characters, and how the <code class="literal">iomode</code> module can be used to enable binary data transfers through the standard streams.</p><p>Take a look at the output of the following commands:</p><pre class="programlisting"><strong class="userinput"><code>lua iotest.lua w | lua iotest.lua r</code></strong>
'1' 0x0d '2' 0x0a '3'

<strong class="userinput"><code>lua iotest.lua wb | lua iotest.lua r</code></strong>
'1' 0x0d '2' 0x0a '3'

<strong class="userinput"><code>lua iotest.lua w | lua iotest.lua rb</code></strong>
'1' 0x0d '2' 0x0d 0x0a '3' 0x1a '4'

<strong class="userinput"><code>lua iotest.lua wb | lua iotest.lua rb</code></strong>
'1' 0x0d '2' 0x0a '3' 0x1a '4'</pre><p>This output illustrates the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When writing in text mode, a single linefeed is translated as a carriage return/linefeed pair. A single carriage return or Ctrl+Z is not translated.</p></li><li class="listitem"><p>When reading in text mode, a carriage return/linefeed pair is translated to a single linefeed. A single carriage return is not translated. The Ctrl+Z character is processed as the end of the stream contents.<a id="IDX-CHP-13-0036" class="indexterm"></a><a id="IDX-CHP-13-0037" class="indexterm"></a><a id="IDX-CHP-13-0038" class="indexterm"></a><a id="IDX-CHP-13-0039" class="indexterm"></a><a id="IDX-CHP-13-0040" class="indexterm"></a><a id="IDX-CHP-13-0041" class="indexterm"></a></p></li><li class="listitem"><p>Reading and writing in binary mode disables character processing; everything written in this mode can be read again intact. This is the standard behavior in Linux and other Unix-like systems.</p></li></ul></div></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="indexing_values_in_c"></a>Indexing Values in C</h1></div></div></div><p>Manipulating tables is as important and pervasive in C as it is in Lua. The API gives you a number of ways to access tables and, by means of metamethods, other indexed values.<a id="IDX-CHP-13-0042" class="indexterm"></a></p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="retrieving_indexed_values"></a>Retrieving Indexed Values</h2></div></div></div><p>The <code class="literal">lua_gettable</code> function is used in C to perform the operation that performs in Lua:</p><pre class="programlisting">Val = Tbl[Key]</pre><p>The <code class="literal">__index</code> metamethod can make this operation valid for values of <code class="literal">Tbl</code> other than a table, or for a table that doesn't contain <code class="literal">Key</code>. This same metamethod behavior applies in C, so whether <code class="literal">Tbl</code> is a table or some other value that has an associated <code class="literal">__index</code> metamethod, the way to retrieve a value by key is as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Place <code class="literal">Tbl</code> on the stack at some known position.</p></li><li class="listitem"><p>Arrange to have <code class="literal">Key</code> placed at the top of the stack using one of the functions that begin with <code class="literal">lua_push</code>, such as <code class="literal">lua_pushvalue</code> or <code class="literal">lua_pushstring</code>.</p></li><li class="listitem"><p>Call <code class="literal">lua_gettable</code> with the Lua state pointer as the first argument and the stack position of <code class="literal">Tbl</code> as the second. For example, if <code class="literal">Tbl</code> occupies the fourth position from the top of the stack, you could call the following</p><pre class="programlisting">lua_gettable(L, −4);</pre></li><li class="listitem"><p>Replace the key at the top of the stack with <code class="literal">Tbl[Key]</code>. This value may be <code class="literal">nil</code>. In either case, the stack's top position does not change.</p></li></ol></div><p>In the event that you want to retrieve a value from a table without invoking <code class="literal">__index</code> if the key is missing, you can use the <code class="literal">lua_rawget</code> function. This does in C what <code class="literal">rawget</code> does in Lua. <code class="literal">lua_rawget</code> and <code class="literal">lua_gettable</code> are similar in that the key is pushed on the stack and the table's position on the stack is specified as the second argument. The function replaces the key with the key's associated value.</p><p>When you want to retrieve a value associated with an integer key, you can omit the step where you push the key by using the <code class="literal">lua_rawgeti</code> function. For example, if you want to retrieve <code class="literal">Tbl[7]</code> and <code class="literal">Tbl</code> resides in position 3 of the stack, you would call the function as follows:</p><pre class="programlisting">lua_rawgeti(L, 3, 7);</pre><p>The value of <code class="literal">Tbl[7]</code> is pushed on the stack. Like <code class="literal">lua_rawget</code>, this function bypasses the metamethod mechanism.</p><p>In the absence of metamethods, only tables can be indexed, so <code class="literal">lua_rawget</code> and <code class="literal">lua_rawgeti</code> operate only on tables. This restriction can be used to point out an important distinction between programming in Lua and programming in C. If you try the following in Lua:<a id="IDX-CHP-13-0043" class="indexterm"></a></p><pre class="programlisting">local J = 42
print(J[3])</pre><p>you'll be presented with this Lua error message:</p><pre class="programlisting">attempt to index local 'J' (a number value)</pre><p>Using a protected call, you can recover from an error like this. If you try something similar in C, such as the following:</p><pre class="programlisting">// Stk: ...
lua_pushinteger(L, 42);
// Stk: ... 42
lua_rawgeti(L, −1, 3);
// Stk: ... 42[3]</pre><p>you're in for this less-pleasant response:</p><pre class="programlisting">Segmentation fault</pre><p>A protected call can't prevent the host from abnormally terminating like this. When you're programming with Lua's C API, all of the sharp edges are exposed.</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="setting_indexed_values"></a>Setting Indexed Values</h2></div></div></div><p>Each of the API functions for retrieving an indexed value has a complement for setting an indexed value. For example, use the <code class="literal">lua_settable</code> function in C to perform what the following line does in Lua:</p><pre class="programlisting">Tbl[Key] = Val</pre><p>For example, to make the following assignment in C:</p><pre class="programlisting">Tbl.Name = "Don Quixote"</pre><p>you would use the following sequence:</p><pre class="programlisting">// Stk: ...
lua_newtable(L);
// Stk: ... Tbl
lua_pushstring(L, "Name");
// Stk: ... Tbl "Name"
lua_pushstring(L, "Don Quixote");
// Stk: ... Tbl "Name" NameStr
lua_settable(L, −3);
// Stk: ... Tbl</pre><p>In this case, a new table is created but, because <code class="literal">lua_settable</code> will invoke the <code class="literal">__newindex</code> metamethod if needed, any indexable value could be used instead. The sequence shows how the topmost value on the stack must be the value to be assigned, and the value just below it must be the key.<a id="IDX-CHP-13-0044" class="indexterm"></a><a id="IDX-CHP-13-0045" class="indexterm"></a><a id="IDX-CHP-13-0046" class="indexterm"></a><a id="IDX-CHP-13-0047" class="indexterm"></a><a id="IDX-CHP-13-0048" class="indexterm"></a><a id="IDX-CHP-13-0049" class="indexterm"></a></p><p>If <code class="literal">Tbl</code> is a table and you want to avoid any use of metamethods, you can use the <code class="literal">lua_rawset</code> function as a drop-in replacement for <code class="literal">lua_settable</code>.</p><p>If you're making an assignment to a table with an integer key and want to avoid the use of metamethods, a shortcut is to use the <code class="literal">lua_rawseti</code> function. For example, you would perform the following Lua function:</p><pre class="programlisting">Tbl[42] = "Hello, world"</pre><p>with the following C code:</p><pre class="programlisting">// Stk: ...
lua_newtable(L);
// Stk: ... Tbl
lua_pushstring(L, "Hello, world");
// Stk: ... Tbl Str
lua_rawseti(L, −2, 42);
// Stk: ... Tbl</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="retaining_values_in_c"></a>Retaining Values in C</h1></div></div></div><p>Userdata can be used by a C library to retain contextual information. No provision needs to be made in the C code to store and retrieve its state information — it simply gets passed in from Lua when needed. But Lua is nothing if not flexible, so it gives you some other choices for storing persistent values. As you've seen so far in this chapter, when you extend Lua with C, you've got to manage many details that are taken care of transparently when working strictly in Lua. For example, the Lua compiler will recognize whether a variable referenced in a Lua script is a local variable or upvalue or one that will need to be looked for in the global environment. In C, the only way to retrieve Lua variables will be to know in advance where they are stored. This applies to the following storage mechanisms.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="the_registry"></a>The Registry</h2></div></div></div><p>Every Lua state has a table referred to as the registry for storing Lua values. Any C code that has access to the Lua state pointer has access to the registry. Lua code, by design, does not. The shared nature of the registry makes it suitable for some purposes and not for others. As with any table, you need to choose keys well to avoid inadvertent duplicates. This is especially important with the registry, because you can't know what other C libraries will be loaded along with yours. One technique is to use light userdata initialized with the addresses of static variables in the C code. Within an application, each static variable will have a unique address.</p><p>The registry is just a table, so it would be a shame to have to provide a bunch of API functions to manipulate it when there are already functions available for table access. Lua's elegant solution is to make the registry table available on the stack at a special position that can't be used for other purposes. Lua gives the symbolic name <code class="literal">LUA_REGISTRYINDEX</code> to the <span class="emphasis"><em>pseudo-index</em></span> (an index that is treated specially by Lua) that refers to the registry. To access the registry, use any of the table indexing methods you already know about and specify <code class="literal">LUA_REGISTRYINDEX</code> as the table's stack position.<a id="IDX-CHP-13-0050" class="indexterm"></a></p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="c_function_environments"></a>C Function Environments</h2></div></div></div><p>Every registered C function is associated with a table known as its environment. When a C function is registered, it inherits the current environment. This can later be changed by means of the <code class="literal">lua_replace</code> function. This table is accessed, in C only, with the pseudo-index <code class="literal">LUA_ENVIRONINDEX</code> the same way the registry is. The difference is that the table referenced by <code class="literal">LUA_ENVIRONINDEX</code> by one function may be different than the one similarly referenced in another function, and the table referenced by <code class="literal">LUA_REGISTRYINDEX</code> will always be the same.<a id="IDX-CHP-13-0051" class="indexterm"></a><a id="IDX-CHP-13-0052" class="indexterm"></a><a id="IDX-CHP-13-0053" class="indexterm"></a><a id="IDX-CHP-13-0054" class="indexterm"></a></p><p>It's easy to create an environment that will be shared by all registered functions in a library and by no others. Prior to calling <code class="literal">luaL_register</code> to register one or more C functions, create a new table and replace the current environment with it. Here is some sample code:</p><pre class="programlisting">int luaopen_sample(
 lua_State *L)

{  // luaopen_sample
   static const luaL_reg Map[] = {
       {"run", LclRun},
       {NULL, NULL}
   }; // Map

   //  Stk: ModuleStr
   lua_newtable(L);
   //  Stk: ModuleStr Tbl
   lua_replace(L, LUA_ENVIRONINDEX);
   //  Stk: ModuleStr
   luaL_register(L, "sample", Map);
   //  Stk: ModuleStr Namespace
   return 1;
}  // luaopen_sample</pre></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="upvalues_in_c"></a>Upvalues in C</h2></div></div></div><p>So far in this chapter, you have called <code class="literal">luaL_register</code> to register one or more C functions so that they can be called from Lua. The pattern has been to call this function in a library's loader function, but this is not a requirement. Lua provides a lower level function named <code class="literal">lua_pushcclosure</code> that lets you push a function of type <code class="literal">lua_CFunction</code> on the stack. This is the critical step that creates a value of type <code class="literal">function</code> from a C function. For example, in the following C code, the value that <code class="literal">lua_pushcclosure</code> pushes at the top of stack can be made available to a Lua script and called from there:</p><pre class="programlisting">// Stk: ...
lua_pushcclosure(L, LclRun, 0);
// Stk: Fnc</pre><p>The functions <code class="literal">lua_isfunction</code> and <code class="literal">lua_iscfunction</code> will both return 1 on this value. (When a function is written in Lua, the former function returns <code class="literal">1</code> and the latter function returns <code class="literal">0</code>.) From its position on the stack, it can be treated like any other Lua value. For example, it can be assigned to a global variable, associated with a key in a table, kept on the stack as a return value or, because it is a function, called in place.</p><p>The third argument to <code class="literal">lua_pushcclosure</code> indicates the number of upvalues to associate with the new Lua function. These values should be at the top of the stack when <code class="literal">lua_pushcclosure</code> is called. Here's an example:</p><pre class="programlisting">// Stk: ...
lua_pushstring(L, "First upvalue");
// Stk: ... Str
lua_pushinteger(L, 42);
// Stk: ... Str Num
lua_newtable(L);
// Stk: ... Str Num Tbl
lua_pushcclosure(L, LclRun, 3);
// Stk: ... LclRun</pre><p>These values are bound to the <span class="emphasis"><em>closure</em></span> function and are available to it whenever it is called. The function accesses its upvalues as if they resided on the stack. The stack position to use is calculated by the <code class="literal">lua_upvalueindex</code> macro defined in <code class="literal">lua.h</code>. This macro maps the position of the upvalue to a pseudo-index value. For example, here is how the first two upvalues (the string and the integer) in the preceding example would be retrieved:<a id="IDX-CHP-13-0055" class="indexterm"></a><a id="IDX-CHP-13-0056" class="indexterm"></a><a id="IDX-CHP-13-0057" class="indexterm"></a></p><pre class="programlisting">Str = lua_tostring(L, lua_upvalueindex(1));
Pos = lua_tointeger(L, lua_upvalueindex(2));</pre><p>You can treat the pseudo-index that <code class="literal">lua_upvalueindex</code> returns as an ordinary stack position. With this index, you can retrieve upvalues and assign new values to them.</p><p>Upvalues in C are private to the function to which they are bound. But the third upvalue in the example is a Lua table, and the values in that table can be shared by using that table as an upvalue for different functions. In this way, you have a lot of control over what information is shared between select functions.</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="referencing_values"></a>Referencing Values</h2></div></div></div><p>Lua's auxiliary library has some referencing functions that help you keep track of Lua values in your C code. When given a table, the <code class="literal">luaL_ref</code> function will do the following:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Generate a unique integer key to be used in the specified table.</p></li><li class="listitem"><p>Associate the stack's topmost value with the new integer key in the specified table.</p></li><li class="listitem"><p>Pop the value off of the stack.</p></li><li class="listitem"><p>Return the integer key.</p></li></ol></div><p>To retrieve the referenced value, use the <code class="literal">lua_rawgeti</code> function. To remove the stored value from the table, and to make the reference identifier available for reuse, call <code class="literal">luaL_unref</code>.</p><p>Because integers are so easily stored in C, the reference system is a convenient way to have access to Lua values in your library. Any table can be used with the reference system, but it is important that you not subvert the system by using your own numeric keys in it. The registry and C function environment tables are particularly well-suited to the reference mechanism because you don't need to worry about key clashes. Here's an example of using the reference functions to store, retrieve, and release a string value in the registry:</p><pre class="programlisting">int Ref = LUA_NOREF;

// Stk: ...
lua_pushstring(L, "Hello, world");</pre><pre class="programlisting">// Stk: ... Str
Ref = luaL_ref(L, LUA_REGISTRYINDEX);
// Stk: ...
lua_rawgeti(L, LUA_REGISTRYINDEX, Ref);
// Stk: ... Str
printf("Retrieved string: %s\n", lua_tostring(L, −1));
luaL_unref(L, LUA_REGISTRYINDEX, Ref);
Ref = LUA_NOREF;
// Stk: ... Str
lua_pop(L, 1);
// Stk: ...</pre><p>The <code class="literal">LUA_NOREF</code> symbolic constant is an integer value that Lua will never return as a valid reference. It is useful to assign this value to a reference identifier before and after use to mark it as inactive. This way, you won't inadvertently try to dereference or release it.<a id="IDX-CHP-13-0058" class="indexterm"></a><a id="IDX-CHP-13-0059" class="indexterm"></a><a id="IDX-CHP-13-0060" class="indexterm"></a><a id="IDX-CHP-13-0061" class="indexterm"></a><a id="IDX-CHP-13-0062" class="indexterm"></a><a id="IDX-CHP-13-0063" class="indexterm"></a><a id="IDX-CHP-13-0064" class="indexterm"></a><a id="IDX-CHP-13-0065" class="indexterm"></a><a id="IDX-CHP-13-0066" class="indexterm"></a><a id="IDX-CHP-13-0067" class="indexterm"></a></p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="the_thread_environment"></a>The Thread Environment</h2></div></div></div><p>Global variables are held in a table known as the thread environment. As with the registry and C function environments, a pseudo-index is used to access the table, which in this case is <code class="literal">LUA_GLOBALSINDEX</code>. The <code class="literal">lua_getglobal</code> and <code class="literal">lua_setglobal</code> macros retrieve and set values in this table by using this pseudo-index. Here's an example that sets a global variable in the thread environment:</p><pre class="programlisting">// Stk: ...
lua_pushstring(L, "0.4.8");
// Stk: ... VerStr
lua_setglobal(L, "APP_VERSION");
// Stk: ...</pre><p>Values stored in this table are accessible in both Lua and C code.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="layering_your_extension_library"></a>Layering Your Extension Library</h1></div></div></div><p>The <code class="literal">iomode</code> extension library is made up of a single C module, and its loader function is called directly by the <code class="literal">require</code> mechanism. Another approach is to provide a Lua script that acts as the principal module; this script in turn loads a C extension library. This combination gives you the opportunity to leverage Lua and C in the places where they work best: C for low-level primitives and linking to third-party libraries and Lua for everything else.</p><p>Sometimes it is worthwhile to distinguish the C code that is aware of Lua from the C code that isn't. If you find that large amounts of C code are sprinkled with only a few calls into the Lua API, it may be beneficial to redesign the interface and place the code that isn't aware of Lua into its own library. This library is then more widely usable, and the Lua-aware code acts as a binding layer between it and Lua.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="layering_your_extension_librar"></a></h2></div></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_creating_a_layered-exte"></a>Try It Out: Creating a Layered-Extension Library for CSV Records</h3></div></div></div><p>A fairly common way to package row and column information is to place it in CSV (comma-separated value) format. Each row occupies one line of text, and each field within a row is delimited with a comma. There are variations in how to handle a field that includes one or more literal commas. One peculiar but pervasive convention is to enclose such a field in double quotes, and to interpret each occurrence of two adjacent double quotes within a quoted field as one double quote. These rules make it difficult to handle CSV records in pure Lua.</p><p>This exercise demonstrates a layered extension library to facilitate the reading and writing of CSV records. It handles the low-level parsing in C, and the higher-level functions in Lua.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Using your text editor, create a new file and include the following C contents:</p><pre class="programlisting">#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
#include &lt;string.h&gt;

/* * */

static const char * LclCsv(
    const char * Str,
    luaL_Buffer * BufPtr)

    /* This function parses the comma separated value (CSV) segment beginning at
    the start of Str. In CSV format

       * commas delimit text segments

       * double quotes which surround text are not copied

       * commas occurring within double quoted text are copied verbatim

       * each occurrence of two consecutive double quotes within double quoted
         text are copied as one double quote

   Examples

       abc               -&gt; |abc|
       "abc"             -&gt; |abc|
       "abc, def"        -&gt; |abc, def|
       "abc ""def"" ghi" -&gt; |abc "def" ghi|

   */

{  // LclCsv

   typedef enum {CnaIgnore = 0, CnaCopy = 1, CnaInc = 2, CnaQuit = 4} ActionType;

   typedef enum {CnsStart, CnsText, CnsQuoted, CnsHyperQuoted} StateType;

   typedef enum {CncComma, CncQuote, CncChar, CncNull} CatType;

   typedef struct {
      ActionType A;
      StateType S;
   } ContextType;

   static ContextType ContextList[CnsHyperQuoted + 1][CncNull + 1] = {</pre><pre class="programlisting">{ // CnsStart
     {CnaInc, CnsStart}, // CncComma
     {CnaIgnore, CnsQuoted}, // CncQuote
     {CnaCopy, CnsText}, // CncChar
     {CnaQuit, CnsStart}}, // CncNull

 { // CnsText
     {CnaInc, CnsStart}, // CncComma
     {CnaIgnore, CnsQuoted}, // CncQuote
     {CnaCopy, CnsText}, // CncChar
     {CnaInc | CnaQuit, CnsText}}, // CncNull

 { // CnsQuoted
     {CnaCopy, CnsQuoted}, // CncComma
     {CnaIgnore, CnsHyperQuoted}, // CncQuote
     {CnaCopy, CnsQuoted}, // CncChar
     {CnaInc | CnaQuit, CnsQuoted}}, // CncNull

 { // CnsHyperQuoted
     {CnaInc, CnsStart}, // CncComma
     {CnaCopy, CnsQuoted}, // CncQuote
     {CnaCopy, CnsText}, // CncChar
     {CnaInc | CnaQuit, CnsHyperQuoted}}}; // CncNull

 char Ch;
 ContextType Context;
 CatType Cat;

 Context.S = CnsStart;
 do {
    Ch = *(Str++);
     if (! Ch) Cat = CncNull;
    else if (Ch == 34) Cat = CncQuote;
    else if (Ch == ',') Cat = CncComma;
    else {
        Cat = CncChar;
         if (Ch &lt; ' ') Ch = ' ';
    } // else
   Context = ContextList[Context.S][Cat];
    if (CnaCopy &amp; Context.A) luaL_addchar(BufPtr, Ch);
    if (CnaInc &amp; Context.A) Ch = 0;
 } while (Ch);
 return Str;
} // LclCsv

/* * */

static int LclCsvParse(
    lua_State *L)

    // str_segment, pos &lt;- csv.parse(str [, pos])

{  // LclCsvParse
    const char *Str, *EndStr;
    int Len, Pos;</pre><pre class="programlisting">luaL_Buffer Buf;

    Str = luaL_checkstring(L, 1);
    if (lua_isnil(L, 2)) Pos = 1;
    else Pos = luaL_checkinteger(L, 2);
    Len = strlen(Str);
    if ((Pos &gt;= 1) &amp;&amp; (Pos &lt;= Len)) {
      luaL_buffinit(L, &amp;Buf);
      EndStr = LclCsv(Str + Pos - 1, &amp;Buf);
      luaL_pushresult(&amp;Buf);
      Pos = EndStr - Str;
      Pos = Pos &gt; Len ? −1 : Pos + 1;
      lua_pushinteger(L, Pos);
    } // if
    else luaL_error(L, "pos is out of range");
    return 2;
  } // LclCsvParse

  /* * */

  int luaopen_csvparse(
    lua_State *L)

  {  // luaopen_csvparse
     static const luaL_reg Map[] = {
       {"parse", LclCsvParse},
       {NULL, NULL}
     };

     luaL_register(L, "csv", Map);
     return 1;
   } // luaopen_csvparse</pre></li><li class="listitem"><p>Save the file as <code class="literal">csvparse.c</code>.</p></li><li class="listitem"><p>Compile this extension into a shared library. On Linux and other Unix-type systems, run this command:</p><pre class="programlisting">cc -o csvparse.so -shared -Wall csvparse.c</pre><p>On the Windows platform, compile the extension as follows:</p><pre class="programlisting">cl /c /Zl /Zd /Yd /MD /W4 /DWIN32 csvparse.c
link /dll /out:csvparse.dll /base:0x67C00000 /machine:ix86 <div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/U002.png" alt="Try It Out: Creating a Layered-Extension Library for CSV Records" width="12" height="12"></div>
   /export:luaopen_csvparse csvparse.obj msvcrt.lib lua5.1.lib</pre></li><li class="listitem"><p>Copy the generated module to your designated Lua library directory. On Unix-type systems, run this:</p><pre class="programlisting">cp csvparse.so $LUA_DIR/</pre><p>On Windows, run this:</p><pre class="programlisting">xcopy csvparse.dll "%LUA_DIR%\*.*"</pre></li><li class="listitem"><p>Create another new file with the following Lua contents:</p><pre class="programlisting">require "csvparse"

-- Return a string which has been properly quoted for inclusion in a
-- comma-separated value file.

function csv.escape(str)
  local wrap = ""
  str = tostring(str)
  if string.find(str, '"') then
    str = string.gsub(str, '"', '""')
    wrap = '"'
  end
  if string.find(str, ',') then
    wrap = '"'
  end
  return wrap .. str .. wrap
end

-- Iterator to allow traversal of CSV cells

function csv.cells(str)
  local pos = 1
  local function nextcell()
    local cellstr
    if pos &gt; 0 then
      cellstr, pos = csv.parse(str, pos)
    else
      cellstr = nil
    end
    return cellstr
  end
  return nextcell
end</pre></li><li class="listitem"><p>Save this file as <code class="literal">csv.lua</code>.</p></li><li class="listitem"><p>Copy this module to your designated Lua library directory. On Unix-type systems, run this:</p><pre class="programlisting">cp csv.lua $LUA_DIR/</pre><p>On Windows, run this:</p><pre class="programlisting">xcopy csv.lua "%LUA_DIR%\*.*"</pre></li><li class="listitem"><p>Create another new Lua file with these contents:</p><pre class="programlisting">require "csv"

local Str = 'Natty Bumppo,"Natty Bumppo, Pathfinder","Natty ""Hawkeye"" Bumppo"'

local SubStr, Pos

io.write("--- csv.parse ---\n")
Pos = 1
io.write(Str, "\n")
for J = 1, 10 do</pre><pre class="programlisting">if Pos &gt; 0 then
    SubStr, Pos = csv.parse(Str, Pos)
    io.write(string.format("Pos %3d, field [%s], escaped [%s]\n", Pos, SubStr,
      csv.escape(SubStr)))
  end
end

io.write("--- csv.cells ---\n")
for CellStr in csv.cells(Str) do
  io.write(CellStr, "\n")
end</pre></li><li class="listitem"><p>Save this file as <code class="literal">csvtest.lua</code>.</p></li><li class="listitem"><p>From a command shell, run the test script as follows:</p><pre class="programlisting">lua csvtest.lua
--- csv.parse ---
Natty Bumppo,"Natty Bumppo, Pathfinder","Natty ""Hawkeye"" Bumppo"
Pos 14, field [Natty Bumppo], escaped [Natty Bumppo]
Pos 41, field [Natty Bumppo, Pathfinder], escaped ["Natty Bumppo, Pathfinder"]
Pos −1, field [Natty "Hawkeye" Bumppo], escaped ["Natty ""Hawkeye"" Bumppo"]
--- csv.cells ---
Natty Bumppo
Natty Bumppo, Pathfinder
Natty "Hawkeye" Bumppo</pre></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-039"></a>How It Works</h3></div></div></div><p>This extension processes CSV rows and leaves the matter of reading and writing those lines to the <code class="literal">io</code> library. It comprises two layers: the low level parsing component in C, and the escaping and iterator routines in Lua.</p><p>The format of <code class="literal">csvparse.c</code> is similar to that of <code class="literal">iomode.c</code>. The loader function <code class="literal">luaopen_csvparse</code> is called by Lua's package system. It calls <code class="literal">luaL_register</code> to create (or reuse, if it already exists) the <code class="literal">csv</code> namespace table and to place into it the <code class="literal">LclCsvParse</code> extension function keyed with the string "parse".</p><p>The extension function uses Lua's string buffering routines. This mechanism lets you construct a string in stages without having to worry about memory issues. You have to pay attention to the virtual stack, however. Here's how string buffering works:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The following line initializes <code class="literal">Buf</code> (of type <code class="literal">luaL_Buffer</code>) in preparation to building up a CSV field string:</p><pre class="programlisting">luaL_buffinit(L, &amp;Buf);</pre></li><li class="listitem"><p>Characters are added to the string in the following line:</p><pre class="programlisting">if (CnaCopy &amp; Context.A) luaL_addchar(BufPtr, Ch);</pre><p>The function <code class="literal">luaL_addchar</code> appends the specified character to the string buffer. When called, it and the other string buffer functions except <code class="literal">luaL_addvalue</code> expect to find the stack as it was left after the previous string buffer call. (In the case of <code class="literal">luaL_addvalue</code>, the stack should be the same except that an additional value should be pushed on the top.) In between string buffer calls, you are able to perform operations that manipulate the stack. You just need to make sure the stack is returned to the expected level before calling a string buffer function again.</p></li><li class="listitem"><p>The completed string is pushed on the stack with the following line:<a id="IDX-CHP-13-0068" class="indexterm"></a></p><pre class="programlisting">luaL_pushresult(&amp;Buf);</pre></li></ol></div><p>The <code class="literal">csv.parse</code> function is called with a string to process and, optionally, a one-based position that indicates where in the string to begin parsing. The arguments are obtained and validated with the following lines:</p><pre class="programlisting">Str = luaL_checkstring(L, 1);
if (lua_isnil(L, 2)) Pos = 1;
else Pos = luaL_checkinteger(L, 2);</pre><p>If the second argument is missing, <code class="literal">Pos</code> is assigned a default value of one indicating the beginning of the string. If it's an integer, its value is assigned to <code class="literal">Pos</code>. If it is neither of these, an error is generated. The value of <code class="literal">Pos</code> is checked to be sure it points to a valid position in <code class="literal">Str</code>.</p><p>The <code class="literal">csv.parse</code> function is intended to be called repeatedly, each time returning the next field. It does this by returning, in addition to the field string, the position of the next field. When the last field of the CSV row is returned, the value of this position is set to <code class="literal">−1</code>. A scheme like this is efficient because parsing takes place only as needed and, using Lua's string buffer mechanism, no overhead is spent on transient, partial strings during string construction. If the function succeeds, the call to <code class="literal">luaL_pushresult</code> pushes the field string on the stack, and the call to <code class="literal">lua_pushinteger</code> pushes the next position or <code class="literal">−1</code>. The return value of <code class="literal">2</code> indicates to Lua that these two values are to be returned, in the order they were pushed, to the caller of <code class="literal">csv.parse</code>.</p><p>The Lua layer of this extension library, <code class="literal">csv.lua</code>, includes routines to help with reading and writing CSV fields. The <code class="literal">csv.cells</code> function is an iterator generator that wraps <code class="literal">csv.parse</code>, allowing the fields of a CSV record to be read in a generic for loop. The <code class="literal">csv.escape</code> function applies the quoting rules to a single field, helping with the construction of a CSV record.</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="summary-040"></a>Summary</h1></div></div></div><p>The C API is a substantial part of Lua, and this chapter has glossed or outright skipped over some of its features. But, having come this far, you have learned enough to create a basic C extension library for Lua. In particular, you've learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The distinction between embedding Lua and extending it</p></li><li class="listitem"><p>To use the virtual stack to exchange values between Lua and C</p></li><li class="listitem"><p>To write and register C functions that can be called from Lua</p></li><li class="listitem"><p>To call Lua functions from C</p></li><li class="listitem"><p>Where you can store persistent values in C</p></li><li class="listitem"><p>To program userdata to create versatile Lua handles that, behind the scenes, can manage C resources</p></li><li class="listitem"><p>Different ways to layer your extensions to get the most out of C and the most out of Lua</p></li></ul></div><p>Take some time to test what you've learned by tackling the following exercises. From there, the next chapters will lead you through the use of Lua for database, web, and network access.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-041"></a>Exercises</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>In the <code class="literal">ud_example</code> Try It Out, you created and used an example handle as follows:</p><pre class="programlisting">local Hnd = ud_example.open(1)
Hnd:set(2)
Hnd:close()</pre><p>What changes would you need to make to the C library so that it would additionally support the following usage?</p><pre class="programlisting">local Hnd = ud_example.open(1)
ud_example.set(Hnd, 2)
ud_example.close(Hnd)</pre></li><li class="listitem"><p>Add stack diagrams in the form of single line comments to the following C fragment:</p><pre class="programlisting">lua_newtable(L);
lua_newtable(L);
lua_pushstring(L, "Rip Van Winkle");
lua_setfield(L, −2, "Name");
lua_pushvalue(L, −1);
lua_pushcclosure(L, FncA, 1);
lua_setfield(L, −3, "a");
lua_pushcclosure(L, FncB, 1);
lua_setfield(L, −2, "b");
lua_pushvalue(L, −1);
lua_setglobal(L, "test");</pre><p>Now explain what this code accomplishes:</p></li><li class="listitem"><p>Write an extension library for bit operations. The <code class="literal">bit._and</code> function should return each argument (which must be an integer) linked with <code class="literal">and</code>. Similarly, the <code class="literal">bit._or</code> function should return each argument (which must be an integer) linked with <code class="literal">or</code>.</p></li></ol></div><div class="blockquote"><blockquote class="blockquote"><p><code class="literal">and</code> and <code class="literal">or</code> are reserved keywords and cannot be used as names. Nevertheless, you can use them as table keys for your functions, but then you need to invoke your functions as <code class="literal">bit['and']</code> and <code class="literal">bit['or']</code>.</p></blockquote></div><p>For example, the following script:</p><pre class="programlisting">package.path = ""
package.cpath = "./?.so;./?.dll"
require "bit"

print(bit._and(301, 251, 491))
print(bit['and'](301, 251, 491))
print(bit._or(32, 8, 1))
print(bit['or'](32, 8, 1))</pre><p>should print these lines:</p><pre class="programlisting">41
41
41
41</pre></div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="ch12.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">12. Using Community Libraries</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="ch14.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">14. Managing Information with Databases</div>
        </a>
    
  
  </div>


        
    </section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag">
        
        

        
          <p>You have 6 days left in your trial, Michaelschiner. Subscribe today. <a href="https://learning.oreilly.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
        
        

      </div>

    
    



        
      </div>
      
        

<footer class="pagefoot t-pagefoot">
  <a href="ch13.html#" class="icon-up" onclick="window.Appcues.track('JumpTop_HeronBook')"><div class="visuallyhidden">Back to top</div></a>
  <ul class='js-footer-nav'>
  
    
    <li><a href="https://learning.oreilly.com/public/support/">Support</a></li>
    
    <li><a href="https://learning.oreilly.com/accounts/logout/">Sign Out</a></li>
    
  
  
  </ul>
  <span class="copyright">&#169; 2021 <a href="https://learning.oreilly.com/" target="_blank">O'Reilly Media, Inc</a>.</span>
  
    
    <a href="https://www.oreilly.com/terms/">Terms of Service</a> 
     / 
    
    <a href="https://learning.oreilly.com/privacy">Privacy Policy</a> 
    
    
  
</footer>

      
    
    <script src="https://learning.oreilly.com/jsi18n/web/" charset="utf-8"></script>
    <script src="https://learning.oreilly.com/library/jsi18n/appcache/" charset="utf-8"></script>
  </body>
</html>
