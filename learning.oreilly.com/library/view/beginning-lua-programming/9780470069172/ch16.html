<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch16.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch16.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/beginning-lua-programming/9780470069172/ch16.html"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9780470069172"
  data-publishers="Wrox"



  data-htmlfile-name="ch16.html"
  data-epub-title="Beginning Lua Programming" data-debug=0 data-testing=0><!--<![endif]--><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="author" content="O'Reilly Media" /><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9780470069172"/><link rel="shortcut icon" href="https://www.oreilly.com/favicon.ico" /><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"/><meta property="twitter:account_id" content="4503599627559754" /><link rel="shortcut icon" href="https://learning.oreilly.com/favicon.ico" type="image/x-icon"><link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic' rel='stylesheet' type='text/css'><title>16. Connecting to a Larger World - Beginning Lua Programming</title><link rel="stylesheet" href="https://learning.oreilly.com/static/CACHE/css/output.5bdb4fcb2aad.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://learning.oreilly.com/static/css/annotator.e3b0c44298fc.css"/><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book"></style><script> // <![CDATA[
    var g = {
      position_cache: {
        
          "chapter": "/api/v1/book/9780470069172/chapter/ch16.html",
          "book_id": "9780470069172",
          "chapter_uri": "ch16.html",
          "position": 0,
          "user_uuid": "ce47de5b-ce80-49f0-b5cd-c60d3d33b198",
          "next_chapter_uri": "/library/view/beginning-lua-programming/9780470069172/ch17.html"
        
      },
      title: "Beginning Lua Programming",
      author_list: "Aaron Brown, Kurt Jung",
      format: "book",
      source: "application/epub+zip",
      is_system_book: true,
      is_public: false,
      loaded_from_server: true,
      allow_scripts: false,
      has_mathml: false
    };
    // ]]></script><script src="https://learning.oreilly.com/static/js/src/modernizr.8e35451ddb64.js"></script><script>
    
      

      
        
          window.PUBLIC_ANNOTATIONS = true;
        
      

      window.MOBILE_PUBLIC_ANNOTATIONS = false;

    

    
      window.PRIVACY_CONTROL_OVERRIDE = false;
    

      window.PRIVACY_CONTROL_SWITCH = true;

      window.PUBLISHER_PAGES = true;

      window.SBO = {
        "constants": {
          "SITB_ENDPOINT": "/api/v2/sitb/",
          "SEARCH_SELECT_ENDPOINT": "https://learning.oreilly.com/api/v2/search/select/",
        }
      };
  </script><link rel="canonical" href="ch16.html"/><meta name="description" content="Chapter 16. Connecting to a Larger World In the previous chapter, you used Lua in conjunction with web servers and web browsers—applications that take care of networking details and let ... "><meta property="og:title" content="16. Connecting to a Larger World" /><meta itemprop="isPartOf" content="/library/view/beginning-lua-programming/9780470069172/" /><meta itemprop="name" content="16. Connecting to a Larger World" /><meta property="og:url" itemprop="url" content="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch16.html" /><meta property="og:site_name" content="Safari" /><meta property="og:image" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9780470069172/" /><meta property="og:description" itemprop="description" content="Chapter 16. Connecting to a Larger World In the previous chapter, you used Lua in conjunction with web servers and web browsers—applications that take care of networking details and let ... "><meta itemprop="inLanguage" content="en" /><meta itemprop="publisher" content="Wrox" /><meta property="og:type" content="book" /><meta property="og:book:isbn" itemprop="isbn" content="9780470069172" /><meta property="og:book:author" itemprop="author" content="Aaron Brown" /><meta property="og:book:author" itemprop="author" content="Kurt Jung" /><meta property="og:book:tag" itemprop="about" content="Core Programming" /><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@OReillyMedia"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><noscript><meta http-equiv="refresh" content="0; URL=https://learning.oreilly.com/library/no-js/" /></noscript><script>
    var dataLayer = window.dataLayer || [];

    
      window.medalliaVsgUserIdentifier = 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198';
      dataLayer.push({userIdentifier: 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198'});
      dataLayer.push({loggedIn: 'yes'});

      
        window.medalliaVsgAccountIdentifier = '29964b7b-68d8-4532-9a9b-32e089689c1f';
        

        window.medalliaVsgIsIndividual = true;
        
          
          dataLayer.push({learningAccountType: 'free trial'});
          
        

        
      
    

    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5P4V6Z');
    (function () {
      var VERSION = 'V1.1';
      var AUTHOR = 'Awwad';
      if (!window.GtmHelper)
        window.GtmHelper = function () {
          var instance = this;
          var loc = document.location;
          this.version = VERSION;
          this.author = AUTHOR;
          this.readCookie = function (name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
              var c = ca[i];
              while (c.charAt(0) == ' ') c = c.substring(1, c.length);
              if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
          };
          this.createCookie = function (name, value, days, cookieDomain) {
            var domain = "";
            var expires = "";

            if (days) {
              var date = new Date();
              date.setTime(date.getTime() + Math.ceil(days * 24 * 60 * 60 * 1000));
              var expires = " expires=" + date.toGMTString() + ";";
            }

            if (typeof (cookieDomain) != 'undefined')
              domain = " domain=" + cookieDomain + "; ";

            document.cookie = name + "=" + value + ";" + expires + domain + "path=/";
          };

          this.isDuplicated = function (currentTransactionId) {
            // the previous transaction id:
            var previousTransIdValue = this.readCookie("previousTransId");

            if (currentTransactionId === previousTransIdValue) {
              return true; // Duplication
            } else {
              return false;
            }
          };
        }
    })()
  </script><script defer src="https://learning.oreilly.com/static/js/build/vendor.0eac897f11ed.js"></script><script defer src="https://learning.oreilly.com/static/js/build/reader.c745ea9296ac.js"></script></head>


<body class="reading sidenav nav-collapsed  scalefonts">

    
  <noscript> 
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
            height="0" width="0"
            style="display:none;visibility:hidden">
    </iframe>
  </noscript>



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        

  


<a href="ch16.html#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li><a href="https://learning.oreilly.com/home/" class="l0 nav-icn"><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.738 14H9.254v-3.676a.617.617 0 0 0-.621-.613H7.39a.617.617 0 0 0-.62.613V14H4.284a.617.617 0 0 1-.622-.613V10.22c0-.327.132-.64.367-.87l3.547-3.493a.627.627 0 0 1 .875 0l3.54 3.499c.234.229.366.54.367.864v3.167a.617.617 0 0 1-.62.613zM7.57 2.181a.625.625 0 0 1 .882 0l5.77 5.692-.93.92-5.28-5.209-5.28 5.208-.932-.919 5.77-5.692z" /></svg><span>Home</span></a></li><li class="search"><a href="ch16.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"/></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="ch16.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"/></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li class="flyout-parent"><a
                href="ch16.html#"
                class="l1 nav-icn "
                
              ><?xml version="1.0" encoding="UTF-8"?><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M8,8 C6.34321755,8 5.00013,6.65691245 5.00013,5.00013 C5.00013,3.34334755 6.34321755,2.00026001 8,2.00026001 C9.65678245,2.00026001 10.99987,3.34334755 10.99987,5.00013 C10.99987,6.65691245 9.65678245,8 8,8 Z M2.33024571,11.3523547 L2.33774538,11.3523547 C3.7622187,9.70968996 5.82947484,8.76608166 8.00374984,8.76608166 C10.1780248,8.76608166 12.245281,9.70968996 13.6697543,11.3523547 C13.8892083,11.6177474 14.0062813,11.9530021 13.99974,12.2973138 L13.99974,13.99974 L2.00026001,13.99974 L2.00026001,12.2973138 C1.99371867,11.9530021 2.11079172,11.6177474 2.33024571,11.3523547 Z" id="path-1"></path></svg><span>Your O&#39;Reilly</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/profile/"
                    class="l2 nav-icn"
                    
                  ><span>Profile</span></a></li><li><a
                    href="https://learning.oreilly.com/history/"
                    class="l2 nav-icn"
                    
                  ><span>History</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/"
                    class="l2 nav-icn"
                    
                  ><span>Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/u/ce47de5b-ce80-49f0-b5cd-c60d3d33b198/"
                    class="l2 nav-icn"
                    
                  ><span>Highlights</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/answers/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M2.31032699,3.75609006 C4.65421571,1.41371359 8.45302454,1.41472092 10.7955702,3.75860838 C13.1381158,6.10249583 13.1369405,9.90130261 10.7930518,12.243847 C8.44916311,14.5863913 4.65018639,14.5852161 2.30780867,12.2413286 C-0.0346204845,9.89749489 -0.0334929936,6.09853298 2.31032699,3.75609006 Z M8.8198605,4.98016308 C7.34193969,3.86924672 5.23410194,3.98609692 3.88914868,5.33104946 C3.12814393,6.09032122 2.72818176,7.13880077 2.79015179,8.21201133 C2.79115912,8.23064692 2.79233434,8.24928252 2.79350956,8.26791811 L2.79350956,8.26791811 C2.83179539,8.8307976 2.9944077,9.37404287 3.26947292,9.86201677 L3.26947292,9.86201677 L2.77621706,11.7027432 C2.7699968,11.7259241 2.77662063,11.7506624 2.79359185,11.7676337 C2.8105631,11.7846049 2.83530144,11.7912287 2.85848233,11.7850085 L2.85848233,11.7850085 L4.69400524,11.2922565 C5.26306363,11.6167344 5.90703177,11.786885 6.56209849,11.7858479 C8.64827865,11.7858479 10.3395879,10.094542 10.3395879,8.00836292 C10.3405204,6.84135608 9.80105674,5.73967784 8.87862141,5.02482134 L8.87862141,5.02482134 L8.82825492,4.98654283 Z M13.7933062,2 C14.7073496,2.00009863 15.4482759,2.74110484 15.4482759,3.65514822 C15.4482759,4.32460943 15.0449926,4.92814782 14.4264842,5.18432286 C13.8079757,5.44049789 13.096053,5.29885769 12.6226979,4.82545158 C12.1493429,4.35204547 12.0077795,3.64010743 12.2640213,3.02162665 C12.5202631,2.40314587 13.123845,1.99992776 13.7933062,2 Z"/></svg><span>Answers</span></a></li><li class="flyout-parent"><a
                href="ch16.html#"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z"/></g></svg><span>Explore</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/topics/"
                    class="l2 nav-icn"
                    
                  ><span>All Topics</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;formats=case%20study&amp;formats=learning%20path&amp;formats=live%20online%20training&amp;formats=notebook&amp;formats=oriole&amp;formats=video&amp;sort=popularity&amp;facet_json=true&amp;page=0&amp;collection_type=expert"
                    class="l2 nav-icn"
                    
                  ><span>Most Popular Titles</span></a></li><li><a
                    href="https://learning.oreilly.com/recommendations/"
                    class="l2 nav-icn"
                    
                  ><span>Recommended</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;sort=publication_date&amp;facet_json=true&amp;page=0"
                    class="l2 nav-icn"
                    
                  ><span>Early Releases</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/discover/"
                    class="l2 nav-icn"
                    
                  ><span>Shared Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/resource-centers/"
                    class="l2 nav-icn"
                    
                  ><span>Resource Centers</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch16.html#"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M12.8 3.2A1.2 1.2 0 0 1 14 4.4v8.4a1.2 1.2 0 0 1-1.2 1.2H3.2A1.2 1.2 0 0 1 2 12.8V4.4a1.2 1.2 0 0 1 1.2-1.2h1.2V2h1.2v1.2h4.8V2h1.2v1.2h1.2zm-9.6 9.6h9.6V6.2H3.2v6.6zM8 9.5a1.35 1.35 0 1 1 0-2.7 1.35 1.35 0 0 1 0 2.7zm2.7 2.148v.552H5.3v-.552c0-.321.124-.634.355-.858a3.358 3.358 0 0 1 4.69 0c.23.224.355.537.355.858z" /></svg><span>Live Events</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/attend/"
                    class="l2 nav-icn"
                    
                  ><span>All Events</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/architectural-katas/"
                    class="l2 nav-icn"
                    
                  ><span>Architectural Katas</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/ai/"
                    class="l2 nav-icn"
                    
                  ><span>AI &amp; ML</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/strata/"
                    class="l2 nav-icn"
                    
                  ><span>Data Sci &amp; Eng</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/oscon/"
                    class="l2 nav-icn"
                    
                  ><span>Programming</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/infrastructure-ops/"
                    class="l2 nav-icn"
                    
                  ><span>Infra &amp; Ops</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/software-architecture/"
                    class="l2 nav-icn"
                    
                  ><span>Software Arch</span></a></li></ul></li><li class="flyout-parent"><a
                href="ch16.html#"
                class="l1 nav-icn "
                
              ><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.6467109,4.35328907 L14.7964612,7.51003884 C15.0678463,7.78304342 15.0678463,8.22395603 14.7964612,8.49696061 L11.6467109,11.6467109 L10.6597892,10.6597892 L13.3055794,8 L10.6597892,5.34021084 L11.6467109,4.35328907 Z M4.35328907,11.6467109 L1.20353875,8.48996116 C0.932153749,8.21695658 0.932153749,7.77604397 1.20353875,7.50303939 L4.35328907,4.35328907 L5.34021084,5.34021084 L2.69442057,8 L5.34021084,10.6597892 L4.35328907,11.6467109 Z M5.84417089,11.4997226 L8.67194674,4.50027742 L10.1838269,4.50027742 L7.35605105,11.4997226 L5.84417089,11.4997226 Z" id="Mask"></path></svg><span>Interactive</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=content-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Scenarios</span></a></li><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=sandbox-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Sandboxes</span></a></li><li><a
                    href="https://learning.oreilly.com/interactive/?classification=jupyter-notebook"
                    class="l2 nav-icn"
                    
                  ><span>Jupyter Notebooks</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/certifications/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M12.912 9.18L14 8.014l-1.088-1.18a.304.304 0 01-.075-.268L13.195 5l-1.535-.463a.313.313 0 01-.194-.194l-.462-1.537-1.565.358c-.09.03-.194 0-.269-.074L8.007 2 6.845 3.09a.303.303 0 01-.269.074l-1.565-.358-.462 1.537a.313.313 0 01-.194.194L2.82 5l.358 1.567a.26.26 0 01-.075.269L2 8.015l1.088 1.164c.075.075.09.18.075.269l-.358 1.567 1.535.463c.09.03.164.104.194.194l.462 1.537 1.565-.358c.015 0 .045-.015.075-.015.075 0 .15.03.209.074L8.007 14l1.163-1.09a.303.303 0 01.269-.074l1.565.358.462-1.537a.313.313 0 01.194-.194L13.195 11l-.358-1.567a.338.338 0 01.075-.254zm-6.046 1.37L4.41 8.26l1.16-1.244 1.767 1.649L10.4 5.6l1.202 1.202-4.242 4.243-.495-.495z"/></svg><span>Certifications</span></a></li><li ><a
                href="https://learning.oreilly.com/preferences/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"/></g></svg><span>Settings</span></a></li><li ><a
                href="https://learning.oreilly.com/public/support/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M7.363 6.656a2.692 2.692 0 0 1-2.681-2.703c0-1.493 1.2-2.703 2.681-2.703a2.692 2.692 0 0 1 2.682 2.703c0 1.493-1.2 2.703-2.682 2.703zm4.023 2.027c-1.852 0-3.352 1.513-3.352 3.379H2v-1.534c-.006-.31.099-.612.295-.852a6.666 6.666 0 0 1 9.09-.993zm-.543.676h1.12v.304c.003.284.16.543.408.676a.766.766 0 0 0 .77 0l.303-.176.556.966-.302.176a.772.772 0 0 0-.362.676v.08a.772.772 0 0 0 .362.677l.302.21-.556.965-.302-.175a.766.766 0 0 0-.771 0 .778.778 0 0 0-.409.675v.352h-1.106v-.372a.778.778 0 0 0-.409-.676.766.766 0 0 0-.77 0l-.303.176-.556-.912.302-.176a.772.772 0 0 0 .362-.676v-.04-.04a.772.772 0 0 0-.362-.676l-.302-.176.556-.966.289.155a.766.766 0 0 0 .77 0 .778.778 0 0 0 .41-.676V9.36zm1.562 2.703c0-.271-.108-.531-.3-.722a1.001 1.001 0 0 0-.72-.292 1.01 1.01 0 0 0-.992 1.023 1.01 1.01 0 0 0 1.01 1.004 1.01 1.01 0 0 0 1.002-1.013z" /></svg><span>Support</span></a></li><li ><a
                href="https://get.oreilly.com/email-signup.html"
                class="l1 nav-icn "
                target=&quot;_blank&quot;
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.564 2.263l2.172 2.174c.17.168.264.397.264.636V11a.6.6 0 0 1-.6.6h-.6V6.2h-6V2.6a.6.6 0 0 1 .6-.6h3.527c.239 0 .468.095.637.263zM2.6 14a.6.6 0 0 1-.6-.6V6.8a.6.6 0 0 1 .6-.6h1.903a1.2 1.2 0 0 1 .849.352L6.2 7.4H11a.6.6 0 0 1 .6.6v5.4a.6.6 0 0 1-.6.6H2.6zM11 5h1.8L11 3.2V5z" /></svg><span>Newsletters</span></a></li><li ><a
                href="https://learning.oreilly.com/accounts/logout/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.613 12.63A.607.607 0 0 1 2 12.03V3.602C2 3.269 2.274 3 2.613 3h5.515v1.204H3.226v7.223h4.902v1.203H2.613zM5.677 9.02V6.611h4.903V4.926a.301.301 0 0 1 .19-.274.31.31 0 0 1 .33.063l2.722 2.673a.594.594 0 0 1 0 .849L11.1 10.909a.31.31 0 0 1-.331.063.301.301 0 0 1-.19-.274V9.02H5.677z" /></svg><span>Sign Out</span></a></li></ul></div></li></ul></nav></header>



      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="ch16.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Beginning Lua Programming
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="ch16.html#" title="Search in archive" class="js-search-controls search-controls" onclick="window.Appcues.track('SearchBook_HeronBook')"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9780470069172/chapter/ch16.html"><div class="js-collections-dropdown collections-dropdown menu-bit-cards" onclick="window.Appcues.track('AddPlaylist_HeronBook')"></div></div></li><li class="js-font-control-panel font-control-activator"><a href="ch16.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size" onclick="window.Appcues.track('ChangeFont_HeronBook')"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="ch16.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share" onclick="window.Appcues.track('Share_HeronBook')"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a
        class="twitter share-button t-twitter"
        target="_blank"
        aria-label="Share this section on Twitter"
        title="Share this section on Twitter"
      
        href="https://twitter.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch16.html&text=Beginning%20Lua%20Programming&via=OReillyMedia"
      ><span>Twitter</span></a></li><li><a
        class="facebook share-button t-facebook"
        target="_blank"
        aria-label="Share this section on Facebook"
        title="Share this section on Facebook"
        href="https://www.facebook.com/sharer/sharer.php?u=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch16.html"
      ><span>Facebook</span></a></li><li><a
        class="googleplus share-button t-googleplus"
        target="_blank"
        aria-label="Share this secton on Google Plus"
        title="Share this secton on Google Plus"
        href="https://plus.google.com/share?url=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch16.html"
      ><span>Google Plus</span></a></li><li><a
        class="email share-button t-email"
        aria-label="Share this section via email"
        title="Share this section via email"
      
        href="mailto:?subject=Safari: 16.%20Connecting%20to%20a%20Larger%20World&body=https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/ch16.html%0D%0Afrom Beginning%20Lua%20Programming%0D%0A"
      ><span>Email</span></a></li></ul></li><!-- endif request.user.is_authenticated -->
      </ul>
    </div>

      
          
      

    <section role="document">
        
        




  <script defer src="https://learning.oreilly.com/static/js/build/djangoMessagesPage.bfaca9fd8619.js"></script>


        <script src="https://fast.appcues.com/48743.js"></script>
<script>
  var userId = "ce47de5b-ce80-49f0-b5cd-c60d3d33b198";

  var userObject = {
    firstName: "Michael",
    segment: "Trial",
    admin: "False",
    profileCreatedOn: "2021-05-13",
    academic: ""
  };
  window.Appcues.identify(userId, userObject);
  window.Appcues.page();

  setTimeout(function () {
    window.Appcues.track('ViewingBook_HeronBook')
  }, 20000);
</script>


	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="ch15.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">15. Programming for the Web</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="ch17.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">17. Programming Games with Lua</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="connecting_to_a_larger_world"></a>Chapter 16. Connecting to a Larger World</h1></div></div></div><p>In the previous chapter, you used Lua in conjunction with web servers and web browsers—applications that take care of networking details and let you focus on dynamic content and presentation. In this chapter, you'll burrow in a little deeper and learn how to manage those communication details using Lua. The principal tool you'll use in doing this is the LuaSocket library. This package lets you connect your Lua scripts to other programs, whether those programs are running on your own machine, on another machine in your home or office network, or on an Internet server located on the other side of the globe. The facets of this library and networking in general that you'll learn about are as follows:<a id="IDX-CHP-16-0001" class="indexterm"></a><a id="IDX-CHP-16-0002" class="indexterm"></a><a id="IDX-CHP-16-0003" class="indexterm"></a><a id="IDX-CHP-16-0004" class="indexterm"></a><a id="IDX-CHP-16-0005" class="indexterm"></a><a id="IDX-CHP-16-0006" class="indexterm"></a><a id="IDX-CHP-16-0007" class="indexterm"></a><a id="IDX-CHP-16-0008" class="indexterm"></a><a id="IDX-CHP-16-0009" class="indexterm"></a><a id="IDX-CHP-16-0010" class="indexterm"></a><a id="IDX-CHP-16-0011" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Building and installing LuaSocket<a id="IDX-CHP-16-0012" class="indexterm"></a></p></li><li class="listitem"><p>The rudiments of the Berkeley sockets interface</p></li><li class="listitem"><p>The basics of programming for the Internet</p></li><li class="listitem"><p>Implementing simple client and server scripts</p></li><li class="listitem"><p>Retaining a server-side state with coroutines</p></li><li class="listitem"><p>Sending and receiving e-mail</p></li><li class="listitem"><p>Serving and retrieving web pages</p></li><li class="listitem"><p>Processing content with filters</p></li><li class="listitem"><p>Using standard streams in a networked environment</p></li></ul></div><p>You'll find the LuaSocket library to be a natural extension of the language that adds an entirely new dimension to your applications. At its simplest, it makes communicating with another program as easy as reading from and writing to a file.</p><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="installing_luasocket"></a>Installing LuaSocket</h1></div></div></div><p>LuaSocket is the work of Diego Nehab, an active member of the Lua community, and is made available with the same terms as Lua itself. It is widely used on the Linux, Mac OS X, and Windows platforms, and should work fine on all Unix-like systems. In addition to the source package, a package with precompiled dynamic link libraries is available for Windows. Obtain LuaSocket from <code class="literal">luaforge.net</code>. The instructions that follow assume version 2.0.1, but you'll want to download a later version if one is available. In the event that a more recent version is available, the instructions regarding the compatibility module may no longer apply.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="compiling_luasocket"></a>Compiling LuaSocket</h2></div></div></div><p>Compiling the LuaSocket library is straightforward. The installable product comprises two core dynamically linked libraries and a number of Lua scripts.</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="compiling_on_linux_and_other_unix-like_s"></a>Compiling on Linux and Other Unix-Like Systems</h3></div></div></div><p>To compile the LuaSocket library on Linux and other Unix-like systems, follow these steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Extract the downloaded package.</p></li><li class="listitem"><p>Replace <code class="literal">/path/to</code> in the following command with the location of the source package:</p><pre class="programlisting">tar xzvf /path/to/luasocket-2.0.1.tar.gz</pre></li><li class="listitem"><p>Drop into the source package's directory:</p><pre class="programlisting">cd luasocket-2.0.1</pre></li><li class="listitem"><p>Using your text editor, open the file named <code class="literal">config</code> and make the following changes, using values that pertain to your particular system:</p><pre class="programlisting">LUAINC=-I/usr/local/include
INSTALL_TOP_SHARE=/usr/local/lib/lua/5.1
INSTALL_TOP_LIB=/usr/local/lib/lua/5.1</pre></li><li class="listitem"><p>After saving these changes, open the file named <code class="literal">makefile</code> and remove all lines that refer to <code class="literal">compat</code>, such as this:</p><pre class="programlisting">$(COMPAT)/compat-5.1.o</pre></li><li class="listitem"><p>Save your changes and do the same with the <code class="literal">src/makefile</code>.</p></li><li class="listitem"><p>Build and install the library:</p><pre class="programlisting">make
make install</pre></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="compiling_on_windows"></a>Compiling on Windows</h3></div></div></div><p>You can run the following instructions from a Windows command shell. The <code class="literal">makefiles</code> that come with LuaSocket are Unix-oriented, so you won't use them here. These instructions assume that you've got your development environment set up as shown in <a class="link" href="ch01.html" title="Chapter 1. Getting Situated">Chapter 1</a>.</p><p>Follow these steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Extract the contents of the <code class="literal">luasocket-2.0.1.tar.gz</code> package to the directory in which you will compile the library. To do this with 7-zip, use the following commands, replacing <code class="literal">\path\to</code> with the location of the downloaded package:</p><pre class="programlisting">7z x \path\to\luasocket-2.0.1.tar.gz
7z x luasocket-2.0.1.tar
del luasocket-2.0.1.tar</pre></li><li class="listitem"><p>Drop into the <code class="literal">src</code> subdirectory of the newly created tree, like this:<a id="IDX-CHP-16-0013" class="indexterm"></a><a id="IDX-CHP-16-0014" class="indexterm"></a></p><pre class="programlisting">cd luasocket-2.0.1\src</pre></li><li class="listitem"><p>The <code class="literal">unix.c</code> and <code class="literal">usocket.c</code> files are not used in the Windows version. Effectively remove them from the set by renaming their extension as follows:</p><pre class="programlisting">ren unix.c unix.c00
ren usocket.c usocket.c00</pre></li><li class="listitem"><p>Compile the C files as follows:</p><pre class="programlisting">cl /c /nologo /Zl /Zd /Yd /MD /W3 /DWIN32 /DWIN32_LEAN_AND_MEAN *.c</pre></li><li class="listitem"><p>Separate the MIME library module from the others like this:</p><pre class="programlisting">ren mime.obj mime.o</pre></li><li class="listitem"><p>Link the socket library as follows:</p><pre class="programlisting">link /DLL /out:socket.dll /base:0x67800000 /export:luaopen_socket_core <div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/U002.png" alt="Compiling on Windows" width="12" height="12"></div>
  *.obj msvcrt.lib lua5.1.lib wsock32.lib</pre></li><li class="listitem"><p>Link the MIME library as follows:</p><pre class="programlisting">link /DLL /out:mime.dll /base:0x67700000 /export:luaopen_mime_core <div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/U002.png" alt="Compiling on Windows" width="12" height="12"></div>
  mime.o msvcrt.lib lua5.1.lib</pre></li><li class="listitem"><p>Copy the dynamic link libraries and support scripts to the installation directory as follows:</p><pre class="programlisting">xcopy socket.dll "%LUA_DIR%\socket\core.*"
xcopy mime.dll "%LUA_DIR%\mime\core.*"
xcopy socket.lua "%LUA_DIR%\*.*"
xcopy mime.lua "%LUA_DIR%\*.*"
xcopy ltn12.lua "%LUA_DIR%\*.*"
xcopy ftp.lua "%LUA_DIR%\socket\*.*"
xcopy http.lua "%LUA_DIR%\socket\*.*"
xcopy smtp.lua "%LUA_DIR%\socket\*.*"
xcopy tp.lua "%LUA_DIR%\socket\*.*"
xcopy url.lua "%LUA_DIR%\socket\*.*"</pre></li></ol></div></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="installing_windows_binaries"></a>Installing Windows Binaries</h2></div></div></div><p>A binary package of LuaSocket that is compatible with the Window binary package of Lua is available on <code class="literal">luaforge.net</code>. Download <code class="literal">luasocket-2.0.1-lua5.1-win32.zip</code> or a higher version if one is available. The zip file's contents are as follows, with directory names shown in italic:</p><pre class="programlisting"><em class="replaceable"><code>lib</code></em>
  <em class="replaceable"><code>mime</code></em>
      core.dll
  <em class="replaceable"><code>socket</code></em></pre><pre class="programlisting">core.dll
<em class="replaceable"><code>lua</code></em>
   socket.lua
   mime.lua
   ltn12.lua
   <em class="replaceable"><code>socket</code></em>
       url.lua
       tp.lua
       smtp.lua
       http.lua
       ftp.lua</pre><p>You can use an interactive tool like WinZip to extract the files, or you can use the Windows command shell as follows:<a id="IDX-CHP-16-0015" class="indexterm"></a><a id="IDX-CHP-16-0016" class="indexterm"></a><a id="IDX-CHP-16-0017" class="indexterm"></a><a id="IDX-CHP-16-0018" class="indexterm"></a><a id="IDX-CHP-16-0019" class="indexterm"></a></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Replace <code class="literal">\path\to</code> with the location of the downloaded zip file:</p><pre class="programlisting">7z x \path\to\luasocket-2.0.1-lua5.1-win32.zip
xcopy lua\*.lua "%LUA_DIR%\*.*"
xcopy lua\socket\*.lua "%LUA_DIR%\socket\*.*"
xcopy lib\mime\*.dll "%LUA_DIR%\mime\*.*"
xcopy lib\socket\*.dll "%LUA_DIR%\socket\*.*"</pre></li><li class="listitem"><p>Remove the <code class="literal">lua</code> and <code class="literal">lib</code> directories by executing the following:</p><pre class="programlisting">del /s /q lib lua</pre><p>The <code class="literal">del</code> command on older versions of Windows doesn't support these switches. In this case, try the following command instead:</p><pre class="programlisting">deltree lib lua</pre></li></ol></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="network_overview"></a>Network Overview</h1></div></div></div><p>To effectively use the LuaSocket library, you need at least a rudimentary understanding of networks, such as how computers on a network identify one another and how they exchange information.</p><p>Virtually all mainstream networks nowadays support the Internet Protocol (IP) as a means of routing data packets from one network device to another. The wide acceptance of this open standard ushered in the Internet boom. IP is just one of the well-engineered layers that allow remote computers to communicate with each other. Beneath it are layers involving standards for low-level protocols—such as communication by means of Ethernet and wireless devices—and above it are layers that coordinate packets and present them in a format suitable for applications like email programs and web browsers. Each of these layers encapsulates its tasks and presents a well-defined interface to adjacent layers, allowing for varied implementations that work well and reliably together. The LuaSocket library doesn't give you access to the lower layers of this model but, as you'll see in the sections that follow, it gives you a lot of control over the upper layers.<a id="IDX-CHP-16-0020" class="indexterm"></a></p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="routed_packets"></a>Routed Packets</h2></div></div></div><p>From its inception, the Internet was designed to be fault tolerant. As long as a path exists between two computers on the Internet, they should be able to communicate even if shorter and more direct paths are inaccessible due to equipment failure. The Internet supports this objective by breaking all data transfer into individual packets that make the journey from the originating machine to the destination machine independently. At each step along the way, routers guide a packet closer to its destination based on routing tables and current performance metrics.<a id="IDX-CHP-16-0021" class="indexterm"></a><a id="IDX-CHP-16-0022" class="indexterm"></a><a id="IDX-CHP-16-0023" class="indexterm"></a><a id="IDX-CHP-16-0024" class="indexterm"></a><a id="IDX-CHP-16-0025" class="indexterm"></a><a id="IDX-CHP-16-0026" class="indexterm"></a><a id="IDX-CHP-16-0027" class="indexterm"></a><a id="IDX-CHP-16-0028" class="indexterm"></a><a id="IDX-CHP-16-0029" class="indexterm"></a><a id="IDX-CHP-16-0030" class="indexterm"></a><a id="IDX-CHP-16-0031" class="indexterm"></a><a id="IDX-CHP-16-0032" class="indexterm"></a></p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="addresses"></a>Addresses</h2></div></div></div><p>Each machine with direct access to the Internet is identified with a unique address, either a 32-bit value (the format specified in version 4 of the IP protocol, or IPv4) or a 128-bit value (the format specified by the backwards compatible version 6 of the IP protocol, or IPv6). IPv4 addresses are conventionally expressed in <span class="emphasis"><em>dotted-decimal</em></span> or <span class="emphasis"><em>dotted-quad</em></span> notation in which the individual byte values, or <span class="emphasis"><em>octets</em></span>, are delimited with a dot, for example <code class="literal">192.168.0.1</code>. The most significant portion of the address identifies the network in which a machine resides and the least significant portion identifies the device within the network.<a id="IDX-CHP-16-0033" class="indexterm"></a><a id="IDX-CHP-16-0034" class="indexterm"></a></p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="domain_names"></a>Domain Names</h2></div></div></div><p>An important level of indirection allows you to use symbolic names like <code class="systemitem">www.lua.org</code> rather than IP addresses. If you were to move the Lua website to another network, its nameserver record would be updated to point to the new address relieving users throughout the world from the need to modify their records. The mechanism that supports this mapping is hierarchical and distributed and is known as <span class="emphasis"><em>DNS</em></span> (Domain Name System). The hierarchy is apparent in the ordering of the dot-delimited names; for example, <code class="literal">www</code> is just one of possibly many hosts or subdomains at the Lua site, and <code class="literal">lua</code> is just one of many second level domains in the <code class="literal">org</code> top level domain. The mappings between host name and IP address are managed by name servers distributed throughout the Internet, each having authority for its own particular domain.</p><p>LuaSocket gives you access to DNS, allowing you to obtain host information either by IP address or by host name. There are three functions in the <code class="literal">dns</code> namespace (which in turn belongs to the <code class="literal">socket</code> namespace):<a id="IDX-CHP-16-0035" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">socket.dns.gethostname()</code>: Returns the host name of the machine on which the function is called.</p></li><li class="listitem"><p><code class="literal">socket.dns.tohostname(IP address or host name)</code>: Returns, on success, the canonical name corresponding to the specified address followed by a table containing summary information including alias host names. On error, it returns <code class="literal">nil</code> followed by an error message. The canonical name is the principal host name registered with an IP address; aliases are alternative host names that resolve to this same IP address.</p></li><li class="listitem"><p><code class="literal">socket.dns.toip(host name or IP address)</code>: Returns, on success, the IP address corresponding to the specified address followed by a table containing summary information including alias host names. On error, it returns <code class="literal">nil</code> followed by an error message.</p></li></ul></div><p>The last two functions accept either an IP address or a host name. This is a convenient feature shared by most functions in the LuaSocket library. You should note that the convenience of using host names comes at a cost; a potentially long DNS lookup will need to be made to resolve the name to an IP address. However, subsequent lookups for a given name are usually fast because the name and address association will be cached locally.</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_name_and_number_comma_p"></a>Try It Out: Name and Number, Please</h3></div></div></div><p>Usually when you access the principal Lua website, you specify <code class="systemitem">www.lua.org</code> and let your browser handle the details of obtaining the site's IP address. Here, you dig a little beneath the surface and use DNS to find out more about this site.<a id="IDX-CHP-16-0036" class="indexterm"></a><a id="IDX-CHP-16-0037" class="indexterm"></a><a id="IDX-CHP-16-0038" class="indexterm"></a><a id="IDX-CHP-16-0039" class="indexterm"></a><a id="IDX-CHP-16-0040" class="indexterm"></a><a id="IDX-CHP-16-0041" class="indexterm"></a></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>With your text editor, create a new Lua file with the following contents:</p><pre class="programlisting">local socket = require("socket")
require("show")

local Ip = {socket.dns.toip("www.lua.org")}

ObjectShow(Ip, "toip")</pre><p>The <code class="literal">ObjectShow</code> function comes from the <code class="literal">show</code> module introduced in <a class="link" href="ch07.html" title="Chapter 7. Using Modules">Chapter 7</a>.</p></li><li class="listitem"><p>Save this file as <code class="literal">dns_test.lua</code>.</p></li><li class="listitem"><p>While connected to the Internet, run this script from a command shell:</p><pre class="programlisting"><strong class="userinput"><code>lua dns_test.lua</code></strong>
["toip"] table: 00414F28 (n = 2)
   [1] "62.197.40.9"
   [2] table: 00414FD8 (n = 0)
      ["alias"] table: 00410C68 (n = 2)
         [1] "www.lua.org"
         [2] "zeus.pepperfish.net"
      ["ip"] table: 00410C00 (n = 1)
        [1] "62.197.40.9"
      ["name"] "babel.pepperfish.net"</pre></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-052"></a>How It Works</h3></div></div></div><p>The <code class="literal">socket.dns.toip</code> function calls on the services of a <span class="emphasis"><em>resolver library</em></span> to obtain information about the specified host. The first value that is returned is the current IP address of <code class="systemitem">www.lua.org</code>; this is followed by a table containing summary information including alias host names, canonical host name and IP address. In this case, you can see that <code class="systemitem">www.lua.org</code> is an alias for <code class="literal">babel.pepperfish.net</code>. Note that this behind-the-scenes information is subject to change; when you run this script, the site hosting <code class="systemitem">www.lua.org</code> may have changed.<a id="IDX-CHP-16-0042" class="indexterm"></a></p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="identifying_internet_resources"></a>Identifying Internet Resources</h2></div></div></div><p>Most resources on the Internet can be named with a URL, which is a standard way of identifying web pages, images, and other resources and the means by which you access them. URLs are described in more detail in <a class="link" href="ch15.html" title="Chapter 15. Programming for the Web">Chapter 15</a>. LuaSocket provides support for, according to Diego, "anything you could possibly want to do with" a URL.</p><p>If you write an application that works with Internet resources, you can use <code class="literal">url.parse</code> to get the details you need to connect with a remote server and make a request. This function receives a URL string and breaks it into its constituent parts.</p><p><code class="literal">url.parse(URL string, optional result table)</code> returns a table with the specified URL's string components keyed with the names <code class="literal">url, scheme, authority, path, params, query, fragment, userinfo, host, port, user</code>, and <code class="literal">password</code>. If the result table is provided, the components are placed into it rather than a new table. Fields in this table that are not overwritten are left alone.<a id="IDX-CHP-16-0043" class="indexterm"></a><a id="IDX-CHP-16-0044" class="indexterm"></a><a id="IDX-CHP-16-0045" class="indexterm"></a></p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_unfurling_a_url"></a>Try It Out: Unfurling a URL</h3></div></div></div><p>As one example pertaining to the <code class="literal">socket.url</code> module, use <code class="literal">url.parse</code> to break a rather contrived URL into its component parts.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a Lua file with the following contents:</p><pre class="programlisting">local url = require("socket.url")
require("show")

local UrlStr = "http://natty:pathfinder@www.example.net:8888" ..
   "/susquehanna;loc?date=1793#title"
ObjectShow(url.parse(UrlStr), "URL")</pre></li><li class="listitem"><p>Save this script as <code class="literal">url_01.lua</code>.</p></li><li class="listitem"><p>Run the script as follows:</p><pre class="programlisting"><strong class="userinput"><code>lua url_01.lua</code></strong>
["URL"] table: 00413760 (n = 0)
    ["authority"] "natty:pathfinder@www.example.net:8888"
    ["fragment"] "title"
    ["host"] "www.example.net"
    ["params"] "loc"
    ["password"] "pathfinder"
    ["path"] "/susquehanna"
    ["port"] "8888"
    ["query"] "date=1793"
    ["scheme"] "http"
    ["user"] "natty"
    ["userinfo"] "natty:pathfinder"</pre></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-053"></a>How It Works</h3></div></div></div><p>The <code class="literal">url.parse</code> function extracts components within the specified URL as substrings. For example, notice that the value of <code class="literal">port</code> is saved as a string rather than a number. Also, note that certain intermediate components are stored in the result table as well. For example, in this case the <code class="literal">authority</code> field includes the intermediate <code class="literal">userinfo</code> field which in turn includes the <code class="literal">user</code> and <code class="literal">password</code> fields.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="transport_protocols"></a>Transport Protocols</h2></div></div></div><p>On top of IP are two protocols to which LuaSocket gives you access: UDP (User Datagram Protocol) and TCP (Transmission Control Protocol). These are so-called <span class="emphasis"><em>transport</em></span> protocols, which means that they're in charge of getting information from one application to another. In a characteristic layered approach, they use IP to handle packet routing details, and IP in turn uses the underlying hardware to handle the physical signal transmission details needed to transfer information.<a id="IDX-CHP-16-0046" class="indexterm"></a><a id="IDX-CHP-16-0047" class="indexterm"></a></p><p>Here are more detailed descriptions of UDP and TCP:<a id="IDX-CHP-16-0048" class="indexterm"></a><a id="IDX-CHP-16-0049" class="indexterm"></a><a id="IDX-CHP-16-0050" class="indexterm"></a><a id="IDX-CHP-16-0051" class="indexterm"></a><a id="IDX-CHP-16-0052" class="indexterm"></a><a id="IDX-CHP-16-0053" class="indexterm"></a><a id="IDX-CHP-16-0054" class="indexterm"></a><a id="IDX-CHP-16-0055" class="indexterm"></a><a id="IDX-CHP-16-0056" class="indexterm"></a><a id="IDX-CHP-16-0057" class="indexterm"></a><a id="IDX-CHP-16-0058" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>UDP:</strong></span> A short step away from IP is UDP, a protocol that specifies how <span class="emphasis"><em>datagrams</em></span> are exchanged between applications. This protocol has low overhead and is consequently very fast. However, UDP doesn't attempt to straighten out problems with datagrams that are lost in transit, arrive at their destination out-of-sequence, or contain errors introduced in transmission. The high reliability of modern networks has made problems like this less likely to occur than in earlier years. The LuaSocket documentation includes an example client script that uses UDP to connect with a remote daytime server.</p></li><li class="listitem"><p><span class="strong"><strong>TCP:</strong></span> The predominant transport protocol of the Internet is TCP. A veritable roster of application protocols with initialized names depend on it: the web (HTTP and HTTPS), mail (SMTP, IMAP, POP), file transfer (FTP), and secure shell (SSH) among many others. This protocol allows applications to send and receive a stream of data without worrying about the problems that may beset the data in transit. When data is transmitted, TCP splits it into packets suitable for conveyance by IP. On the receiving end, TCP requests that missing or corrupted packets be resent, puts arriving packets in their original order, and recombines the packets into a stream of bytes.<a id="IDX-CHP-16-0059" class="indexterm"></a></p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="sockets_colon_streams_and_datagrams"></a>Sockets: Streams and Datagrams</h2></div></div></div><p>A library of routines and data structures that provide applications with abstracted access to the UDP and TCP protocols was developed at Berkeley in the early 80s. The model this library implements is known as the <span class="emphasis"><em>Berkeley sockets interface</em></span> and has become the standard way for applications to communicate with one another on the Internet. In the Berkeley model, a socket represents one end of a connection. It has associated with it an IP address and a port and must be of type TCP or UDP. The IP address must be associated with one of the machine's interfaces; these can be physical such as Ethernet interfaces, or virtual such as the loopback interfaces or virtual private network interfaces. The port number is a two-byte value that identifies a particular service accessible on an interface.<a id="IDX-CHP-16-0060" class="indexterm"></a><a id="IDX-CHP-16-0061" class="indexterm"></a><a id="IDX-CHP-16-0062" class="indexterm"></a><a id="IDX-CHP-16-0063" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>UDP:</strong></span> This is sometimes referred to as a <span class="emphasis"><em>datagram</em></span> socket. You generally want to read the entire datagram when receiving data with this type of socket; anything not read is discarded.</p></li><li class="listitem"><p><span class="strong"><strong>TCP:</strong></span> This is often referred to as a <span class="emphasis"><em>stream</em></span> or <span class="emphasis"><em>connection-oriented</em></span> socket because, when you connect it to a peer, you can use it for a two way dialog in which streams of bytes are exchanged. Reading data from a remotely connected socket is done with a client socket's <code class="literal">receive</code> method. On success, <code class="literal">ClientHnd:receive(read pattern, optional prefix)</code> returns a Lua string containing the received data matching the specified pattern. If the method fails, <code class="literal">nil</code> is returned followed by an error message and the partial contents of the received data. The first argument to this method indicates how much data is to be read: the next line (the default), the next fixed block of bytes, or everything that is sent by the remote socket until the connection is closed. All patterns have comparable performance, so select the one that is easiest to work with for your particular application. The following table provides a summary of the LuaSocket <code class="literal">receive</code> patterns.</p></li></ul></div><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"><col class="col2"></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Pattern</p></th><th style="text-align: left" valign="bottom"><p>Explanation</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>*<code class="literal">a</code></p></td><td style="text-align: left" valign="top"><p>Before closing a socket, an application can indicate by means of the <code class="literal">shutdown</code> method that it is finished sending data. The receiver can detect this condition, or a closed sending socket, and use it to deliver the entire amount of data transmitted.</p></td></tr><tr><td style="text-align: left" valign="top"><p>*<code class="literal">l</code><a id="IDX-CHP-16-0064" class="indexterm"></a><a id="IDX-CHP-16-0065" class="indexterm"></a><a id="IDX-CHP-16-0066" class="indexterm"></a><a id="IDX-CHP-16-0067" class="indexterm"></a><a id="IDX-CHP-16-0068" class="indexterm"></a><a id="IDX-CHP-16-0069" class="indexterm"></a></p></td><td style="text-align: left" valign="top"><p>LuaSocket reads data up to the next end-of-line marker. This can be a CR (carriage return) LF (linefeed) pair, or a standalone LF. These markers are not returned. Many application protocols are line-oriented. This pattern is used if the pattern argument is missing.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">Number</code></p></td><td style="text-align: left" valign="top"><p>The next available number of bytes is read. In this case, LuaSocket does not translate or interpret end-of-line markers. Blocks of specified length may be useful when reading a header that contains information about the amount of data to follow.</p></td></tr></tbody></table></div><p>If a prefix is specified, it will be prepended to the returned data string.</p><p>Client TCP sockets send data to one another by means of the <code class="literal">send</code> method. On success, <code class="literal">ClientHnd:send(data string, optional start, optional end)</code> returns the position of the last byte sent. On error, the method returns <code class="literal">nil</code> followed by an error message and the position of the last byte successfully sent. You can use the <span class="emphasis"><em>start</em></span> and <span class="emphasis"><em>end</em></span> arguments to send a substring rather than the entire string.<a id="IDX-CHP-16-0070" class="indexterm"></a><a id="IDX-CHP-16-0071" class="indexterm"></a></p><p>By default, the functions used to send and receive data will block; that is, they will retain control until the operation has completed. A blocking function simplifies programming somewhat, but it can be a trapdoor for the unwary because it can deprive your program of control needed for other connections. The Berkeley sockets interface provides an effective way to deal with this by including a <code class="literal">select</code> function that lets you know which sockets in a pool are ready for reading and which are ready for writing. Additionally, LuaSocket lets you set timeout values to bail out of a function if it doesn't respond in the specified time. As you'll see, a combination of these two features makes it possible to write responsive application servers in Lua.</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="tcp_socket_sociology"></a>TCP Socket Sociology</h2></div></div></div><p>A TCP socket is created by calling <code class="literal">socket.tcp</code>. If this function succeeds, a new socket handle is returned, otherwise <code class="literal">nil</code> followed by an error message is returned. The returned socket is referred to in the LuaSocket documentation as a <span class="emphasis"><em>master object</em></span>, but in some respects it isn't yet even an apprentice; it has a limited skill set and is unable to communicate with peers. There are two career paths open to such a socket: through calls to <code class="literal">bind</code> and <code class="literal">listen</code> it can become a <span class="emphasis"><em>server object</em></span>, or through a call to <code class="literal">connect</code> it can become a <span class="emphasis"><em>client object</em></span>. One thing it cannot do in this phase is transfer information with another socket.<a id="IDX-CHP-16-0072" class="indexterm"></a><a id="IDX-CHP-16-0073" class="indexterm"></a><a id="IDX-CHP-16-0074" class="indexterm"></a><a id="IDX-CHP-16-0075" class="indexterm"></a></p><p>When a TCP socket graduates to client or server status, its associated methods change. LuaSocket lets you know if you attempt to call a method on a socket that isn't of the right type. For example, calling <code class="literal">accept</code> on a master socket will result in an error with the following message:</p><pre class="programlisting">calling 'accept' on bad self (tcp{server} expected, got userdata)</pre><p>The <code class="literal">tcp{server}</code> notation is how LuaSocket renders a server socket with <code class="literal">tostring</code>. In general, a server socket's job is to listen on a well-known port, which is a port that is associated with the service that the application renders. For example, a web server listens on port 80 and an FTP server listens on port 21. When the <code class="literal">accept</code> method of a server socket detects an inbound connection request, it creates and returns a new socket that is connected with the remote socket. The returned value is a client socket. The nomenclature can be a little misleading because such a socket is part of a server application, but it's arguably appropriate, because the socket has the same capabilities as a client socket returned from a call to <code class="literal">connect</code>.</p><p>A client socket created by <code class="literal">accept</code> and a client socket created by <code class="literal">connect</code> are <span class="emphasis"><em>peers</em></span>. Their job is to transfer information with each other, and the principal means used to do this are the <code class="literal">send</code> and <code class="literal">receive</code> methods. When peers are connected, there is an IP address and a port at each end. The address and port of the server are usually well-known, for example port 80 at <code class="systemitem">www.example.com</code>, but in general the address and port of the connecting client are decided by the sockets library rather than the application itself. The port that the library selects for you is called <span class="emphasis"><em>ephemeral</em></span> because it is recycled after the connection is closed. When using the <code class="literal">socket.connect</code> shortcut to create a client socket, you can optionally specify an address and port. You might want to do this if you have more than one interface that could be used to connect with the remote server and have some reason to favor one. If you want to specify an address but don't care about the port, you can use 0 as the port value.<a id="IDX-CHP-16-0076" class="indexterm"></a><a id="IDX-CHP-16-0077" class="indexterm"></a><a id="IDX-CHP-16-0078" class="indexterm"></a><a id="IDX-CHP-16-0079" class="indexterm"></a><a id="IDX-CHP-16-0080" class="indexterm"></a><a id="IDX-CHP-16-0081" class="indexterm"></a><a id="IDX-CHP-16-0082" class="indexterm"></a></p></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="using_luasocket_for_network_communicatio"></a>Using LuaSocket for Network Communication</h1></div></div></div><p>The following Try It Outs demonstrate sockets in action. Keep in mind that these examples use LuaSocket at a rather low level; many applications using the package never deal directly with sockets. The first exercise will use Lua scripts for both ends—the server and the client—of a communication link. In the second exercise, you'll implement a very simplistic web server with a Lua script. In this case, you'll use a web browser for the client side of the connection.</p><div class="sidebar"><a id="try_it_out_colon_using_two_servers_and_a"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Using Two Servers and a Client</strong></p></div></div></div><p>LuaSocket gives your Lua scripts access to Berkeley sockets. Here, you'll open up three command shells and explore the basic practice of listening and connecting sockets.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>With your text editor, create a new Lua file with the following contents:</p><pre class="programlisting">local socket = require("socket")

local Addr = arg[1] or "127.0.0.1"
local Port = tonumber(arg[2] or 11250)
local Str, Len, SckHnd, ClientHnd, ErrStr, BindAddr, BindPort, ClAddr, ClPort
SckHnd, ErrStr = socket.bind(Addr, Port)
if SckHnd then
  BindAddr, BindPort = SckHnd:getsockname()
  io.write("Listening on ", BindAddr, ", port ", BindPort, "\n")
  ClientHnd, ErrStr = SckHnd:accept()
  if ClientHnd then
    ClAddr, ClPort = ClientHnd:getpeername()
    io.write("Connection from ", ClAddr, ", port ", ClPort, "\n")
    Str = string.format("Greetings from %s:%d to %s:%d\r\n",
       BindAddr, BindPort, ClAddr, ClPort)
    Len, ErrStr = ClientHnd:send(Str)
    if Len then
      Str, ErrStr = ClientHnd:receive()
      if Str then
        io.write("Received from client: [", Str, "]\n")
      else
        io.write("Receive error: ", ErrStr, "\r\n")</pre><pre class="programlisting">end
       ClientHnd:shutdown("both")
     else
       io.write("Send error: ", ErrStr, "\n")
     end
     ClientHnd:close()
   else
     io.write("Client connection. ", ErrStr, "\n")
   end
   SckHnd:close()
 else
   io.write("Listening socket. ", ErrStr, "\n")
 end</pre></li><li class="listitem"><p>Save this file as <code class="literal">server_01.lua</code>.</p></li><li class="listitem"><p>With your text editor, create another new Lua file with the following contents:</p><pre class="programlisting">local socket = require("socket")

local Addr = arg[1] or "127.0.0.1"
local Port = tonumber(arg[2] or 11250)
local SckHnd, ErrStr, Str, ClAddr, ClPort, SrvAddr, SrvPort
SckHnd, ErrStr = socket.connect(Addr, Port, "127.0.0.1", 0)
if SckHnd then
  ClAddr, ClPort = SckHnd:getsockname()
  SrvAddr, SrvPort = SckHnd:getpeername()
  io.write("Connected with ", SrvAddr, " on port ", SrvPort, "\n")
  Str, ErrStr = SckHnd:receive()
  if Str then
    SckHnd:send(string.format("Greetings from %s:%d to %s:%d\r\n",
       ClAddr, ClPort, SrvAddr, SrvPort))
     io.write("Got [", Str, "] from server\n")
   else
     io.error("Error. ", ErrStr, "\n")
   end
   SckHnd:close()
 else
   io.write("Connecting socket. ", ErrStr, "\n")
 end</pre></li><li class="listitem"><p>Save this file as <code class="literal">client_01.lua</code>.</p></li><li class="listitem"><p>Open three command shells and, in each, use <code class="literal">cd</code> to change to the directory in which the two scripts are saved. If possible, size and arrange each shell display so they are all visible on the screen.</p></li><li class="listitem"><p>In one command shell, invoke the server as follows:</p><pre class="programlisting"><strong class="userinput"><code>lua server_01.lua 127.1.2.3</code></strong>
Listening on 127.1.2.3, port 11250</pre></li><li class="listitem"><p>In another command shell, invoke another server as follows:</p><pre class="programlisting"><strong class="userinput"><code>lua server_01.lua 127.101.102.103</code></strong>
Listening on 127.101.102.103, port 11250</pre></li><li class="listitem"><p>In the third command shell, invoke the client script as follows:<a id="IDX-CHP-16-0083" class="indexterm"></a></p><pre class="programlisting"><strong class="userinput"><code>lua client_01.lua 127.1.2.3</code></strong>
Connected with 127.1.2.3 on port 11250
Got [Greetings from 127.1.2.3:11250 to 127.0.0.1:32822] from server</pre><p>The script in the first shell will terminate after displaying the following line:</p><pre class="programlisting">Connection from 127.0.0.1, port 32822
Received from client: [Greetings from 127.0.0.1:32822 to 127.1.2.3:11250]</pre><p>In general, you'll see an ephemeral port value different than 32822 in the server's response.</p></li><li class="listitem"><p>In the third command shell, reinvoke the client script as follows:</p><pre class="programlisting"><strong class="userinput"><code>lua client_01.lua 127.101.102.103</code></strong>
Connected with 127.101.102.103 on port 11250
Got [Greetings from 127.101.102.103:11250 to 127.0.0.1:32821] from server</pre><p>The script in the second shell will terminate after displaying the following line:</p><pre class="programlisting">Connection from 127.0.0.1, port 32821
Received from client: [Greetings from 127.0.0.1:32821 to 127.101.102.103:11250]</pre><p>As before, you'll likely see a value different than 32821 when you run the script.</p></li></ol></div><p><span class="strong"><strong>How It Works</strong></span></p><p>This example illustrates network connections that take place over your machine's virtual loopback device, effectively connecting your machine to itself. A number of observations can be made from the output of these scripts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Your machine can listen for incoming connections on the same port as long as the listening sockets are bound to different interfaces. Virtual web servers are set up this way.</p></li><li class="listitem"><p>A socket-based network connection involves client sockets at each end. The server application creates a client socket when <code class="literal">accept</code> responds to a connection request, and the client application creates a client socket by calling <code class="literal">connect</code>.</p></li><li class="listitem"><p>IP address and port information about the remote socket is available through the <code class="literal">getpeername</code> method, but this information is not required to conduct a dialog.</p></li></ul></div></div><p>A design objective of the World Wide Web was to keep web servers simple. While today's mainstream servers are a good deal more complex than their early predecessors, they are still considerably simpler than web browsers because they don't have to deal with content rendering and the user interface.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="using_luasocket_for_network_communicati"></a></h2></div></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_creating_a_simple_web_s"></a>Try It Out: Creating a Simple Web Server</h3></div></div></div><p>LuaSocket has everything you need to script a functional web server. The server you'll build here is light-duty by any definition, but it provides you with a basic framework on which you can add features, including the generation of dynamic content.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a new Lua file with your text editor and add the following contents:</p><pre class="programlisting">local socket = require("socket")
require "show"

local Cn = {}

Cn.Host = "localhost"

Cn.Port = 80

Cn.MimeList = {
  css = "text/css",
  gif = "image/gif",
  htm = "text/html",
  html = "text/html",
  png = "image/png",
  txt = "text/plain" }

local function LclHdrRead(ClSck)
  local Hdr = {}
  local LineStr, ErrStr
  LineStr, ErrStr = ClSck:receive()
  if LineStr then
    -- "GET /page.html HTTP/1.1" -&gt; "GET", "page.html"
    Hdr.Cmd, Hdr.Path = string.match(LineStr, "^(%S+)%s+%/(%S)")
    while LineStr do
      LineStr, ErrStr = ClSck:receive()
      if LineStr then
        if LineStr ~= "" then
          local Key, Val = string.match(LineStr, "^(.-)%:%s*(.*)$")
          Hdr[string.lower(Key)] = Val
        else
          LineStr = nil -- End loop at first blank line
        end
      end
    end
  end
  if (not Hdr.Path) or (Hdr.Path == "") then
    Hdr.Path = "index.html"
  end
  return Hdr
end

local function LclSend(Client, BodyStr, MimeStr, CodeStr)
  local SendStr =
    'HTTP/1.1 ' .. (CodeStr or '200 OK') .. '\r\n' ..
    'Date: ' .. os.date() .. '\r\n' ..
    'Server: webserver.lua/0.1\r\n' ..
    'Content-Length: ' .. string.len(BodyStr) .. '\r\n' ..
    'Content-Type: ' .. (MimeStr or 'text/html') .. '\r\n\r\n' .. BodyStr
  Client:send(SendStr)
  Client:shutdown() -- We're finished with this transaction
end</pre><pre class="programlisting">local function LclSendFile(Client, FileStr)
    local Hnd = io.open(FileStr, "rb")
    if Hnd then
      local Str = Hnd:read("all")
      if Str then
        local ExtStr = string.lower(string.match(FileStr, "%P+$"))
        local MimeStr = Cn.MimeList[ExtStr] or "application/octet-stream"
        LclSend(Client, Str, MimeStr)
      else
        LclSend(Client, 'Error reading file.', 'text/plain',
          '500 Internal Server Error')
      end
      Hnd:close()
    else
      LclSend(Client, 'Error opening file.', 'text/plain', '404 Not Found')
    end
  end

  local Addr, Port, Server, Client, Hdr, Loop

  Server = socket.bind(Cn.Host, Cn.Port)
  if Server then
    Addr, Port = Server:getsockname()
    if Addr and Port then
      io.write("Waiting for connection from client on ", Addr, ":", Port, "\n")
      local PortStr = Port == 80 and "" or (":" .. Port)
      io.write('To end server, request "http://', Cn.Host, PortStr,
        '/quit" from browser\n')
      Loop = true
      while Loop do
        Client = Server:accept()
        if Client then
          io.write("Got client request\n")
          Addr, Port = Client:getpeername()
          if Addr and Port then
            io.write("Connected to ", Addr, ":", Port, "\n")
            Hdr = LclHdrRead(Client)
            ObjectShow(Hdr, "Hdr")
            if not string.find(Hdr.Path, "..", 1, true) then
              if Hdr.Path == "quit" then
                LclSend(Client, "Shutdown", "text/plain")
                Loop = false
              else
                LclSendFile(Client, Hdr.Path)
              end
            else
              LclSend(Client, 'Unauthorized', 'text/plain', '401 Unauthorized')
            end
          else
            io.write("Could not retrieve client address\n")
          end
          Client:close()
        else
          io.write("Error connecting to client\n")
        end
      end</pre><pre class="programlisting">io.write("Ending server loop\n")
        else
          io.write("Could not retrieve server address\n")
        end
        Server:close()
      else
        io.write("Error creating server socket\n")
      end</pre></li><li class="listitem"><p>Save the file as <code class="literal">webserver.lua</code>.</p></li><li class="listitem"><p>Before starting the server, create a web page and name it <code class="literal">index.html</code>. If you want to generate a sample page with a Lua script, you can use the following:</p><pre class="programlisting">local function FncList(Tbl, Name)
   local List = {}
   for Key, Val in pairs(Tbl) do
     if type(Val) == "function" then
       List[#List + 1] = Key
     end
   end
   table.sort(List)
   io.write('&lt;h1&gt;', Name, ' library&lt;/h1&gt;\n\n&lt;p&gt;')
   for J, Str in ipairs(List) do
     io.write(Str, " ")
   end
   io.write("&lt;/p&gt;\n\n")
 end

 io.write('&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"\n',
   '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;\n\n',
   '&lt;html&gt;\n\n&lt;head&gt;\n\n&lt;title&gt;Lua Environment&lt;/title&gt;',
   '\n\n&lt;/head&gt;\n\n&lt;body&gt;\n\n')

 local Namespace = {"coroutine", "debug", "io", "math", "os", "package",
   "string", "table"}

 FncList(_G, "base")
 for J, Tbl in ipairs(Namespace) do
   FncList(_G[Tbl], Tbl)
 end
 io.write('&lt;/body&gt;\n\n&lt;/html&gt;\n')</pre></li><li class="listitem"><p>Save this file as <code class="literal">env_page.lua</code> and use it to create an index page as follows:</p><pre class="programlisting">lua env_page.lua &gt; index.html</pre></li><li class="listitem"><p>Running this script requires that you don't currently have a TCP service listening on port 80 of your machine. If you do, change the value of <code class="literal">Cn.Port</code> at the top of the script to an unused port number. Fire up the web server as follows:</p><pre class="programlisting">lua webserver.lua</pre></li><li class="listitem"><p>With your web browser, access <code class="systemitem">http://localhost/</code> to test the server. You can add links and references to images and style sheets in your index page to verify that the server returns everything as it should.</p></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-054"></a>How It Works</h3></div></div></div><p>This script has a very simple structure. First it creates a socket and binds it to the local machine (<code class="literal">localhost</code> is associated with the loopback address <code class="literal">127.0.0.1</code>), as follows:<a id="IDX-CHP-16-0084" class="indexterm"></a><a id="IDX-CHP-16-0085" class="indexterm"></a><a id="IDX-CHP-16-0086" class="indexterm"></a><a id="IDX-CHP-16-0087" class="indexterm"></a><a id="IDX-CHP-16-0088" class="indexterm"></a></p><pre class="programlisting">Server = socket.bind(Cn.Host, Cn.Port)</pre><p>It then enters a loop in which it blocks on the following line, waiting for a connection request:</p><pre class="programlisting">Client = Server:accept()</pre><p>Because the socket is bound to the loopback device, you can only access the server from the local machine, but if your machine is part of a network, you can modify the value of <code class="literal">Cn.Host</code> and access the script from a different machine.</p><p>One limitation of this server is that only one request is handled at a time. A fair amount of work is required to address this deficiency in a robust and efficient way. An elegant way to approach this problem with Lua is to use coroutines, but even with these it can be a trick to get a central event dispatcher to conform to the Berkeley sockets model. Another limitation is that it expects each inbound header to occupy only one line. Finally, this implementation does not handle nested directories in the document root robustly.</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="handling_multiple_persistent_connections"></a>Handling Multiple Persistent Connections</h1></div></div></div><p>This section examines an effective way for a server to maintain ongoing connections with clients. When you interact with an FTP or telnet server, your connection is persistent: the server maintains the context of the interaction between transactions until you log off. The emerging SSE (Server-Sent Events) standard will carry this behavior over to web browsers as well.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="using_lua_coroutines_with_the_select_fun"></a>Using Lua Coroutines with the select Function</h2></div></div></div><p>Lua coroutines and the LuaSocket <code class="literal">select</code> function make it easy for a server application to handle simultaneous connections from multiple clients. In this example, a coroutine is dedicated to each client connection. Each coroutine is uncluttered with connection details or even an awareness of other concurrent connections, allowing it to focus on the ongoing dialog with a particular client.</p><p>Follow these steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a new file with your text editor and copy in the following Lua script:</p><pre class="programlisting">local socket = require("socket")

local Cn = {SrvPort = 3072, SrvAddr = "localhost"}

local SckHnd = socket.connect(Cn.SrvAddr, Cn.SrvPort)
if SckHnd then
   local Loop = true
   local CnnSrvStr, CnnSrvPort = SckHnd:getpeername()
   local CnnNameStr = socket.dns.tohostname(CnnSrvStr)
   io.write(string.format("Connected to %s (%s) on port %d.\n",
     CnnSrvStr, CnnNameStr, CnnSrvPort))</pre><pre class="programlisting">io.write('Issue .quit to end connection, .shutdown to terminate server.\n')
   while Loop do
     local Str, ErrStr
     io.write("Send: ")
     Str = io.read() or ".quit"
     SckHnd:send(Str .. "\r\n")
     Str, ErrStr = SckHnd:receive()
     if Str then
       io.write("Received: ", Str, "\n")
     else
       Loop = false
       if ErrStr == "closed" then
         io.write("Closing connection to server\n")
       else
         io.write("Error: ", ErrStr, "\n")
       end
     end
   end
   SckHnd:close()
 else
   io.write("Error creating client socket\n")
end</pre></li><li class="listitem"><p>Save this file as <code class="literal">client_02.lua</code>.</p></li><li class="listitem"><p>Create another new file with your editor and copy in the following Lua script:</p><pre class="programlisting">local socket = require("socket")

local Cn = {HostPort = 3072, HostAddr = "*"}

local function ClientSession(SckHnd)
  local Loop, Str, ErrStr = true
  local Rcv = {}
  while Loop do
    coroutine.yield(Str)
    Str, ErrStr = SckHnd:receive()
    if Str then
      Loop = Str ~= ".quit" and Str ~= ".shutdown"
      if Loop then
        for J = 1, #Str do
          Rcv[string.byte(Str, J, J)] = true
        end
        local SendStr = ""
        for J = 33, 255 do
          if Rcv[J] then
            SendStr = SendStr .. string.char(J)
          end
        end
        SckHnd:send(SendStr .. "\r\n")
      end
    else
      io.write("Error: ", ErrStr, "\n")
    end
  end</pre><pre class="programlisting">return Str
end


local SckHnd = socket.bind(Cn.HostAddr, Cn.HostPort)
if SckHnd then
  local SckList = {} -- Array of sockets, beginning with accepting socket
  local CoList = {} -- Table of coroutines keyed by socket
  local Loop = true
  -- Prevent this socket from blocking for too long in call to accept
  SckHnd:settimeout(250)
  SckList[1] = SckHnd
  while Loop do
    io.write('Waiting for connection or data from\n')
    for J, Hnd in ipairs(SckList) do
      io.write(' ', J, ': ', tostring(Hnd), ', ', tostring(CoList[Hnd]), '\n')
    end
    local ReadTbl, WriteTbl, ErrStr = socket.select(SckList)
    for K, SckHnd in ipairs(ReadTbl) do
      if SckHnd == SckList[1] then -- Server socket
        local ClientHnd, ErrStr = SckHnd:accept()
        if ClientHnd then
          local NewPos = #SckList + 1
          SckList[NewPos] = ClientHnd
          CoList[ClientHnd] = coroutine.wrap(ClientSession)
          CoList[ClientHnd](ClientHnd)
        elseif ErrStr ~= "timeout" then
          io.write(ErrStr, "\n")
          Loop = false
        end
      else -- Client connection
        local Cmd = CoList[SckHnd]()
        if ".quit" == Cmd then
          CoList[SckHnd] = nil
          SckHnd:close()
          local L, Pos = #SckList
          while L &gt; 1 do
            if SckHnd == SckList[L] then
              table.remove(SckList, L)
              L = 1 -- Terminate search
            else
              L = L - 1
            end
          end
        elseif ".shutdown" == Cmd then
          io.write("Shutting down server\n")
          Loop = false
        end
      end
    end
  end
  for J, SckHnd in ipairs(SckList) do
    SckHnd:close()
  end</pre><pre class="programlisting">else
  io.write("Error creating server socket\n")
end</pre></li><li class="listitem"><p>Save this file as <code class="literal">server_02.lua</code>.</p></li><li class="listitem"><p>Open a command shell, use <code class="literal">cd</code> to change to the directory where you saved the scripts, and execute the following server script:</p><div class="blockquote"><blockquote class="blockquote"><p>The hexadecimal socket identifier will almost certainly be different in your case.</p></blockquote></div><pre class="programlisting"><strong class="userinput"><code>lua server_02.lua</code></strong>
Waiting for connection or data from
     1: tcp{server}: 00658CA0, nil</pre></li><li class="listitem"><p>Open another command shell, use <code class="literal">cd</code> to change to the directory where you saved the scripts, and execute the following client script:</p><pre class="programlisting"><strong class="userinput"><code>lua client_02.lua</code></strong>
Connected to 127.0.0.1 (localhost) on port 3072.
Issue .quit to end connection, .shutdown to terminate server.
Send:</pre><p>At this point, the server script prints new information indicating that the client has connected with it:</p><pre class="programlisting">Waiting for connection or data from
     1: tcp{server}: 00658CA0, nil
     2: tcp{client}: 0065BD18, function: 007684A0</pre></li><li class="listitem"><p>In response to the <code class="literal">Send</code> prompt, transmit some character sequences to the server, such as the following:</p><pre class="programlisting">Send: <strong class="userinput"><code>ajx</code></strong>
Received: ajx
Send: <strong class="userinput"><code>bky</code></strong>
Received: abjkxy
Send: <strong class="userinput"><code>clz</code></strong>
Received: abcjklxyz
Send:</pre></li><li class="listitem"><p>Open another command shell, use <code class="literal">cd</code> to change to the directory where you saved the scripts, and execute the following instance of the client script:</p><pre class="programlisting"><strong class="userinput"><code>lua client_02.lua</code></strong>
Connected to 127.0.0.1 (localhost) on port 3072.
Issue .quit to end connection, .shutdown to terminate server.
Send:</pre><p>The server script will now indicate multiple connected clients:</p><pre class="programlisting">Waiting for connection or data from
     1: tcp{server}: 00658CA0, nil
     2: tcp{client}: 0065BD18, function: 007684A0
     3: tcp{client}: 0065DD8C, function: 0076A1D0</pre></li><li class="listitem"><p>Alternate between the two client scripts, inputting characters and verifying that the server is returning the set of accumulated characters for the particular connection.<a id="IDX-CHP-16-0089" class="indexterm"></a><a id="IDX-CHP-16-0090" class="indexterm"></a><a id="IDX-CHP-16-0091" class="indexterm"></a></p></li><li class="listitem"><p>End a client session as follows:</p><pre class="programlisting">Send: <strong class="userinput"><code>.quit</code></strong>
Closing connection to server</pre><p>Note that the server prints a summary with one fewer client connection.</p></li><li class="listitem"><p>Terminate the server from the remaining active client as follows:</p><pre class="programlisting">Send: <strong class="userinput"><code>.shutdown</code></strong>
Closing connection to server</pre><p>The server script ends after printing the following:</p><pre class="programlisting">Shutting down server</pre></li></ol></div><p>The client script creates a TCP socket and connects it to a server with a well-known port (here, an arbitrarily selected value). This is done in one command:</p><pre class="programlisting">local SckHnd = socket.connect(Cn.SrvAddr, Cn.SrvPort)</pre><p>As presented, the server and clients all run on the same machine, but with the appropriate adjustment to <code class="literal">Cn.SrvAddr</code>, you can run the client script on a remotely connected machine. The following lines obtain information about the server for display purposes:</p><pre class="programlisting">local CnnSrvStr, CnnSrvPort = SckHnd:getpeername()
local CnnNameStr = socket.dns.tohostname(CnnSrvStr)</pre><p>A loop is entered in which the following things are done repeatedly:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Text is obtained from the user (<code class="literal">io.read</code>).</p></li><li class="listitem"><p>The acquired text is sent to the server (<code class="literal">SckHnd:send</code>).</p></li><li class="listitem"><p>The server's response is obtained (<code class="literal">SckHnd:receive</code>).</p></li><li class="listitem"><p>The response is displayed to the user (<code class="literal">io.write</code>).</p></li></ol></div><p>This loop continues until one of the following occurs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The user issues the <code class="literal">.quit</code> command to end the session.</p></li><li class="listitem"><p>The user issues the <code class="literal">.shutdown</code> command to terminate the server.</p></li><li class="listitem"><p>Another client issues the <code class="literal">.shutdown</code> command. In this case, the client loop won't end until it attempts to send some data to the now defunct server.</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="multiple_connections_on_the_server_side"></a>Multiple Connections on the Server Side</h2></div></div></div><p>Things are a little more involved on the server side, but the actual business logic (the code that actually interacts with the client) is refreshingly simple due to coroutines. The actual connection logic is something that you can write once and tuck away in a module.<a id="IDX-CHP-16-0092" class="indexterm"></a></p><p>The key to handling concurrent client connections is the <code class="literal">socket.select</code> function. As you saw in <a class="link" href="ch09.html" title="Chapter 9. Handling Events Naturally with Coroutines">Chapter 9</a>, a properly implemented dispatcher forms the basis for properly managing asynchronous events, which are events that originate outside of the application. The feature that you want is the ability to call a function that blocks until an event occurs. In this case, the event can be a connection request by a new client or the arrival of information from an already connected client. The <code class="literal">socket.select</code> fills this role by blocking until one or more of the sockets you indicate are ready for reading or writing. <code class="literal">socket.select(receive array, send array, optional timeout in seconds)</code> returns three values: a table of sockets from the receive array that have data waiting, a table of sockets from the send array that are ready to be written to, and an error message. On success the error message is <code class="literal">nil</code>.<a id="IDX-CHP-16-0093" class="indexterm"></a><a id="IDX-CHP-16-0094" class="indexterm"></a><a id="IDX-CHP-16-0095" class="indexterm"></a><a id="IDX-CHP-16-0096" class="indexterm"></a><a id="IDX-CHP-16-0097" class="indexterm"></a><a id="IDX-CHP-16-0098" class="indexterm"></a><a id="IDX-CHP-16-0099" class="indexterm"></a><a id="IDX-CHP-16-0100" class="indexterm"></a><a id="IDX-CHP-16-0101" class="indexterm"></a><a id="IDX-CHP-16-0102" class="indexterm"></a></p><p>Follow these steps to use <code class="literal">socket.select</code>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Place the client and server sockets you expect input from into an array (a table indexed with contiguous integers beginning with 1), and pass this table as the first argument.</p></li><li class="listitem"><p>Place all the sockets that you are waiting to write to into another array. If either of these tables is empty, you can use <code class="literal">nil</code> instead. If you need the function to return after some designated number of seconds in the event that none of the specified sockets become ready for reading or writing, indicate a timeout value as the third argument.</p><p>The returned tables are structured as follows:</p><pre class="programlisting">{
   [1] = tcp{client}: 0065E214,
   [2] = tcp{client}: 0065E394,
   [tcp{client}: 0065E214] = 1,
   [tcp{client}: 0065E394] = 2
}</pre><p>You can see that each socket is represented two ways in the table: once as an array element and once as an associative key. The script presented here uses an <code class="literal">ipairs</code> loop to handle only the arrayed sockets.</p></li></ol></div><p>All incoming connection requests are handled by the server socket. Recall that a server socket calls <code class="literal">accept</code> to establish a connection and create a new client socket, but does not exchange data with the remote socket. The server socket is kept in the first position of an array that holds all active sockets. Subsequent positions hold client sockets. This array is in the form required by <code class="literal">socket.select</code> so it is passed as the function's first argument (the receive array) to wait until inbound data or a connection request arrives.</p><p>This example is line oriented: the server expects to receive a single line from the client and in return sends back a line. Because of this, there are no special writing considerations and the second argument to <code class="literal">socket.select</code> (the send array) is passed as <code class="literal">nil</code>.</p></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="setting_timeout_values_for_the_server_so"></a>Setting Timeout Values for the Server Socket</h2></div></div></div><p>One quirk in the Windows implementation of sockets is worked around in the multiple-connection example. Generally, a server socket can be included along with client sockets in the receive array, and an inbound connection request for the server socket is treated like inbound data for a client socket. However, Windows is known to occasionally report that a server socket is ready to accept a new connection when in fact it is not. To deal with this, you can do the following:<a id="IDX-CHP-16-0103" class="indexterm"></a></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Set a timeout value for the server socket:<a id="IDX-CHP-16-0104" class="indexterm"></a><a id="IDX-CHP-16-0105" class="indexterm"></a><a id="IDX-CHP-16-0106" class="indexterm"></a><a id="IDX-CHP-16-0107" class="indexterm"></a><a id="IDX-CHP-16-0108" class="indexterm"></a><a id="IDX-CHP-16-0109" class="indexterm"></a><a id="IDX-CHP-16-0110" class="indexterm"></a><a id="IDX-CHP-16-0111" class="indexterm"></a><a id="IDX-CHP-16-0112" class="indexterm"></a><a id="IDX-CHP-16-0113" class="indexterm"></a></p><pre class="programlisting">SckHnd:settimeout(250)</pre><p>This forces a call to <code class="literal">accept</code> to return in a quarter second if in fact no connection requests are pending.</p></li><li class="listitem"><p>Check the return values of this function to determine whether a viable connection was made. In this example, a timeout condition terminates the main loop. In a real application, you would ignore it.</p></li><li class="listitem"><p>For each new client connection, create a coroutine and associate it with the client socket. When a client connection is terminated, this coroutine is set to <code class="literal">nil</code> and the client socket is removed from the read array.</p></li></ol></div><p>The actual dialog between client and server is quite simple. Essentially it is a loop that begins with a yield. This transfers control back to the main script loop where it spends most of its time blocking in a call to <code class="literal">socket.select</code>. When this mechanism indicates that data has arrived from a client, the associated coroutine is resumed. The client data is read and examined. If it constitutes a termination request (either to end the connection or shut down the server) the dialog loop is terminated and the coroutine returns rather than yields. Otherwise, it processes the data and responds with its own data. In this example, the data returned is simply a string comprising the unique characters received from the client so far. This illustrates the ease with which the dialog state can be retained between transmissions.<a id="IDX-CHP-16-0114" class="indexterm"></a></p></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="the_application_protocols"></a>The Application Protocols</h1></div></div></div><p>LuaSocket's C layer interfaces with platform-specific sockets libraries to handle networking details at the TCP and UDP level. LuaSocket also provides a rich interface to the Internet's application protocols such as SMTP, FTP, HTTP and a number of modules to support them.<a id="IDX-CHP-16-0115" class="indexterm"></a></p><p>The application protocols in wide use throughout the Internet are presented in <span class="emphasis"><em>RFC</em></span> (Request for Comments) documents that are informative and generally easy to read. If you need Lua to interact with an Internet server, such as a server that uses NNTP (Network News Transfer Protocol), the relevant RFCs will help you implement a working client. Visit <code class="systemitem">www.rfc-editor.org</code> for indexes to all RFCs.<a id="IDX-CHP-16-0116" class="indexterm"></a></p><p>Many application protocols involve transforming data prior to sending it or after receiving it. The following section describes an elegant solution that the LuaSocket libraries bring to this task.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="filtering_the_flow_of_data"></a>Filtering the Flow of Data</h2></div></div></div><p>As data is moved from one point to another, it often has to be manipulated to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Conform with protocol constraints</p></li><li class="listitem"><p>Enhance transmission efficiency</p></li><li class="listitem"><p>Accommodate application formats and platform-dependent issues such as end-of-line conventions</p></li></ul></div><p>LuaSocket includes a framework for flexibly massaging inbound and outbound data. It treats data as a fluid that is pumped from a <span class="emphasis"><em>source</em></span> through a series of <span class="emphasis"><em>filters</em></span> to a <span class="emphasis"><em>sink</em></span>. While Diego Nehab created this framework in conjunction with the development of LuaSocket version 2, it is quite general and has been made into a standalone module named <code class="literal">ltn12</code>. An article Diego wrote detailing the principles of this framework (available on the Lua wiki at <code class="systemitem">http://lua-users.org/wiki/FiltersSourcesAndSinks</code>) was evidently slated to become the 12th in a series of <span class="emphasis"><em>Lua technical notes</em></span>. The first eleven of these articles are maintained on the main Lua website; newer contributions by members of the Lua community are placed on the lua-users wiki.<a id="IDX-CHP-16-0117" class="indexterm"></a><a id="IDX-CHP-16-0118" class="indexterm"></a><a id="IDX-CHP-16-0119" class="indexterm"></a></p><p>The sources, filters and sinks framework implemented in <code class="literal">ltn12</code> is based on the modification of data chunks rather than transacted data as a whole. This reduces the memory requirements of applications, especially server applications that handle concurrent connections involving large transactions. The basic parts of an <code class="literal">ltn12</code> circuit are shown in the following table.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"><col class="col2"></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Component</p></th><th style="text-align: left" valign="bottom"><p>Explanation</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>Source</p></td><td style="text-align: left" valign="top"><p>Where data chunks originate. You can supply your own function to do this, or use one of the sources included in the <code class="literal">ltn12</code> module. Of these, <code class="literal">ltn12.source.file</code> is convenient if your data is stored in a file or originates from the standard input stream.</p></td></tr><tr><td style="text-align: left" valign="top"><p>Filter</p></td><td style="text-align: left" valign="top"><p>At its simplest, a filter receives a string of bytes and returns a transformed string of bytes. You can use the <code class="literal">ltn12.filter.chain</code> function to sequentially combine multiple filters into a single chain. Filters may need to retain some context from chunk to chunk, in which case, a factory is generally used to create a filter as a closure.</p></td></tr><tr><td style="text-align: left" valign="top"><p>Sink</p></td><td style="text-align: left" valign="top"><p>The destination of all data chunks passing through the circuit. As with the source, you can associate a file, (including the standard output stream) with this component.</p></td></tr><tr><td style="text-align: left" valign="top"><p>Pump</p></td><td style="text-align: left" valign="top"><p>A pump function pushes data from a source to a sink. Two pumps are included in the module: <code class="literal">ltn12.pump.all</code> blocks until all data has been pumped through the system, and <code class="literal">ltn12.pump.step</code> blocks until one chunk has been pumped.</p></td></tr></tbody></table></div><p>Many of the application protocols in use today were created when only ASCII text was being moved around on networks. To support the transmission of text that includes characters outside of the ASCII range as well as binary data such as images and compressed data, various encoding techniques have evolved to work within the original protocol limitations. MIME (Multipurpose Internet Mail Extensions) standardizes the ways non-ASCII data can be exchanged. Two common encoding methods are Quoted-Printable and Base64, which do the following:<a id="IDX-CHP-16-0120" class="indexterm"></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The Quoted-Printable encoding expands non-ASCII characters to a three-character sequence: an equal sign followed by a two-character hexadecimal representation of the out-of-range character. The equal sign itself is given the same treatment, as are tabs and spaces at the end of a line. For text messages that include occasional non-ASCII characters, this method of encoding has the advantage of being readable and compact.<a id="IDX-CHP-16-0121" class="indexterm"></a></p></li><li class="listitem"><p>Base64 encoding is suited for transmitted data that includes many non-ASCII characters. In this method of encoding, all data is expanded so that each sequence of three bytes becomes four ASCII characters. In a sense, data is transformed from a 256 character alphabet to a 64 character alphabet.<a id="IDX-CHP-16-0122" class="indexterm"></a></p></li></ul></div><p>The <code class="literal">mime</code> module included in LuaSocket implements encodings from the MIME standard. It requires the <code class="literal">ltn12</code> module but is independent of the socket routines.<a id="IDX-CHP-16-0123" class="indexterm"></a></p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_text_hydraulics"></a>Try It Out: Text Hydraulics</h3></div></div></div><p>The <code class="literal">ltn12</code> module gives you everything you need to construct a source-to-sink data transformation routine. The <code class="literal">mime</code> module provides filters for encodings, text wrapping and end-of-line manipulation. Here you'll use both modules to demonstrate the ways to combine a source, filters, sink, and pump to encode and decode a string.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a Lua file with the following contents:</p><pre class="programlisting">local mime = require("mime")
local ltn12 = require("ltn12")

-- This function receives one string and one or more high level filters. On
-- success it returns the filtered string, otherwise nil followed by an error
-- message.

local function Transform(Str, ...)
  -- Source is specified string
  local Src = ltn12.source.string(Str)
  -- Chain all specified filters into one
  local Filter = ltn12.filter.chain(...)
  -- Send all data chunks to table
  local Snk, Tbl = ltn12.sink.table()
  -- Filter chunks before delivering to sink
  Snk = ltn12.sink.chain(Filter, Snk)
  -- Open the valve
  local Code, ErrStr = ltn12.pump.all(Src, Snk)
  return Code and table.concat(Tbl) or nil, ErrStr
end

local function Test(Str, EncodingStr)
  local CodeStr, StatStr
  CodeStr = Transform(Str, mime.encode(EncodingStr)) or ""
  StatStr = Str == Transform(CodeStr, mime.decode(EncodingStr)) and
    "OK" or "Not OK"
  io.write(string.format("%-18s [%s] %s\n", EncodingStr, CodeStr, StatStr))
end

local Str = "Gabriel Garc\237a M\225rquez"
io.write(Str, "\n")
Test(Str, "base64")
Test(Str, "quoted-printable")</pre></li><li class="listitem"><p>Run the script as follows:</p><pre class="programlisting"><strong class="userinput"><code>lua mime_01.lua</code></strong>
Gabriel García Márquez
base64           [R2FicmllbCBHYXJj7WEgTeFycXVleg==] OK
quoted-printable [Gabriel Garc=EDa M=E1rquez] OK</pre></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-055"></a>How It Works</h3></div></div></div><p>The <code class="literal">Transform</code> function is a general-purpose routine for applying one or more filters to a string. Receiving and returning whole strings in some respects defeats the purpose of a filtered circuit, but even if the input and output strings are enormous, the actual filtering operations take place on smaller portions of data. The routine illustrates how you can place filters between a source and a sink. In this case, the amalgamated filter is chained to the sink (in <code class="literal">ltn12.sink.chain</code>), but you could just as easily have chained to the source instead (by using <code class="literal">ltn12.source.chain</code>).<a id="IDX-CHP-16-0124" class="indexterm"></a><a id="IDX-CHP-16-0125" class="indexterm"></a><a id="IDX-CHP-16-0126" class="indexterm"></a><a id="IDX-CHP-16-0127" class="indexterm"></a><a id="IDX-CHP-16-0128" class="indexterm"></a><a id="IDX-CHP-16-0129" class="indexterm"></a><a id="IDX-CHP-16-0130" class="indexterm"></a><a id="IDX-CHP-16-0131" class="indexterm"></a><a id="IDX-CHP-16-0132" class="indexterm"></a><a id="IDX-CHP-16-0133" class="indexterm"></a><a id="IDX-CHP-16-0134" class="indexterm"></a><a id="IDX-CHP-16-0135" class="indexterm"></a><a id="IDX-CHP-16-0136" class="indexterm"></a><a id="IDX-CHP-16-0137" class="indexterm"></a></p><p>The <code class="literal">Test</code> function receives a string to transform and a MIME encoding identifier (either <code class="literal">base64</code> or <code class="literal">quoted-printable</code>). It uses this identifier to obtain an encoding filter with which it calls <code class="literal">Transform</code> to generate an encoded string. To test this, it compares the original string with a decoded version to make sure the process is functioning properly.</p><p>Examine the encoded versions of the text. For this example, the Quoted-Printable encoding makes the most sense, as most of the data is already in ASCII characters. The two equal signs at the end of the Base64-encoded string are padding added to make the length of the encoded string a multiple of four.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="accessing_web_pages"></a>Accessing Web Pages</h2></div></div></div><p>The <code class="literal">http</code> module of LuaSocket lets you retrieve a web resource with one function call. <code class="literal">http.request(<span class="emphasis"><em>URL string, optional post body</em></span>)</code> requests a resource from a web server. If there is no second argument, the request is made using the <code class="literal">GET</code> method; otherwise the second argument is sent to the server as post data and the <code class="literal">POST</code> method is used. On success, the function returns four response values from the server. In order, these are the web resource body, the status code, the headers and the status line. On error, the function returns <code class="literal">nil</code> followed by an error message. If the function succeeds, remember to also check the status code.</p><div class="blockquote"><blockquote class="blockquote"><p>When data is posted to the server, it is assumed to be urlencoded. See the section on CGI programming in <a class="link" href="ch15.html" title="Chapter 15. Programming for the Web">Chapter 15</a> for more details.</p></blockquote></div><p>The following global variables are consulted by <code class="literal">http.request</code> and can be used to modify its behavior:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">PORT</code> specifies the port used to contact the web server if a value isn't included in the URL.</p></li><li class="listitem"><p><code class="literal">PROXY</code> is used as a proxy server. If it is used, it should be in the form <code class="systemitem">http://proxy.example.com:8080</code>.</p></li><li class="listitem"><p><code class="literal">TIMEOUT</code> specifies the timeout value in seconds of the request.</p></li><li class="listitem"><p><code class="literal">USERAGENT</code> specifies the <code class="literal">user-agent</code> header that will be sent to the server.</p></li></ul></div><p>An alternate version of the same function gives you finer-grained control over the HTTP request. Instead of submitting a URL to the function, you pass an associative table instead. <code class="literal">http.request(request attribute table)</code> requests a resource from a web server. Its return values are like the URL string version of this function, except that on success, the first value returned is 1 rather than the resource body.</p><p>The request attribute table can have values for the following keys (only the <code class="literal">url</code> field is mandatory):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">url</code> specifies the URL of the requested resource.</p></li><li class="listitem"><p><code class="literal">sink</code> indicates where you want the retrieved resource to be stored. Common values are <code class="literal">ltn12.sink.file</code> to save the resource as a file, and <code class="literal">ltn12.sink.table</code> to store the retrieved chunks in a table where they can be easily converted to a string using <code class="literal">table.concat</code>.<a id="IDX-CHP-16-0138" class="indexterm"></a><a id="IDX-CHP-16-0139" class="indexterm"></a><a id="IDX-CHP-16-0140" class="indexterm"></a><a id="IDX-CHP-16-0141" class="indexterm"></a><a id="IDX-CHP-16-0142" class="indexterm"></a><a id="IDX-CHP-16-0143" class="indexterm"></a><a id="IDX-CHP-16-0144" class="indexterm"></a></p></li><li class="listitem"><p><code class="literal">method</code> should be "<code class="literal">GET"</code>, "<code class="literal">HEAD"</code>, or "<code class="literal">POST"</code>.</p></li><li class="listitem"><p><code class="literal">headers</code> is an associative table that includes headers that will be sent to the server in addition to the standard headers. For example:</p><pre class="programlisting">headers = {["content-length"] = 1094}</pre></li><li class="listitem"><p>You use <code class="literal">source</code> if you are posting data to the server. When using this, you should specify <code class="literal">content-length</code> in the <code class="literal">headers</code> table. For example:</p><pre class="programlisting">source = ltn12.source.string(PostStr)
headers = {["content-length"] = string.len(PostStr)}</pre></li><li class="listitem"><p><code class="literal">step</code> enables you to specify a step pump other than the default <code class="literal">ltn12.pump.step</code>.</p></li><li class="listitem"><p><code class="literal">proxy</code> allows you to request a resource through a proxy server. You use this like the <code class="literal">PROXY</code> global variable.</p></li><li class="listitem"><p>You can set <code class="literal">redirect</code> to false to prevent server redirection.</p></li><li class="listitem"><p><code class="literal">create</code> specifies an alternate function to create the client socket.</p></li></ul></div><p>Additionally, you can include any or all of the keys <code class="literal">user, password, host, port</code>, and <code class="literal">path</code> in the table with appropriate values to override the fields embedded in <code class="literal">url</code>.</p><p>When <code class="literal">http.request</code> is called with a table, it saves the retrieved resource to the specified <code class="literal">sink</code> rather than returning it.</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_grabbing_a_file"></a>Try It Out: Grabbing a File</h3></div></div></div><p>You can conveniently retrieve binary files with <code class="literal">http.request</code>. Here the table form of the function is used with a file sink.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>With your text editor, create a new Lua file with the following contents:</p><pre class="programlisting">local http = require("socket.http")
require("show")

local ResFileStr = "lascii85.tar.gz"
local PathStr = "http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/5.0/"
local ResHnd, ErrStr = io.open(ResFileStr, "wb")
if ResHnd then
  local Req = {
     url = PathStr .. ResFileStr,
     sink = ltn12.sink.file(ResHnd),
     -- proxy = "http://proxy.example.com:8888"
   }
   local Response = {http.request(Req)}
  ObjectShow(Response, "Response")
else
  io.write("Error opening ", ResFileStr, " for writing\n")
end</pre></li><li class="listitem"><p>Save this file as <code class="literal">http_01.lua</code>.<a id="IDX-CHP-16-0145" class="indexterm"></a><a id="IDX-CHP-16-0146" class="indexterm"></a><a id="IDX-CHP-16-0147" class="indexterm"></a><a id="IDX-CHP-16-0148" class="indexterm"></a><a id="IDX-CHP-16-0149" class="indexterm"></a><a id="IDX-CHP-16-0150" class="indexterm"></a><a id="IDX-CHP-16-0151" class="indexterm"></a><a id="IDX-CHP-16-0152" class="indexterm"></a></p></li><li class="listitem"><p>Run the script as follows:</p><pre class="programlisting"><strong class="userinput"><code>lua http_01.lua</code></strong>
["Response"] table: 0041C6B0 (n = 4)
    [1] 1
    [2] 200
    [3] table: 00429F28 (n = 0)
      ["accept-ranges"] "bytes"
      ["content-encoding"] "x-gzip"
      ["content-length"] "2641"
      ["content-type"] "application/x-gzip"
      ["date"] "Thu, 07 Sep 19:49:29 GMT"
      ["etag"] ""3f60e-a51-3fbb6735""
      ["last-modified"] "Wed, 19 Nov 2003 12:51:01 GMT"
      ["server"] "Apache"
      ["via"] "1.1 tinyproxy (tinyproxy/1.7.0)"
    [4] "HTTP/1.1 200 OK"</pre><p>Some headers may be different when you run the script. When the request completes, the <code class="literal">lascii85.tar.gz</code> file is saved in the current directory.</p></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-056"></a>How It Works</h3></div></div></div><p>The table form of <code class="literal">http.request</code> is used here for extra control over the file retrieval request. To save the downloaded file directly to disk, the <code class="literal">ltn12.sink.file</code> factory is called with the handle to a file opened for writing. The function this factory returns is called for each chunk of data received. When there is no more data to process, it closes the file handle.</p><p>If there are no special request attributes, you can retrieve the file directly into a string with the following call:</p><pre class="programlisting">UrlStr = "http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/5.0/lascii85.tar.gz"
BodyStr, Code, Hdr, StatStr = http.request(UrlStr)</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="sending_and_receiving_e-mail_messages"></a>Sending and Receiving E-mail Messages</h2></div></div></div><p>LuaSocket provides high-level support for sending messages with SMTP (Simple Mail Transfer Protocol), which is the standard means of sending Internet e-mail. LuaSocket currently doesn't support email retrieval directly, but its lower-level TCP socket routines let you do this if you follow the protocol—usually POP (Post Office Protocol) or IMAP (Internet Message Access Protocol)—that your mail server uses.<a id="IDX-CHP-16-0153" class="indexterm"></a><a id="IDX-CHP-16-0154" class="indexterm"></a><a id="IDX-CHP-16-0155" class="indexterm"></a></p><div class="sidebar"><a id="try_it_out_colon_sending_e-mail"></a><div class="titlepage"><div><div><p class="title"><strong>Try It Out: Sending E-mail</strong></p></div></div></div><p>The <code class="literal">smtp</code> module comprises two functions: <code class="literal">smtp.message</code> and <code class="literal">smtp.send</code>. The first function prepares a message for sending by the second function. Both are used in the following example. This exercise works only with SMTP servers that accept plain-text password authentication.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a new file with the following Lua script:</p><pre class="programlisting">local smtp = require("socket.smtp")

local Recipient = {"&lt;recipient_1@example.net&gt;", "&lt;recipient_2@example.net&gt;"}

-- Run the specified configuration file in an empty environment. On success,
-- returns a table that contains all global variables that are assigned in
-- configuration file, otherwise (nil, error string).

local function Configure(CfgFileStr)
  local Gl, Cfg = getfenv(0), {}
  setfenv(0, Cfg)
  local Code, ErrStr = pcall(dofile, CfgFileStr)
  setfenv(0, Gl)
  return Code and Cfg or nil, ErrStr
end

local BodyStr = [[
Now the hungry lion roars,
  And the wolf behowls the moon;
Whilst the heavy ploughman snores,
  All with weary task foredone.
]]

local Msg = {
  headers = {
    to = "Oberon &lt;oberon@example.com&gt; Titania &lt;titania@example.com&gt;",
    cc = "William Shakespeare &lt;bard@globe.example.org&gt;",
    subject = "Moonlight",
    from = "Puck &lt;puck@example.com&gt;",
  },
  body = BodyStr
}

local Packet = {}
local Code
local CfgFileStr = "smtp.cfg"
local Cfg, ErrStr = Configure(CfgFileStr)
if Cfg then
  if type(Cfg.ServerStr) == "string" and type(Cfg.ServerPort) == "number" and
    type(Cfg.UserStr) == "string" and type(Cfg.PassStr) == "string" then
    io.write("Connecting to ", Cfg.ServerStr, "\n")
    Packet.from = "&lt;puck@example.com&gt;"
    Packet.rcpt = Recipient
    Packet.source = smtp.message(Msg)
    Packet.server = Cfg.ServerStr
    Packet.port = Cfg.ServerPort
    Packet.password = Cfg.PassStr
    Packet.user = Cfg.UserStr
    Code, ErrStr = smtp.send(Packet)
    if Code then
      io.write("Successfully sent messages")
    end</pre><pre class="programlisting">else
    ErrStr = "Improper configuration: " .. CfgFileStr
  end
end
if ErrStr then
  io.write(ErrStr, "\n")
end</pre></li><li class="listitem"><p>Modify the contents of the <code class="literal">Recipient</code> table to include one or more of your e-mail addresses.<a id="IDX-CHP-16-0156" class="indexterm"></a></p></li><li class="listitem"><p>Save this file as <code class="literal">smtp_01.lua</code>.</p></li><li class="listitem"><p>Create a configuration file with your editor and add the following fields, using appropriate values for your SMTP account:</p><pre class="programlisting">ServerStr = "mail.example.com"
ServerPort = 25
UserStr = "user"
PassStr = "password"</pre></li><li class="listitem"><p>Save this file as <code class="literal">smtp.cfg</code></p></li><li class="listitem"><p>Send the message as follows:</p><pre class="programlisting"><strong class="userinput"><code>lua smtp_01.lua</code></strong>
Connecting to mail.example.com
Successfully sent messages</pre></li><li class="listitem"><p>Use your regular e-mail retrieval software to verify that the message was sent or, if you have POP access to your e-mail account, you can retrieve it programmatically in the next exercise.</p></li></ol></div><p><span class="strong"><strong>How It Works</strong></span></p><p>The e-mail sending process begins by obtaining account particulars (such as the server name, user name, and password) as follows:</p><pre class="programlisting">Cfg, ErrStr = Configure(CfgFileStr)</pre><p>It's a good policy to keep this information out of general-purpose scripts. The technique used in the <code class="literal">Configure</code> function is to execute the configuration file as a Lua script that does not have access to library functions. Environment manipulation places the global variables it creates into a table that is returned by <code class="literal">Configure</code>.</p><p>After the presence of the fields expected in the configuration table have been verified, a table is prepared that will be used by <code class="literal">smtp.send</code>. This includes fields such as <code class="literal">from, rcpt, source, server, port, password</code>, and <code class="literal">user</code>.</p><p>The <code class="literal">rcpt</code> table specifies the only addresses to which the message is sent. As shown in this example, the <code class="literal">to</code> and <code class="literal">cc</code> fields of the message <code class="literal">headers</code> table are completely incidental to this process and are included for the purpose of display by the email client. Don't make the mistake of including a <code class="literal">bcc</code> field. To send a blind copy, simply include the recipient in the <code class="literal">rcpt</code> table and do not include it in either the <code class="literal">to</code> or <code class="literal">cc</code> header fields. This is done in the example.</p><p>The <code class="literal">source</code> field is a simple <code class="literal">ltn12</code> source. Here, the <code class="literal">smtp.message</code> factory is used to condition the specified message and generate a suitable source.<a id="IDX-CHP-16-0157" class="indexterm"></a><a id="IDX-CHP-16-0158" class="indexterm"></a><a id="IDX-CHP-16-0159" class="indexterm"></a><a id="IDX-CHP-16-0160" class="indexterm"></a></p></div><p>Now that you've sent a message, you can retrieve it programmatically if you have POP access to your e-mail account.</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_getting_e-mail"></a>Try It Out: Getting E-mail</h3></div></div></div><p>The POP specification lets you list, retrieve, and delete e-mail that has arrived at your mail server. To do this with LuaSocket, you create a client socket and connect it with a POP server on which you have an account. The following example assumes that your POP server does not require an SSL (Secure Sockets Layer) or the APOP (Authenticated Post Office Protocol) command.<a id="IDX-CHP-16-0161" class="indexterm"></a></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a new Lua file with the following contents:</p><pre class="programlisting">local socket = require("socket")

-- Run the specified configuration file in an empty environment. On success,
-- returns a table that contains all global variables that are assigned in
-- configuration file, otherwise (nil, error string).

local function Configure(CfgFileStr)
  local Gl, Cfg = getfenv(0), {}
  setfenv(0, Cfg)
  local Code, ErrStr = pcall(dofile, CfgFileStr)
  setfenv(0, Gl)
  return Code and Cfg or nil, ErrStr
end

-- Obtain POP server response. On success, return (string), otherwise (nil,
-- error string).

local function LclGet(PopHnd)
  local Str, ErrStr = PopHnd:receive()
  if Str then
    -- All POP responses begin with "+OK " or "-ERR "
    if string.sub(Str, 1, 1) == "+" then
      Str = string.sub(Str, 5)
    else
      ErrStr = string.sub(Str, 6)
      Str = nil
    end
  end
  -- return Ok, string.sub(Str, Ok and 5 or 6)
  return Str, ErrStr
end

-- Send a command to the POP server and obtain its response. Returns (string)
-- on success and (nil, error string) otherwise. The Multi argument is true if
-- the caller expects a multiline response from the POP server. If Multi is
-- true and command succeeds, returns (string, table) where table contains
-- returned data lines, otherwise (nil, error string).</pre><pre class="programlisting">local function LclTransact(PopHnd, SendStr, Multi)
    local Ok, Str, ErrStr, Tbl
    Ok, ErrStr = PopHnd:send(SendStr .. "\r\n")
    if Ok then
      Str, ErrStr = LclGet(PopHnd)
      if Str and Multi then
        Tbl = {}
        local DataStr
        while Multi and not ErrStr do
          DataStr, ErrStr = PopHnd:receive()
          if DataStr then
            if string.sub(DataStr, 1, 1) == "." then
              DataStr = string.sub(DataStr, 2)
              if DataStr == "" then
                Multi = false
              end
            end
            if Multi then
              Tbl[#Tbl + 1] = DataStr
          end
        end
      end
      if ErrStr then
        Str = nil
      else
        ErrStr = Tbl -- 2nd return value for Multi
      end
    end
  end
  return Str, ErrStr
end

-- Close the connection to the POP server. It is assumed that the server is in
-- a state to receive the "quit" command.

local function LclClose(PopHnd)
  LclTransact(PopHnd, "quit")
  PopHnd:close()
end

-- Connect to the POP server and authenticate user. If this function succeeds,
-- (client socket) is returned, otherwise (nil, error string) is returned.

local function LclOpen(Cfg)
  local Ok, Str, RetHnd, PopHnd, ErrStr
  PopHnd, ErrStr = socket.connect(Cfg.ServerStr, Cfg.ServerPort)
  if PopHnd then
    Str, ErrStr = LclGet(PopHnd)
    if Str then
      if LclTransact(PopHnd, "user " .. Cfg.UserStr) then
        if LclTransact(PopHnd, "pass " .. Cfg.PassStr) then
          RetHnd = PopHnd
        end
      end</pre><pre class="programlisting">if not RetHnd then
          ErrStr = "Invalid username or password submitted"
        end
      end
      if not RetHnd then
      LclClose(PopHnd)
    end
  end
  return RetHnd, ErrStr
end

-- This function requests header information for each stored email message. On
-- success, it returns (header table), otherwise it returns (nil, error
-- string). Only the first line of each multiline value is saved.

local function LclHeaders(PopHnd)
  local Ok, Str, ErrStr, RetTbl, ListTbl

  Str, ListTbl = LclTransact(PopHnd, "list", true)
  if Str then
    RetTbl = {}
    for J, Str in ipairs(ListTbl) do
      local HdrTbl, MsgTbl = {}
      HdrTbl.size = tonumber(string.match(Str, "(%d+)$") or 0)
      Str, MsgTbl = LclTransact(PopHnd, "top " .. J .. " 1", true)
      if Str then
        for J, Str in ipairs(MsgTbl) do
          local KeyStr, ValStr = string.match(Str, "^([%a%-]+)%:%s(.)")
          if KeyStr then
            HdrTbl[string.lower(KeyStr)] = ValStr
          end
        end
        RetTbl[#RetTbl + 1] = HdrTbl
      else
        ErrStr = ErrStr and (ErrStr .. ", " .. MsgTbl) or MsgTbl
      end
    end
    if ErrStr then
      RetTbl = nil
    end
  else
    ErrStr = ListTbl
  end
  return RetTbl, ErrStr
end

local Cfg, PopHnd, ErrStr, Ok, HdrTbl, CfgFileStr

CfgFileStr = "cfg"
Cfg, ErrStr = Configure(CfgFileStr)
if Cfg then
  if type(Cfg.ServerStr) == "string" and type(Cfg.ServerPort) == "number" and
    type(Cfg.UserStr) == "string" and type(Cfg.PassStr) == "string" then</pre><pre class="programlisting">io.write("Connecting to ", Cfg.ServerStr, "\n")
  PopHnd, ErrStr = LclOpen(Cfg)
  if PopHnd then
    io.write("Retrieving headers\n")
    HdrTbl, ErrStr = LclHeaders(PopHnd)
    if HdrTbl then
      for J, Rec in ipairs(HdrTbl) do
        io.write("--- Msg ", J, " ---\n",
          " Subject: ", Rec.subject or "---", "\n",
          " From: ", Rec.from or "---", "\n",
          " Date: ", Rec.date or "---", "\n",
          " Size: ", Rec.size or "---", "\n")
        end
      end
      io.write("Disconnecting from ", Cfg.ServerStr, "\n")
      LclClose(PopHnd)
    end
  else
    io.write("Improper configuration: ", CfgFileStr, "\n")
  end
end
if ErrStr then
  io.write(ErrStr, "\n")
end</pre></li><li class="listitem"><p>Save this file as <code class="literal">pop_01.lua</code>.</p></li><li class="listitem"><p>Using your editor, create a new configuration file following this template:</p><pre class="programlisting">PassStr = "pass"
ServerPort = 110
ServerStr = "mail.example.com"
UserStr = "user"</pre></li><li class="listitem"><p>Save this file as <code class="literal">cfg</code>.</p></li><li class="listitem"><p>Substitute values that apply to your POP account.</p></li><li class="listitem"><p>Run the script as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>The particular headers that are displayed may vary according to your POP server.</p></blockquote></div><pre class="programlisting"><strong class="userinput"><code>lua pop_01.lua</code></strong>
Connecting to localhost
Retrieving headers
--- Msg 1 ---
   Subject: Moonlight
   To:      Oberon &lt;oberon@example.com&gt; Titania &lt;titania@example.com&gt;
   Cc:      William Shakespeare &lt;bard@globe.example.org&gt;
   From:    Puck &lt;puck@example.com&gt;
   Date:    Thu, 07 Sep 19:52:19 GMT
   Size:    970
Disconnecting from localhost</pre></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-058"></a>How It Works</h3></div></div></div><p>Like the previous example, the e-mail header retrieval process begins by obtaining account particulars (such as server name, user name, and password) as follows:<a id="IDX-CHP-16-0162" class="indexterm"></a><a id="IDX-CHP-16-0163" class="indexterm"></a><a id="IDX-CHP-16-0164" class="indexterm"></a><a id="IDX-CHP-16-0165" class="indexterm"></a><a id="IDX-CHP-16-0166" class="indexterm"></a><a id="IDX-CHP-16-0167" class="indexterm"></a><a id="IDX-CHP-16-0168" class="indexterm"></a></p><pre class="programlisting">Cfg, ErrStr = Configure(CfgFileStr)</pre><p>After the presence of the fields expected in the configuration table has been verified, a connection with the POP server is established. The authentication process shown here involves sending the following lines (where <code class="literal">username</code> and <code class="literal">secret</code> are replaced with values from the configuration file):</p><pre class="programlisting">user username
pass secret</pre><p>If the POP server is okay with each of these, a list of the waiting e-mail sizes is requested by sending the <code class="literal">list</code> command. If this command succeeds, the response will contain multiple lines. In this case, lines are read from the server until a line made up of only a single period is encountered. To address the possibility of such a line being transmitted in an email message, servers conventionally prepend a period to every line beginning with a period. Clients, including the one shown here, remove these initial periods. Based on the retrieved message list, the headers of each waiting message are requested using the <code class="literal">top</code> command. This is done so that a list of the message details can be presented to the user prior to downloading message bodies. Use the <code class="literal">RETR</code> command to retrieve the full body of the message. You can delete a message with the <code class="literal">DELE</code> command. Both of these commands are followed by a space and the one-based position of the message.</p><div class="blockquote"><blockquote class="blockquote"><p>For more information about retrieving message bodies and dealing with possible encoding issues, refer to documentation concerning MIME techniques.</p></blockquote></div></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="networking_with_lua_and_streams"></a>Networking with Lua and Streams</h1></div></div></div><p>In this chapter, you've surveyed some (but by no means all) of the uses of the LuaSocket library. Other viable means of communicating over the Internet exist in the form of programs like <code class="literal">inetd</code> and <code class="literal">ssh</code> that handle the networking details for you.</p><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="on_the_server_side_colon_inetd_and_frien"></a>On the Server Side: inetd and Friends</h2></div></div></div><p>Unix-type systems and the Cygwin system for Windows come with a <span class="emphasis"><em>super-server</em></span> application named <code class="literal">inetd, xinetd</code> or <code class="literal">launchd</code> that you can configure to listen on various ports. When a connection request arrives on one of these ports, it executes the program associated with the port, mapping the program's standard input, output and error streams to the new socket connection. In this way, your program can receive data from a remote client simply by reading its standard input stream, and send data back to the client by writing to its standard output stream. Many of the issues that arise when writing a full-fledged server application are taken care of by the super-server. These include managing execution privileges and restricting connections by address and frequency. Any program that can read from and write to its standard streams can be registered with a super-server, so what makes Lua special in this regard? In a nutshell, speed. Unlike a dedicated application server that runs continuously as a process, a server application registered with a super-server is executed whenever a new connection for it is made. Lua's small size and rapid loading make it a perfect choice for use in this arrangement.</p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_creating_a_stream-based"></a>Try It Out: Creating a Stream-Based Server</h3></div></div></div><p>If you work on a Unix-type platform, including Cygwin for Windows, you can arrange to have a Lua program act as a network server by registering it with your system's super-server. The example shown here assumes you have <code class="literal">xinetd</code> available.<a id="IDX-CHP-16-0169" class="indexterm"></a></p><div class="blockquote"><blockquote class="blockquote"><p>If you use a system with <code class="literal">inetd</code>, consult its man page for configuration details. In particular, you need to add an entry in <code class="literal">/etc/services</code> to give the listening port a service name. It is this service name rather than the port number itself that is put in the <code class="literal">inetd.conf</code> file.</p></blockquote></div><p>The super-server usually runs as root and executes server programs with minimal permissions to reduce the possibility of a security breach. In the following example, the user <code class="literal">nobody</code> (often associated with web servers) is used in this capacity. You may want or need to replace references to <code class="literal">nobody</code> in the following files with another suitable low-authority user. In general, you should restrict the writers of server scripts as much as practical. In this example, only <code class="literal">root</code> can write to the script.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>With your text editor, create a new Lua script with the following contents:</p><pre class="programlisting">-- Sample echo server for testing with inetd and cousin xinetd

local Str = "Lua echo server opening / " .. os.date("%T")
while Str and Str ~= "" and Str ~= "\r" do
  io.write(Str, "\r\n")
  io.flush()
  Str = io.read()
end
io.write("Lua echo server closing / ", os.date("%T"), "\r\n")</pre></li><li class="listitem"><p>Save this file as <code class="literal">echo.lua</code> in a suitable directory. (<code class="literal">/var/local/lua</code> is used here, but the choice is yours.)</p></li><li class="listitem"><p>As root, modify the permissions of <code class="literal">echo.lua</code> so that it is readable by <code class="literal">nobody</code> and writeable only by suitable users, like this:</p><pre class="programlisting">chown root:nobody echo.lua
chmod u=rw,g=r,o= echo.lua</pre></li><li class="listitem"><p>In the <code class="literal">/etc/xinetd.d</code> directory, create a new file named <code class="literal">lua-echo</code> with the following contents, changing the directory and user if necessary:</p><pre class="programlisting"># description: A sample Lua server

service lua-echo
{
   socket_type   = stream
   type          = UNLISTED
   protocol      = tcp
   user          = nobody
   wait          = no
   server        = /usr/local/bin/lua
   server_args   = /var/local/lua/echo.lua
   disable       = no
   port          = 23032</pre><pre class="programlisting">log_type  = FILE /var/local/lua/log
   log_on_success= PID HOST DURATION
   log_on_failure= HOST
}</pre></li><li class="listitem"><p>Restart the super-server. On some systems this is done with a command like this:<a id="IDX-CHP-16-0170" class="indexterm"></a><a id="IDX-CHP-16-0171" class="indexterm"></a><a id="IDX-CHP-16-0172" class="indexterm"></a></p><pre class="programlisting">service xinetd restart</pre><p>or this:</p><pre class="programlisting">/etc/rc.d/rc.inetd restart</pre><p>Consult the documentation for your particular super-server and platform.</p></li><li class="listitem"><p>Use <code class="literal">telnet</code> to connect with the server (<code class="literal">localhost</code> if you are accessing the echo server from the machine on which it will run or the name of the host if you are accessing the script remotely), and submit a blank line when you are ready to terminate the session, as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>You can also invoke concurrent connections.</p></blockquote></div><pre class="programlisting"><strong class="userinput"><code>telnet localhost 23032</code></strong>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Lua echo server opening / 09:40:56
<strong class="userinput"><code>abc</code></strong>
abc
<strong class="userinput"><code>xyz</code></strong>
xyz

Lua echo server closing / 09:41:08
Connection closed by foreign host.</pre></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-059"></a>How It Works</h3></div></div></div><p>When the super-server receives a TCP connection request on port 23032, it makes sure that the remote client is eligible to be connected. If so, it executes the following, with the <code class="literal">stdin, stdout</code>, and <code class="literal">stderr</code> channels hooked to the socket connection:</p><pre class="programlisting">/usr/local/bin/lua /var/local/lua/echo.lua</pre><p>The echo script begins by writing a welcome message with the time. It then waits for input from the client and, when it receives a non-empty line, writes it back. The loop is broken when an empty line arrives from the client. The script then writes a closing line with the time and terminates. This causes the Lua interpreter to terminate as well, a condition that prompts the super-server to close the network connection.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h2 class="title"><a id="on_the_client_side_colon_ssh_and_friends"></a>On the Client Side: ssh and Friends</h2></div></div></div><p>You can use the Lua <code class="literal">io.popen</code> function in conjunction with programs like <code class="literal">ssh</code> and <code class="literal">nc</code> (sometimes named <code class="literal">netcat</code>) to do for clients one-half of what super-servers provide for servers. Why one-half? Unfortunately, you can only open the stock <code class="literal">popen</code> in the C runtime library, on which Lua's <code class="literal">io.popen</code> is based, in either read mode or write mode but not both together. Here's the way it works: <code class="literal">io.popen</code> accepts the name of a program and program arguments as its first argument, and either "<code class="literal">w</code>"(or "<code class="literal">wb</code>") for writing or "<code class="literal">r</code>" (or "<code class="literal">rb</code>") for reading as its second argument. The "<code class="literal">b</code>" qualifiers indicate binary mode, an important consideration on the Windows platform. Here's an example use of <code class="literal">io.popen</code>:<a id="IDX-CHP-16-0173" class="indexterm"></a><a id="IDX-CHP-16-0174" class="indexterm"></a><a id="IDX-CHP-16-0175" class="indexterm"></a></p><pre class="programlisting">Hnd, ErrStr = io.popen("nc server.example.net 4583", "r")</pre><p>In this example, the netcat program (<code class="literal">nc</code>) will be invoked with the name of a server followed by the port on which the server is listening. Whatever this program writes to its standard output will be readable from the handle that <code class="literal">io.popen</code> returns. In this case, because the pipe is read-only, the launched program has to run without input.</p><div class="blockquote"><blockquote class="blockquote"><p>The <code class="literal">io.popen</code> function isn't supported on all platforms, including older versions of Windows.</p></blockquote></div><p>A versatile program named <code class="literal">plink</code> can be used with <code class="literal">io.popen</code> on Windows and Unix-type systems. This stream-based program is part of Simon Tatham's outstanding <code class="literal">PuTTY</code> suite of secure shell client applications. With it, you can connect to a server using the SSH or telnet protocol or use it to transfer data in "raw" mode. The SSH option makes it an excellent tool for accessing servers protected behind a firewall.<a id="IDX-CHP-16-0176" class="indexterm"></a></p><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="try_it_out_colon_using_a_stream-based_cl"></a>Try It Out: Using a Stream-Based Client</h3></div></div></div><p>In this example, you programmatically connect to the server from the previous example. You need to have either <code class="literal">netcat</code> (<code class="systemitem">www.vulnwatch.org/netcat</code>) or <code class="literal">plink</code> (<code class="systemitem">www.chiark.greenend.org.uk/~sgtatham/putty</code>) to run the client script.</p><p>Because of the one-way nature of <code class="literal">io.popen</code>, the <code class="literal">stdin</code> channel of <code class="literal">netcat</code> or <code class="literal">plink</code> will be taken from a file. The <code class="literal">stdout</code> channel is attached to the handle returned from <code class="literal">io.popen</code>.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a new Lua script with the following contents. If you run the client script from a machine other than the one the echo server is running on, change the value of <code class="literal">ServerStr</code> accordingly. Also, there are two variations of <code class="literal">CmdStr</code>—comment or delete the one that doesn't apply depending on which network tool you will use.</p><pre class="programlisting">local ServerStr = "localhost"
local Port = 23032
local CmdStr = "nc " .. ServerStr .. " " .. Port
-- local CmdStr = "plink -raw -P " .. Port .. " " .. ServerStr
local SendFileStr = "send.txt"

local Hnd = io.open(SendFileStr, "w")
if Hnd then
  Hnd:write("One\nTwo\nThree\n\n")
  Hnd:close()
  Hnd = io.popen(CmdStr .. " &lt; " .. SendFileStr)
  if Hnd then
    for Str in Hnd:lines() do
       io.write(Str, "\n")
    end
    Hnd:close()
 else
   io.write("Error executing '", CmdStr, "'\n")
   end
else
    io.write("Error opening ", SendFileStr, " for writing\n")
end</pre></li><li class="listitem"><p>Save this file as <code class="literal">client_03.lua</code>.<a id="IDX-CHP-16-0177" class="indexterm"></a></p></li><li class="listitem"><p>Run the script as follows:</p><pre class="programlisting"><strong class="userinput"><code>lua client_03.lua</code></strong>
Lua echo server opening / 10:39:31
One
Two
Three
Lua echo server closing / 10:39:31</pre></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h3 class="title"><a id="how_it_works-060"></a>How It Works</h3></div></div></div><p>The first order of business for the client script is to prepare some lines to transmit to the echo server. It writes these lines to a file, taking care to include a blank line at the end to signal to the echo server a request to end the session. Putting these lines in a file is necessary because after <code class="literal">io.popen</code> is called the script will have no way to send data to the echo server. The network utility, either <code class="literal">netcat</code> or <code class="literal">plink</code>, is invoked with a call to <code class="literal">io.popen</code>. The command uses the <code class="literal">&lt;</code> redirector to attach the utility's standard input stream to the file just prepared. After making a network connection with the server, the lines are sent by the utility to the server. Server output is obtained by the client through the <code class="literal">io.popen</code> handle. The following line is used to loop through the lines from the server until the session has been ended:</p><pre class="programlisting">for Str in Hnd:lines() do</pre><p>Note that the Lua scripts on both the client and the server have external requirements for network connectivity, but don't require any Lua modules.</p><p>The technique of using external tools for network communication can facilitate many tasks. For example, if you administer a number of network hosts, you can write short scripts that collect and print critical information about each script's host. You can register each script with the super-server on its host or, more securely, invoke it through SSH. You can then run a client script to collect this information with one invocation. You can use the <code class="literal">plink</code> tool whether you access the scripts in raw mode or through SSH.</p><p>When implementing client and server scripts for network operations, moving basic data back and forth in the form of text lines often suffices. This can be limiting, however, for exchanging richly structured data. Currently, the prevailing standard is to exchange data in XML format, and libraries for Lua are available on <code class="literal">luaforge.net</code> to read and write in this format. If the scripts exchanging data are both written in Lua, however, another solution may be the easiest. As a data description language, Lua has a very clean and compact notation. Translating the Booleans, numbers, and strings of nested tables to Lua code is a straightforward variation of the <code class="literal">ObjectDescribe</code> you worked with in <a class="link" href="ch07.html" title="Chapter 7. Using Modules">Chapter 7</a>. In addition to being easy to write, data that is received in this format couldn't be easier to read—you let Lua do it for you with the <code class="literal">loadstring</code> function. For example, suppose you have a Lua data structure that would be created with the following code:</p><pre class="programlisting">Classes = {
  Laura = {"BIO 102", "SPA 221", "MTH 150", "CHM 100", Id = 120},
  Jasmine = {"ENG 154", "LIT 204", "HUM 120", "PHY 100", Id = 390}
}</pre><p>You can use a routine with the following characteristics to convert this structure back to Lua code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Special characters like quotes and newlines in strings are properly escaped.</p></li><li class="listitem"><p>Boolean values are converted to "true" and "false."</p></li><li class="listitem"><p>Tables are handled by calling the routine recursively, with attention paid to already-defined tables to avoid unbound recursion.</p></li></ul></div><p>The string that is returned by such a routine might look something like this:</p><pre class="programlisting">['Classes']={Laura={[1]="BIO 102",[2]="SPA 221",[3]="MTH 150", <div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/U002.png" alt="How It Works" width="12" height="12"></div>
 [4]="CHM 100",['Id']=120},Jasmine={[1]="ENG 154",[2]="LIT 204", <div><img src="https://learning.oreilly.com/library/view/beginning-lua-programming/9780470069172/figs/U002.png" alt="How It Works" width="12" height="12"></div>
 [3]="HUM 120",[4]="PHY 100",['Id']=390}}</pre><p>With a little finesse, you could generate a rendition that is more readable. This readability doesn't matter to the receiving machine, but it might be desirable if some type of monitoring by people is required. When the receiving script receives the string, it can reconstruct the data structure as follows:</p><pre class="programlisting">Fnc = loadstring("return {" .. Str .. "}")
if Fnc then
  Tbl = Fnc()
end</pre><p>To avoid the concatenation on the receiving side, wrap the string with <code class="literal">return {</code> and <code class="literal">}</code> on the sending side instead.</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="summary-061"></a>Summary</h1></div></div></div><p>Network communication with Lua is well-supported by the excellent LuaSocket library and other tools such as the <code class="literal">plink</code> utility. In this chapter, you learned about the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Berkeley sockets and their use in Internet communication</p></li><li class="listitem"><p>LuaSocket's support for domain name queries, URL parsing, and socket communication</p></li><li class="listitem"><p>Sending e-mail with SMTP and receiving it with POP</p></li><li class="listitem"><p>Requesting web pages and other Internet resources via the Web</p></li><li class="listitem"><p>The system of filters, sources, sinks, and pumps that can condition data in transit</p></li><li class="listitem"><p>Using external tools for networking with standard streams</p></li></ul></div><p>In the next chapter, you'll explore how Lua is used in computer games. But before you leave this chapter, try the following exercises to enhance your Lua networking skills.</p></div><div class="sect1"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-062"></a>Exercises</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A simple cipher known as <span class="emphasis"><em>rot13</em></span> is often used to casually obscure text. This method is often used in newsgroup postings to veil potentially offensive jokes or the answers to riddles. This forces the reader to intentionally apply the cipher to make the text understandable. Each ASCII character in the text is effectively rotated 13 positions, so that characters in the range from A through M are shifted up to N through Z, and characters in the range N through Z are shifted down to A through M. A similar rotation takes place with lowercase letters. All characters outside of these ranges remain unaffected. The cipher rotates from the midpoint of each character range (that is A-Z and a-z), so it is its own inverse in the sense that applying it to converted text restores the original text.</p><p>Write a simple filter (a function that accepts a string and returns a converted string) that implements rot13. Use the <code class="literal">Transform</code> function from the Text Hydraulics example to check your filter. The decimal values of the characters <code class="literal">A</code> and <code class="literal">a</code> are 65 and 97, respectively.</p><p>Tbbq yhpx!</p></li><li class="listitem"><p>Extend the e-mail retrieval example to include the message body when displaying the headers if the size of the message is less than or equal to 4096 bytes. Do this by writing a function named <code class="literal">LclBodyPrint</code> that is called in the existing header loop as follows:</p><pre class="programlisting">for J, Rec in ipairs(HdrTbl) do
   io.write("--- Msg ", J, " ---\n",
     " Subject: ", Rec.subject or "---", "\n",
     " To:  ", Rec.to or "---", "\n",
     " Cc:  ", Rec.cc or "---", "\n",
     " From: ", Rec.from or "---", "\n",
     " Date: ", Rec.date or "---", "\n",
     " Size: ", Rec.size or "---", "\n")
    <strong class="userinput"><code>if Rec.size &lt;= 4096 then</code></strong>
        <strong class="userinput"><code>LclBodyPrint(PopHnd, J)</code></strong>
    <strong class="userinput"><code>end</code></strong>
end</pre><p>The POP command to retrieve a message body is <code class="literal">RETR position</code>, where <code class="literal">position</code> is the value <code class="literal">J</code> in the header loop shown above. If the <code class="literal">RETR</code> command is successful, it returns the entire message including headers in multiple lines. Use the blank line between the headers and the message body to print only the body.</p></li><li class="listitem"><p>In the Stream-Based Client exercise, you used <code class="literal">netcat</code> or <code class="literal">plink</code> to pass three lines to an echo server. Do the same using the LuaSocket package rather than an external tool.</p></li></ol></div></div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="ch15.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">15. Programming for the Web</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="ch17.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">17. Programming Games with Lua</div>
        </a>
    
  
  </div>


        
    </section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag">
        
        

        
          <p>You have 6 days left in your trial, Michaelschiner. Subscribe today. <a href="https://learning.oreilly.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
        
        

      </div>

    
    



        
      </div>
      
        

<footer class="pagefoot t-pagefoot">
  <a href="ch16.html#" class="icon-up" onclick="window.Appcues.track('JumpTop_HeronBook')"><div class="visuallyhidden">Back to top</div></a>
  <ul class='js-footer-nav'>
  
    
    <li><a href="https://learning.oreilly.com/public/support/">Support</a></li>
    
    <li><a href="https://learning.oreilly.com/accounts/logout/">Sign Out</a></li>
    
  
  
  </ul>
  <span class="copyright">&#169; 2021 <a href="https://learning.oreilly.com/" target="_blank">O'Reilly Media, Inc</a>.</span>
  
    
    <a href="https://www.oreilly.com/terms/">Terms of Service</a> 
     / 
    
    <a href="https://learning.oreilly.com/privacy">Privacy Policy</a> 
    
    
  
</footer>

      
    
    <script src="https://learning.oreilly.com/jsi18n/web/" charset="utf-8"></script>
    <script src="https://learning.oreilly.com/library/jsi18n/appcache/" charset="utf-8"></script>
  </body>
</html>
