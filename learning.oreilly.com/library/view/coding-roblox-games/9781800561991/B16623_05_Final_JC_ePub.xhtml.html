<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/coding-roblox-games/9781800561991/B16623_05_Final_JC_ePub.xhtml"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9781800561991"
  data-publishers="Packt Publishing"



  data-htmlfile-name="B16623_05_Final_JC_ePub.xhtml"
  data-epub-title="Coding Roblox Games Made Easy" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/coding-roblox-games/9781800561991/B16623_05_Final_JC_ePub.xhtml"
data-csrf-cookie="csrfsafari"


  data-user-id="11366403"
  data-user-uuid="ce47de5b-ce80-49f0-b5cd-c60d3d33b198"
  data-username="michaelschiner"
  data-account-type="Trial"
  
  data-activated-trial-date="05/13/2021"


  data-archive="9781800561991"
  data-publishers="Packt Publishing"



  data-htmlfile-name="B16623_05_Final_JC_ePub.xhtml"
  data-epub-title="Coding Roblox Games Made Easy" data-debug=0 data-testing=0><!--<![endif]--><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="author" content="O'Reilly Media" /><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9781800561991"/><link rel="shortcut icon" href="https://www.oreilly.com/favicon.ico" /><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"/><meta property="twitter:account_id" content="4503599627559754" /><link rel="shortcut icon" href="https://learning.oreilly.com/favicon.ico" type="image/x-icon"><link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic' rel='stylesheet' type='text/css'><title>Chapter 5: Creating an Obby - Coding Roblox Games Made Easy</title><link rel="stylesheet" href="https://learning.oreilly.com/static/CACHE/css/output.5bdb4fcb2aad.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://learning.oreilly.com/static/css/annotator.e3b0c44298fc.css"/><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book">
    #sbo-rt-content div,#sbo-rt-content p,#sbo-rt-content h1,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4{margin:0;orphans:2;widows:2}#sbo-rt-content p{margin-top:1rem}#sbo-rt-content article,#sbo-rt-content aside,#sbo-rt-content details,#sbo-rt-content figcaption,#sbo-rt-content figure,#sbo-rt-content footer,#sbo-rt-content header,#sbo-rt-content hgroup,#sbo-rt-content main,#sbo-rt-content menu,#sbo-rt-content nav,#sbo-rt-content section,#sbo-rt-content summary{display:block}#sbo-rt-content [hidden],#sbo-rt-content template,#sbo-rt-content .hidden{display:none}#sbo-rt-content a{background-color:transparent}#sbo-rt-content a:active,#sbo-rt-content a:hover{outline:0}#sbo-rt-content abbr[title]{border-bottom:1px dotted}#sbo-rt-content b,#sbo-rt-content strong,#sbo-rt-content .source-inline{font-weight:bold}#sbo-rt-content dfn,#sbo-rt-content .chapter-number,#sbo-rt-content .callout,#sbo-rt-content .callout-heading,#sbo-rt-content .author-quote{font-style:italic}#sbo-rt-content mark{background:#ff0;color:#000}#sbo-rt-content small{font-size:80%}#sbo-rt-content sub,#sbo-rt-content sup,#sbo-rt-content .subscript,#sbo-rt-content .superscript{font-size:75%;line-height:0;position:relative;vertical-align:baseline}#sbo-rt-content sup,#sbo-rt-content .superscript{top:-.5em}#sbo-rt-content sub,#sbo-rt-content .subscript{bottom:-.25em}#sbo-rt-content img{border:0}#sbo-rt-content svg:not(:root){overflow:hidden}#sbo-rt-content div.IMG---Figure{margin-top:1rem;margin-left:auto;margin-right:auto;text-align:center;width:100%;max-width:100%;page-break-inside:avoid !important;page-break-before:auto}#sbo-rt-content div.figure-logo{text-align:left;width:40%;max-width:40%}#sbo-rt-content hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}#sbo-rt-content html{font-size:62.5%}#sbo-rt-content div{font-size:1.5em;line-height:1.6;font-weight:400;color:#222}#sbo-rt-content h1,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content .figure-caption{margin-top:1.2rem;margin-bottom:1rem;font-weight:normal}#sbo-rt-content .figure-caption{text-align:center}#sbo-rt-content .author-quote{text-align:left;margin-left:2rem}#sbo-rt-content .author-quote-source{text-align:right;font-style:italic;margin-left:2rem}#sbo-rt-content h1{font-family:serif;font-size:3.2rem;line-height:1.2;letter-spacing:.2rem;margin-top:2rem;margin-bottom:1.5rem}#sbo-rt-content .H1---Section-Part{font-family:serif;font-size:3rem;line-height:1.2;letter-spacing:.2rem;margin-top:2rem;margin-bottom:1.5rem;text-transform:uppercase}#sbo-rt-content h2{font-family:serif;font-size:2.4rem;line-height:1.25;letter-spacing:.15rem;margin-top:2rem;margin-bottom:1rem}#sbo-rt-content h3{font-family:serif;font-size:2rem;line-height:1.3;letter-spacing:.1rem;margin-top:2rem;margin-bottom:.5rem}#sbo-rt-content h4{font-family:serif;font-size:1.6rem;font-weight:bold;line-height:1.35;letter-spacing:.08rem;margin-top:2rem;margin-bottom:.5rem}#sbo-rt-content p{margin-top:1rem}#sbo-rt-content a{color:#1EAEDB}#sbo-rt-content a:hover{color:#f37121}#sbo-rt-content ul{font-family:serif;list-style:circle outside}#sbo-rt-content ol{font-family:serif;list-style:decimal outside}#sbo-rt-content ol,#sbo-rt-content ul{padding-left:1rem;margin-top:0}#sbo-rt-content ul ul,#sbo-rt-content ul ol,#sbo-rt-content ol ol,#sbo-rt-content ol ul{margin:0 0 1.5rem 2rem}#sbo-rt-content li{font-family:serif;margin-bottom:.5rem;margin-top:.5rem}#sbo-rt-content .callout-heading{font-family:sans-serif;font-size:2rem;line-height:1.5;letter-spacing:.05rem;text-transform:uppercase}#sbo-rt-content .callout{font-family:serif}#sbo-rt-content code,#sbo-rt-content kbd,#sbo-rt-content pre,#sbo-rt-content samp,#sbo-rt-content .source-code,#sbo-rt-content .source-inline,#sbo-rt-content .screen-inline{font-family:"CourierStd.otf",monospace;font-size:1.4rem}#sbo-rt-content pre{-epub-hyphens:none;-epub-ruby-position:over;font-size:1.4rem;margin-top:.3rem;margin-bottom:0;margin-left:5rem;margin-right:0;text-align:left;text-decoration:none;text-indent:-4.6rem}#sbo-rt-content p.source-code{font-family:"CourierStd.otf",monospace;-epub-hyphens:none;-epub-ruby-position:over;font-size:1.4rem;font-style:normal;font-variant:normal;font-weight:normal;line-height:1.1rem;margin-top:.3rem;margin-bottom:0;margin-left:5rem;margin-right:0;text-align:left;text-decoration:none;text-indent:-4.6rem}#sbo-rt-content .source-code-heading{font-family:"MinionPro",serif;margin-bottom:1.5rem;border-bottom:2px solid #424242;font-weight:bold}#sbo-rt-content .source-code-link{font-family:"CourierStd.otf",monospace;margin-top:1.5rem;border-top:2px solid #424242;font-style:italic}
    </style><script> // <![CDATA[
    var g = {
      position_cache: {
        
          "chapter": "/api/v1/book/9781800561991/chapter/B16623_05_Final_JC_ePub.xhtml",
          "book_id": "9781800561991",
          "chapter_uri": "B16623_05_Final_JC_ePub.xhtml",
          "position": 0,
          "user_uuid": "ce47de5b-ce80-49f0-b5cd-c60d3d33b198",
          "next_chapter_uri": "/library/view/coding-roblox-games/9781800561991/B16623_06_Final_JC_ePub.xhtml"
        
      },
      title: "Coding Roblox Games Made Easy",
      author_list: "Zander Brumbaugh",
      format: "book",
      source: "application/epub+zip",
      is_system_book: true,
      is_public: false,
      loaded_from_server: true,
      allow_scripts: false,
      has_mathml: false
    };
    // ]]></script><script src="https://learning.oreilly.com/static/js/src/modernizr.8e35451ddb64.js"></script><script>
    
      

      
        
          window.PUBLIC_ANNOTATIONS = true;
        
      

      window.MOBILE_PUBLIC_ANNOTATIONS = false;

    

    
      window.PRIVACY_CONTROL_OVERRIDE = false;
    

      window.PRIVACY_CONTROL_SWITCH = true;

      window.PUBLISHER_PAGES = true;

      window.SBO = {
        "constants": {
          "SITB_ENDPOINT": "/api/v2/sitb/",
          "SEARCH_SELECT_ENDPOINT": "https://learning.oreilly.com/api/v2/search/select/",
        }
      };
  </script><link rel="canonical" href="B16623_05_Final_JC_ePub.xhtml.html"/><meta name="description" content=" Chapter 5: Creating an Obby Now that you have the knowledge needed to make a full game, you will first put your skills to the test by making an ... "><meta property="og:title" content="Chapter 5: Creating an Obby" /><meta itemprop="isPartOf" content="/library/view/coding-roblox-games/9781800561991/" /><meta itemprop="name" content="Chapter 5: Creating an Obby" /><meta property="og:url" itemprop="url" content="https://learning.oreilly.com/library/view/coding-roblox-games/9781800561991/B16623_05_Final_JC_ePub.xhtml" /><meta property="og:site_name" content="Safari" /><meta property="og:image" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9781800561991/" /><meta property="og:description" itemprop="description" content=" Chapter 5: Creating an Obby Now that you have the knowledge needed to make a full game, you will first put your skills to the test by making an ... "><meta itemprop="inLanguage" content="en" /><meta itemprop="publisher" content="Packt Publishing" /><meta property="og:type" content="book" /><meta property="og:book:isbn" itemprop="isbn" content="9781800561991" /><meta property="og:book:author" itemprop="author" content="Zander Brumbaugh" /><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@OReillyMedia"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><noscript><meta http-equiv="refresh" content="0; URL=https://learning.oreilly.com/library/no-js/" /></noscript><script>
    var dataLayer = window.dataLayer || [];

    
      window.medalliaVsgUserIdentifier = 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198';
      dataLayer.push({userIdentifier: 'ce47de5b-ce80-49f0-b5cd-c60d3d33b198'});
      dataLayer.push({loggedIn: 'yes'});

      
        window.medalliaVsgAccountIdentifier = '29964b7b-68d8-4532-9a9b-32e089689c1f';
        

        window.medalliaVsgIsIndividual = true;
        
          
          dataLayer.push({learningAccountType: 'free trial'});
          
        

        
      
    

    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5P4V6Z');
    (function () {
      var VERSION = 'V1.1';
      var AUTHOR = 'Awwad';
      if (!window.GtmHelper)
        window.GtmHelper = function () {
          var instance = this;
          var loc = document.location;
          this.version = VERSION;
          this.author = AUTHOR;
          this.readCookie = function (name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for (var i = 0; i < ca.length; i++) {
              var c = ca[i];
              while (c.charAt(0) == ' ') c = c.substring(1, c.length);
              if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
          };
          this.createCookie = function (name, value, days, cookieDomain) {
            var domain = "";
            var expires = "";

            if (days) {
              var date = new Date();
              date.setTime(date.getTime() + Math.ceil(days * 24 * 60 * 60 * 1000));
              var expires = " expires=" + date.toGMTString() + ";";
            }

            if (typeof (cookieDomain) != 'undefined')
              domain = " domain=" + cookieDomain + "; ";

            document.cookie = name + "=" + value + ";" + expires + domain + "path=/";
          };

          this.isDuplicated = function (currentTransactionId) {
            // the previous transaction id:
            var previousTransIdValue = this.readCookie("previousTransId");

            if (currentTransactionId === previousTransIdValue) {
              return true; // Duplication
            } else {
              return false;
            }
          };
        }
    })()
  </script><script defer src="https://learning.oreilly.com/static/js/build/vendor.0eac897f11ed.js"></script><script defer src="https://learning.oreilly.com/static/js/build/reader.c745ea9296ac.js"></script></head>


<body class="reading sidenav nav-collapsed  scalefonts">

    
  <noscript> 
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
            height="0" width="0"
            style="display:none;visibility:hidden">
    </iframe>
  </noscript>



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        

  


<a href="B16623_05_Final_JC_ePub.xhtml.html#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li><a href="https://learning.oreilly.com/home/" class="l0 nav-icn"><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.738 14H9.254v-3.676a.617.617 0 0 0-.621-.613H7.39a.617.617 0 0 0-.62.613V14H4.284a.617.617 0 0 1-.622-.613V10.22c0-.327.132-.64.367-.87l3.547-3.493a.627.627 0 0 1 .875 0l3.54 3.499c.234.229.366.54.367.864v3.167a.617.617 0 0 1-.62.613zM7.57 2.181a.625.625 0 0 1 .882 0l5.77 5.692-.93.92-5.28-5.209-5.28 5.208-.932-.919 5.77-5.692z" /></svg><span>Home</span></a></li><li class="search"><a href="B16623_05_Final_JC_ePub.xhtml.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"/></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="B16623_05_Final_JC_ePub.xhtml.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"/></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li class="flyout-parent"><a
                href="B16623_05_Final_JC_ePub.xhtml.html#"
                class="l1 nav-icn "
                
              ><?xml version="1.0" encoding="UTF-8"?><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M8,8 C6.34321755,8 5.00013,6.65691245 5.00013,5.00013 C5.00013,3.34334755 6.34321755,2.00026001 8,2.00026001 C9.65678245,2.00026001 10.99987,3.34334755 10.99987,5.00013 C10.99987,6.65691245 9.65678245,8 8,8 Z M2.33024571,11.3523547 L2.33774538,11.3523547 C3.7622187,9.70968996 5.82947484,8.76608166 8.00374984,8.76608166 C10.1780248,8.76608166 12.245281,9.70968996 13.6697543,11.3523547 C13.8892083,11.6177474 14.0062813,11.9530021 13.99974,12.2973138 L13.99974,13.99974 L2.00026001,13.99974 L2.00026001,12.2973138 C1.99371867,11.9530021 2.11079172,11.6177474 2.33024571,11.3523547 Z" id="path-1"></path></svg><span>Your O&#39;Reilly</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/profile/"
                    class="l2 nav-icn"
                    
                  ><span>Profile</span></a></li><li><a
                    href="https://learning.oreilly.com/history/"
                    class="l2 nav-icn"
                    
                  ><span>History</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/"
                    class="l2 nav-icn"
                    
                  ><span>Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/u/ce47de5b-ce80-49f0-b5cd-c60d3d33b198/"
                    class="l2 nav-icn"
                    
                  ><span>Highlights</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/answers/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M2.31032699,3.75609006 C4.65421571,1.41371359 8.45302454,1.41472092 10.7955702,3.75860838 C13.1381158,6.10249583 13.1369405,9.90130261 10.7930518,12.243847 C8.44916311,14.5863913 4.65018639,14.5852161 2.30780867,12.2413286 C-0.0346204845,9.89749489 -0.0334929936,6.09853298 2.31032699,3.75609006 Z M8.8198605,4.98016308 C7.34193969,3.86924672 5.23410194,3.98609692 3.88914868,5.33104946 C3.12814393,6.09032122 2.72818176,7.13880077 2.79015179,8.21201133 C2.79115912,8.23064692 2.79233434,8.24928252 2.79350956,8.26791811 L2.79350956,8.26791811 C2.83179539,8.8307976 2.9944077,9.37404287 3.26947292,9.86201677 L3.26947292,9.86201677 L2.77621706,11.7027432 C2.7699968,11.7259241 2.77662063,11.7506624 2.79359185,11.7676337 C2.8105631,11.7846049 2.83530144,11.7912287 2.85848233,11.7850085 L2.85848233,11.7850085 L4.69400524,11.2922565 C5.26306363,11.6167344 5.90703177,11.786885 6.56209849,11.7858479 C8.64827865,11.7858479 10.3395879,10.094542 10.3395879,8.00836292 C10.3405204,6.84135608 9.80105674,5.73967784 8.87862141,5.02482134 L8.87862141,5.02482134 L8.82825492,4.98654283 Z M13.7933062,2 C14.7073496,2.00009863 15.4482759,2.74110484 15.4482759,3.65514822 C15.4482759,4.32460943 15.0449926,4.92814782 14.4264842,5.18432286 C13.8079757,5.44049789 13.096053,5.29885769 12.6226979,4.82545158 C12.1493429,4.35204547 12.0077795,3.64010743 12.2640213,3.02162665 C12.5202631,2.40314587 13.123845,1.99992776 13.7933062,2 Z"/></svg><span>Answers</span></a></li><li class="flyout-parent"><a
                href="B16623_05_Final_JC_ePub.xhtml.html#"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z"/></g></svg><span>Explore</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/topics/"
                    class="l2 nav-icn"
                    
                  ><span>All Topics</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;formats=case%20study&amp;formats=learning%20path&amp;formats=live%20online%20training&amp;formats=notebook&amp;formats=oriole&amp;formats=video&amp;sort=popularity&amp;facet_json=true&amp;page=0&amp;collection_type=expert"
                    class="l2 nav-icn"
                    
                  ><span>Most Popular Titles</span></a></li><li><a
                    href="https://learning.oreilly.com/recommendations/"
                    class="l2 nav-icn"
                    
                  ><span>Recommended</span></a></li><li><a
                    href="https://learning.oreilly.com/search/?query=&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=true&amp;include_notebooks=true&amp;is_academic_institution_account=false&amp;source=user&amp;formats=book&amp;sort=publication_date&amp;facet_json=true&amp;page=0"
                    class="l2 nav-icn"
                    
                  ><span>Early Releases</span></a></li><li><a
                    href="https://learning.oreilly.com/playlists/discover/"
                    class="l2 nav-icn"
                    
                  ><span>Shared Playlists</span></a></li><li><a
                    href="https://learning.oreilly.com/resource-centers/"
                    class="l2 nav-icn"
                    
                  ><span>Resource Centers</span></a></li></ul></li><li class="flyout-parent"><a
                href="B16623_05_Final_JC_ePub.xhtml.html#"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M12.8 3.2A1.2 1.2 0 0 1 14 4.4v8.4a1.2 1.2 0 0 1-1.2 1.2H3.2A1.2 1.2 0 0 1 2 12.8V4.4a1.2 1.2 0 0 1 1.2-1.2h1.2V2h1.2v1.2h4.8V2h1.2v1.2h1.2zm-9.6 9.6h9.6V6.2H3.2v6.6zM8 9.5a1.35 1.35 0 1 1 0-2.7 1.35 1.35 0 0 1 0 2.7zm2.7 2.148v.552H5.3v-.552c0-.321.124-.634.355-.858a3.358 3.358 0 0 1 4.69 0c.23.224.355.537.355.858z" /></svg><span>Live Events</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/attend/"
                    class="l2 nav-icn"
                    
                  ><span>All Events</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/architectural-katas/"
                    class="l2 nav-icn"
                    
                  ><span>Architectural Katas</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/ai/"
                    class="l2 nav-icn"
                    
                  ><span>AI &amp; ML</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/strata/"
                    class="l2 nav-icn"
                    
                  ><span>Data Sci &amp; Eng</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/oscon/"
                    class="l2 nav-icn"
                    
                  ><span>Programming</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/infrastructure-ops/"
                    class="l2 nav-icn"
                    
                  ><span>Infra &amp; Ops</span></a></li><li><a
                    href="https://learning.oreilly.com/featured/software-architecture/"
                    class="l2 nav-icn"
                    
                  ><span>Software Arch</span></a></li></ul></li><li class="flyout-parent"><a
                href="B16623_05_Final_JC_ePub.xhtml.html#"
                class="l1 nav-icn "
                
              ><svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.6467109,4.35328907 L14.7964612,7.51003884 C15.0678463,7.78304342 15.0678463,8.22395603 14.7964612,8.49696061 L11.6467109,11.6467109 L10.6597892,10.6597892 L13.3055794,8 L10.6597892,5.34021084 L11.6467109,4.35328907 Z M4.35328907,11.6467109 L1.20353875,8.48996116 C0.932153749,8.21695658 0.932153749,7.77604397 1.20353875,7.50303939 L4.35328907,4.35328907 L5.34021084,5.34021084 L2.69442057,8 L5.34021084,10.6597892 L4.35328907,11.6467109 Z M5.84417089,11.4997226 L8.67194674,4.50027742 L10.1838269,4.50027742 L7.35605105,11.4997226 L5.84417089,11.4997226 Z" id="Mask"></path></svg><span>Interactive</span></a><ul class="flyout"><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=content-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Scenarios</span></a></li><li><a
                    href="https://learning.oreilly.com/scenarios/?classification=sandbox-scenario"
                    class="l2 nav-icn"
                    
                  ><span>Sandboxes</span></a></li><li><a
                    href="https://learning.oreilly.com/interactive/?classification=jupyter-notebook"
                    class="l2 nav-icn"
                    
                  ><span>Jupyter Notebooks</span></a></li></ul></li><li ><a
                href="https://learning.oreilly.com/certifications/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path d="M12.912 9.18L14 8.014l-1.088-1.18a.304.304 0 01-.075-.268L13.195 5l-1.535-.463a.313.313 0 01-.194-.194l-.462-1.537-1.565.358c-.09.03-.194 0-.269-.074L8.007 2 6.845 3.09a.303.303 0 01-.269.074l-1.565-.358-.462 1.537a.313.313 0 01-.194.194L2.82 5l.358 1.567a.26.26 0 01-.075.269L2 8.015l1.088 1.164c.075.075.09.18.075.269l-.358 1.567 1.535.463c.09.03.164.104.194.194l.462 1.537 1.565-.358c.015 0 .045-.015.075-.015.075 0 .15.03.209.074L8.007 14l1.163-1.09a.303.303 0 01.269-.074l1.565.358.462-1.537a.313.313 0 01.194-.194L13.195 11l-.358-1.567a.338.338 0 01.075-.254zm-6.046 1.37L4.41 8.26l1.16-1.244 1.767 1.649L10.4 5.6l1.202 1.202-4.242 4.243-.495-.495z"/></svg><span>Certifications</span></a></li><li ><a
                href="https://learning.oreilly.com/preferences/"
                class="l1 nav-icn "
                
              ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"/></g></svg><span>Settings</span></a></li><li ><a
                href="https://learning.oreilly.com/public/support/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M7.363 6.656a2.692 2.692 0 0 1-2.681-2.703c0-1.493 1.2-2.703 2.681-2.703a2.692 2.692 0 0 1 2.682 2.703c0 1.493-1.2 2.703-2.682 2.703zm4.023 2.027c-1.852 0-3.352 1.513-3.352 3.379H2v-1.534c-.006-.31.099-.612.295-.852a6.666 6.666 0 0 1 9.09-.993zm-.543.676h1.12v.304c.003.284.16.543.408.676a.766.766 0 0 0 .77 0l.303-.176.556.966-.302.176a.772.772 0 0 0-.362.676v.08a.772.772 0 0 0 .362.677l.302.21-.556.965-.302-.175a.766.766 0 0 0-.771 0 .778.778 0 0 0-.409.675v.352h-1.106v-.372a.778.778 0 0 0-.409-.676.766.766 0 0 0-.77 0l-.303.176-.556-.912.302-.176a.772.772 0 0 0 .362-.676v-.04-.04a.772.772 0 0 0-.362-.676l-.302-.176.556-.966.289.155a.766.766 0 0 0 .77 0 .778.778 0 0 0 .41-.676V9.36zm1.562 2.703c0-.271-.108-.531-.3-.722a1.001 1.001 0 0 0-.72-.292 1.01 1.01 0 0 0-.992 1.023 1.01 1.01 0 0 0 1.01 1.004 1.01 1.01 0 0 0 1.002-1.013z" /></svg><span>Support</span></a></li><li ><a
                href="https://get.oreilly.com/email-signup.html"
                class="l1 nav-icn "
                target=&quot;_blank&quot;
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M11.564 2.263l2.172 2.174c.17.168.264.397.264.636V11a.6.6 0 0 1-.6.6h-.6V6.2h-6V2.6a.6.6 0 0 1 .6-.6h3.527c.239 0 .468.095.637.263zM2.6 14a.6.6 0 0 1-.6-.6V6.8a.6.6 0 0 1 .6-.6h1.903a1.2 1.2 0 0 1 .849.352L6.2 7.4H11a.6.6 0 0 1 .6.6v5.4a.6.6 0 0 1-.6.6H2.6zM11 5h1.8L11 3.2V5z" /></svg><span>Newsletters</span></a></li><li ><a
                href="https://learning.oreilly.com/accounts/logout/"
                class="l1 nav-icn "
                
              ><svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.613 12.63A.607.607 0 0 1 2 12.03V3.602C2 3.269 2.274 3 2.613 3h5.515v1.204H3.226v7.223h4.902v1.203H2.613zM5.677 9.02V6.611h4.903V4.926a.301.301 0 0 1 .19-.274.31.31 0 0 1 .33.063l2.722 2.673a.594.594 0 0 1 0 .849L11.1 10.909a.31.31 0 0 1-.331.063.301.301 0 0 1-.19-.274V9.02H5.677z" /></svg><span>Sign Out</span></a></li></ul></div></li></ul></nav></header>



      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="B16623_05_Final_JC_ePub.xhtml.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Coding Roblox Games Made Easy
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="B16623_05_Final_JC_ePub.xhtml.html#" title="Search in archive" class="js-search-controls search-controls" onclick="window.Appcues.track('SearchBook_HeronBook')"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9781800561991/chapter/B16623_05_Final_JC_ePub.xhtml"><div class="js-collections-dropdown collections-dropdown menu-bit-cards" onclick="window.Appcues.track('AddPlaylist_HeronBook')"></div></div></li><li class="js-font-control-panel font-control-activator"><a href="B16623_05_Final_JC_ePub.xhtml.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size" onclick="window.Appcues.track('ChangeFont_HeronBook')"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="B16623_05_Final_JC_ePub.xhtml.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share" onclick="window.Appcues.track('Share_HeronBook')"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a
        class="twitter share-button t-twitter"
        target="_blank"
        aria-label="Share this section on Twitter"
        title="Share this section on Twitter"
      
        href="https://twitter.com/share?url=https://learning.oreilly.com/library/view/coding-roblox-games/9781800561991/B16623_05_Final_JC_ePub.xhtml&text=Coding%20Roblox%20Games%20Made%20Easy&via=OReillyMedia"
      ><span>Twitter</span></a></li><li><a
        class="facebook share-button t-facebook"
        target="_blank"
        aria-label="Share this section on Facebook"
        title="Share this section on Facebook"
        href="https://www.facebook.com/sharer/sharer.php?u=https://learning.oreilly.com/library/view/coding-roblox-games/9781800561991/B16623_05_Final_JC_ePub.xhtml"
      ><span>Facebook</span></a></li><li><a
        class="googleplus share-button t-googleplus"
        target="_blank"
        aria-label="Share this secton on Google Plus"
        title="Share this secton on Google Plus"
        href="https://plus.google.com/share?url=https://learning.oreilly.com/library/view/coding-roblox-games/9781800561991/B16623_05_Final_JC_ePub.xhtml"
      ><span>Google Plus</span></a></li><li><a
        class="email share-button t-email"
        aria-label="Share this section via email"
        title="Share this section via email"
      
        href="mailto:?subject=Safari: Chapter%205%3A%20Creating%20an%20Obby&body=https://learning.oreilly.com/library/view/coding-roblox-games/9781800561991/B16623_05_Final_JC_ePub.xhtml%0D%0Afrom Coding%20Roblox%20Games%20Made%20Easy%0D%0A"
      ><span>Email</span></a></li></ul></li><!-- endif request.user.is_authenticated -->
      </ul>
    </div>

      
          
      

    <section role="document">
        
        




  <script defer src="https://learning.oreilly.com/static/js/build/djangoMessagesPage.bfaca9fd8619.js"></script>


        <script src="https://fast.appcues.com/48743.js"></script>
<script>
  var userId = "ce47de5b-ce80-49f0-b5cd-c60d3d33b198";

  var userObject = {
    firstName: "Michael",
    segment: "Trial",
    admin: "False",
    profileCreatedOn: "2021-05-13",
    academic: ""
  };
  window.Appcues.identify(userId, userObject);
  window.Appcues.page();

  setTimeout(function () {
    window.Appcues.track('ViewingBook_HeronBook')
  }, 20000);
</script>


	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="B16623_04_Final_JC_ePub.xhtml.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">Chapter 4: Roblox Programming Scenarios</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="B16623_06_Final_JC_ePub.xhtml.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">Chapter 6: Creating a Battle Royale Game</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div id="_idContainer057">
			<h1 id="_idParaDest-100"><em class="italic"><a id="_idTextAnchor104"></a>Chapter 5</em>: Creating an Obby</h1>
			<p>Now that you have the knowledge needed to make a full game, you will first put your skills to the test by making an <strong class="bold">obstacle course game</strong>, more commonly called an <strong class="bold">Obby</strong>. From this chapter, you will learn<a id="_idIndexMarker289"></a> how to integrate features from previous chapters such as moving parts, rewards, effects, and player management. By the end of this chapter, we will have integrated all of the material learned in the previous chapters and tested and published a fully functional game.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Managing player data</li>
				<li>Making Obby stages</li>
				<li>Creating rewards</li>
				<li>Adding shops and purchases</li>
				<li>Creating effects</li>
				<li>Testing and publication</li>
			</ul>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor105"></a>Technical requirements</h1>
			<p>You will be working solely in Roblox Studio for this chapter. As previously mentioned, having an internet connection will improve your experience in Studio and allow you to do independent research on any topics that are covered.</p>
			<p>You can find all the code of this chapter in this book's GitHub repository – <a href="https://github.com/PacktPublishing/Coding-Roblox-Games-Made-Easy/tree/main/Chapter05">https://github.com/PacktPublishing/Coding-Roblox-Games-Made-Easy/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor106"></a>Setting up the backend</h1>
			<p>The <strong class="bold">backend</strong> of a system in computing<a id="_idIndexMarker290"></a> refers primarily to the code infrastructure that a client will <a id="_idIndexMarker291"></a>never directly interact with. In this section, we will focus on data and player management, which is done from the server. Additionally, as mentioned in <a href="B16623_03_Final_JC_ePub.xhtml.html#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Introduction to Roblox Lua</em>, for the sake of security, all information that can be obtained by the server should be retrieved by the server. </p>
			<p>At the beginning of <a href="B16623_04_Final_JC_ePub.xhtml.html#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Roblox Programming Scenarios</em>, you were introduced to modules and some of their possible uses. You will find that when making something larger scale, such as a full project, the modularization of game systems becomes quite necessary. If you were to use individual scripts as opposed to modules under one script manager, the organization of your scripts would quickly devolve into a nightmare—something that is not at all manageable for a larger-scale game. For this chapter, the systems you make will be contained within modules for easy access and editing.</p>
			<p>Remember that code inside of modules is simply held and not ran unless the module is explicitly required. The following code should be added to a <strong class="sou ce-inline">Script</strong> instance in <strong class="sou ce-inline">ServerScriptService</strong>; the script does not need to be named anything specific but something along the lines of <strong class="sou ce-inline">ServerHandler</strong> is typically good for organization. All of the modules you create should be parented to this script as it serves as a convenient and secure location where clients cannot access them. You should be comfortable enough with programming in a Roblox environment at this point to change the path of something being indexed if you wish to have it located elsewhere. Just remember that <strong class="sou ce-inline">ServerStorage</strong> and <strong class="sou ce-inline">ServerScriptService</strong> are the optimal places to keep modules as they cannot be accessed and subsequently read over by a rogue client.</p>
			<p>The code within the <strong class="sou ce-inline">ServerHandler</strong> script is simple—each module acts as an isolated system with the <strong class="sou ce-inline">ServerHandler</strong> script requiring those modules to allow them to run. There still exists a purpose of using modules as opposed to individual scripts, as the <strong class="sou ce-inline">ServerHandler</strong> script will likely be used for wider general management on your own projects and modules will only contain code relevant to an individual system. The following code uses a generic <strong class="sou ce-inline">for</strong> loop to iterate over the modules parented to the script. Remember that<a id="_idIndexMarker292"></a> the <strong class="bold">script</strong> keyword refers to the <strong class="sou ce-inline">Script</strong> instance itself in the <strong class="bold">Explorer</strong>. Next, we use the <strong class="sou ce-inline">create()</strong> and <strong class="sou ce-inline">resume()</strong> functions from the <strong class="bold">coroutine</strong> library to make a new thread that envelopes the <strong class="sou ce-inline">require()</strong> function, which takes the current module as its argument. </p>
			<p>In this example, we are creating an identical behavior to that of a <strong class="sou ce-inline">spawn()</strong> function but when used in this application, <strong class="sou ce-inline">spawn()</strong> functions can produce odd and undesirable behavior and consequently <a id="_idIndexMarker293"></a>we should use coroutines. The benefit of making a<a id="_idIndexMarker294"></a> new thread here is if a module yields or potentially throws errors when loaded, it will allow other modules to be left unaffected and to load as intended:</p>
			<p class="sou ce-code">for _, module in pairs(script:GetChildren()) do</p>
			<p class="sou ce-code">    local loadMod = coroutine.create(function()</p>
			<p class="sou ce-code">        require(module)</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    coroutine.resume(loadMod)</p>
			<p class="sou ce-code">end</p>
			<p>Now that we have discussed the structure of the backend, let's see how to manage player data.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor107"></a>Managing player data</h2>
			<p>One of the first parts of<a id="_idIndexMarker295"></a> creating the backend of this game will be managing player data. Not only will the game need to keep track of a currency collected by<a id="_idIndexMarker296"></a> the player, which can be used in a shop, but additionally, we can track player progress to place players where they were during their previous play session. Starting off, we will create a new module called <strong class="sou ce-inline">Data</strong> to contain our code and, as mentioned in the previous section, it should be parented to <strong class="sou ce-inline">ServerHandler,</strong> as shown in <em class="italic">Figure 5.1</em>:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="https://learning.oreilly.com/library/view/coding-roblox-games/9781800561991/image/Figure_5.01_B16623.jpg" alt="Figure 5.1 – The Data module is parented directly to the ServerHandler script
" width="157" height="67">
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 5.1 – The Data module is parented directly to the ServerHandler script</p>
			<p>Moving forward, let's learn <a id="_idIndexMarker297"></a>how to create a <a id="_idIndexMarker298"></a>datastore system.</p>
			<h3>Creating a datastore system</h3>
			<p>To create the datastore system<a id="_idIndexMarker299"></a> for this game, we need to first recognize and define which services will be necessary to set it up. The following code is contained in the <strong class="sou ce-inline">Data</strong> module. You should add the functions seen later in this section to the module after the <strong class="sou ce-inline">dataMod</strong> line is declared and before the <strong class="sou ce-inline">return dataMod</strong> line. Note that adding any code after the <strong class="sou ce-inline">return</strong> statement of a module will result in an error.</p>
			<p>The <strong class="sou ce-inline">Players</strong> service will be needed so that it can be used in some of the functions that will be added. <strong class="sou ce-inline">DataStoreService</strong> is a service that is used to save data to Roblox servers using an associated key and is not visible in the <strong class="bold">Explorer</strong>. </p>
			<p>The <strong class="sou ce-inline">store</strong> variable uses the <strong class="sou ce-inline">GetDataStore()</strong> method of <strong class="sou ce-inline">DataStoreService</strong> to create a new <strong class="sou ce-inline">GlobalDataStore</strong> instance. Data held within this <strong class="sou ce-inline">GlobalDataStore</strong> instance is persistent based on the key it is initialized with; in this case the key is <strong class="sou ce-inline">DataStoreV1</strong>. This means that you can create blank datastores by inputting a key that has not been used in the game before. </p>
			<p>The <strong class="sou ce-inline">sessionData</strong> variable will be used to hold a dictionary containing the data of the players currently in the server using players' <strong class="bold">UserIds</strong> as indexes and a table of data as the value. A <strong class="sou ce-inline">UserId</strong> is the number that can be found in the URL of a player's profile; it is unique to each user and is not altered by name changes, making it an excellent value to use with data persistence:</p>
			<p class="sou ce-code">local playerService = game:GetService("Players")</p>
			<p class="sou ce-code">local dataService = game:GetService("DataStoreService")</p>
			<p class="sou ce-code">local store = dataService:GetDataStore("DataStoreV1")</p>
			<p class="sou ce-code">local sessionData = {}</p>
			<p class="sou ce-code">local dataMod = {}</p>
			<p class="sou ce-code">return dataMod</p>
			<p>The first new function we will introduce into our <strong class="sou ce-inline">Data</strong> module is the <strong class="sou ce-inline">recursiveCopy()</strong> function from <a href="B16623_03_Final_JC_ePub.xhtml.html#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Introduction to Roblox Lua</em>. If you remember from <a href="B16623_03_Final_JC_ePub.xhtml.html#_idTextAnchor054"><em class="italic">Chapter 3</em></a><em class="italic">, Introduction to Roblox Lua</em>, when learning about the table datatype, the tables use references, not <a id="_idIndexMarker300"></a>unique copies, when indexed by variables. By using the <strong class="sou ce-inline">recursiveCopy()</strong> function, you are given some safety when working with data tables in the event that any code you add elsewhere expects a table to be unique:</p>
			<p class="sou ce-code">dataMod.recursiveCopy = function(dataTable)</p>
			<p class="sou ce-code">    local tableCopy = {}</p>
			<p class="sou ce-code">    for index, value in pairs(dataTable) do</p>
			<p class="sou ce-code">        if type(value) == "table" then</p>
			<p class="sou ce-code">            value = dataMod.recursiveCopy(value)</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">        tableCopy[index] = value</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    return tableCopy</p>
			<p class="sou ce-code">end</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that you can keep many of these helper functions as local functions within the module though, for a function such as <strong class="sou ce-inline">recursiveCopy()</strong>, it may be advantageous to be able to easily reference it in other scripts. Hence, adding it to the module table would be preferable as any script can require the module to use the function.</p>
			<p>For organizational purposes, you may want to practice putting helper functions toward the top of your <strong class="sou ce-inline">ModuleScript</strong>, much like local functions must be in order to be defined wherever they are called from. To completely follow this organization model, I suggest that you put functions<a id="_idIndexMarker301"></a> you work with the least at the bottom of your script and have core functions located in the middle.</p>
			<p>In the next section, we will add the functionalities of creating and loading data for players when they join your game. </p>
			<h3>Creating and loading session data</h3>
			<p>When a player joins the game, they<a id="_idIndexMarker302"></a> need to have their data<a id="_idIndexMarker303"></a> added to the <strong class="sou ce-inline">sessionData</strong> dictionary. To do this, we will add a new function to our module titled <strong class="sou ce-inline">setupData()</strong> that takes a <strong class="bold">player</strong> instance as its argument. Notice that, to retrieve data, we use the <strong class="sou ce-inline">GetAsync()</strong> method of the <strong class="sou ce-inline">GlobalDataStore</strong> instance held by the <strong class="sou ce-inline">store</strong> variable. The value held in the <strong class="sou ce-inline">key</strong> variable is the <strong class="sou ce-inline">UserId</strong> associated with the player. If the player has stored data, the <strong class="sou ce-inline">data</strong> variable will contain whatever that data is, be it a table or a single value. If no data is associated with the player, then the variable will hold a nil value. In the following function, we set up two cases that execute depending on whether there is associated data with the player. </p>
			<p>For the first case, we copy a table of stats called <strong class="sou ce-inline">defaultData</strong> and then use a generic <strong class="sou ce-inline">for</strong> loop to change the values within that copy to match the player's data. The advantage of copying the <strong class="sou ce-inline">defaultData</strong> table as opposed to directly adding the player's data table to <strong class="sou ce-inline">sessionData</strong> is that you can add new values to <strong class="sou ce-inline">defaultData</strong> later and it will automatically be integrated into the player's current data the next time the player loads, without the need to do any additional coding. </p>
			<p>For the second case, nothing needs to be done, as a blank copy of the <strong class="sou ce-inline">defaultData</strong> table has already been assigned to them in <strong class="sou ce-inline">sessionData</strong>. If you so desire, you could make an additional module, located somewhere secure, that holds the <strong class="sou ce-inline">defaultData</strong> table for further cleanliness in your script.</p>
			<p>You may notice that a function named <strong class="sou ce-inline">set()</strong> is being called but has not yet been defined. Leave this<a id="_idIndexMarker304"></a> line in your code, as we will be defining and using it later. You should add the following code into your module without alteration unless<a id="_idIndexMarker305"></a> you are confident working with this system:</p>
			<p class="sou ce-code">local defaultData = {</p>
			<p class="sou ce-code">    Coins = 0;</p>
			<p class="sou ce-code">    Stage = 1;</p>
			<p class="sou ce-code">}</p>
			<p class="sou ce-code">dataMod.load = function(player)</p>
			<p class="sou ce-code">    local key = player.UserId</p>
			<p class="sou ce-code">    local data = store:GetAsync(key)</p>
			<p class="sou ce-code">    return data</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">dataMod.setupData = function(player)</p>
			<p class="sou ce-code">    local key = player.UserId</p>
			<p class="sou ce-code">    local data = dataMod.load(player)</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    sessionData[key] = dataMod.recursiveCopy(defaultData)</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    if data then</p>
			<p class="sou ce-code">        for index, value in pairs(data) do</p>
			<p class="sou ce-code">            dataMod.set()</p>
			<p class="sou ce-code">        print(index, value)</p>
			<p class="sou ce-code">            dataMod.set(player, index, value)</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">        </p>
			<p class="sou ce-code">        print(player.Name.. "'s data has been loaded!")</p>
			<p class="sou ce-code">    else</p>
			<p class="sou ce-code">        print(player.Name.. " is a new player!")</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end </p>
			<p>Now, you need to be <a id="_idIndexMarker306"></a>able to call these functions at the appropriate <a id="_idIndexMarker307"></a>times. In the module, include the following <strong class="sou ce-inline">PlayerAdded</strong> event function, which calls <strong class="sou ce-inline">setupData()</strong>, passing along the player as an argument. See also that we implement the <strong class="sou ce-inline">leaderstats</strong> system seen in <a href="B16623_04_Final_JC_ePub.xhtml.html#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Roblox Programming Scenarios</em>, to display the player's current stats. The values in the <strong class="sou ce-inline">leaderstats</strong> folder are set to their associated values in the <strong class="sou ce-inline">defaultData</strong> table by default but, when data is loaded, the <strong class="sou ce-inline">set()</strong> method is called, which updates the values in the <strong class="sou ce-inline">leaderstats</strong> folder, and makes it so you do not need to create any additional cases: </p>
			<p class="sou ce-code">playerService.PlayerAdded:Connect(function(player)</p>
			<p class="sou ce-code">    local folder = Instance.new("Folder")</p>
			<p class="sou ce-code">    folder.Name = "leaderstats"</p>
			<p class="sou ce-code">    folder.Parent = player</p>
			<p class="sou ce-code">    local coins = Instance.new("IntValue")</p>
			<p class="sou ce-code">    coins.Name = "Coins"</p>
			<p class="sou ce-code">    coins.Parent = folder</p>
			<p class="sou ce-code">    coins.Value = defaultData.Coins</p>
			<p class="sou ce-code">    local stage = Instance.new("IntValue")</p>
			<p class="sou ce-code">    stage.Name = "Stage"</p>
			<p class="sou ce-code">    stage.Parent = folder</p>
			<p class="sou ce-code">    stage.Value = defaultData.Stage</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    dataMod.setupData(player)</p>
			<p class="sou ce-code">end)</p>
			<p>Now that <a id="_idIndexMarker308"></a>data for the player has been created and added to <strong class="sou ce-inline">sessionData</strong>, we will<a id="_idIndexMarker309"></a> implement functions into the module to manipulate it.</p>
			<h3>Manipulating session data</h3>
			<p>Now that the <a id="_idIndexMarker310"></a>player has joined and their data has been properly set up, you need to be able to manipulate what is in the <strong class="sou ce-inline">sessionData</strong> table with ease from other scripts. Working once again in the <strong class="sou ce-inline">Data</strong> module, some basic functionality that should be introduced are functions that can set and increment data in the table as well as a function to retrieve data from the table. These three functions are very straightforward; for the <strong class="sou ce-inline">set()</strong> and <strong class="sou ce-inline">increment()</strong> functions, the three arguments are the player that you want to manipulate, a string of the stat you want to be changed, and the value you want to be used with the function:</p>
			<ul>
				<li>For the <strong class="sou ce-inline">set()</strong> function, the player's stat in their <strong class="sou ce-inline">sessionData</strong> table is set to the value provided.</li>
				<li>In the <strong class="sou ce-inline">increment()</strong> function, the stat is set to itself plus the provided value. </li>
				<li>For the <strong class="sou ce-inline">get()</strong> function, you only need to provide a <strong class="bold">player</strong> instance and the name of the stat that you wish to read. </li>
			</ul>
			<p>Notice that both the <strong class="sou ce-inline">set()</strong> and <strong class="sou ce-inline">increment()</strong> functions also update the corresponding stat in the <strong class="sou ce-inline">leaderstats</strong> system to the new value:</p>
			<p class="sou ce-code">dataMod.set = function(player, stat, value)</p>
			<p class="sou ce-code">    local key = player.UserId</p>
			<p class="sou ce-code">    sessionData[key][stat] = value</p>
			<p class="sou ce-code">    player.leaderstats[stat].Value = value</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">dataMod.increment = function(player, stat, value)</p>
			<p class="sou ce-code">    local key = player.UserId</p>
			<p class="sou ce-code">    sessionData[key][stat] = dataMod.get(player, stat) +        value</p>
			<p class="sou ce-code">    player.leaderstats[stat].Value = dataMod.get(player,        stat)</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">dataMod.get = function(player, stat)</p>
			<p class="sou ce-code">    local key = player.UserId</p>
			<p class="sou ce-code">    return sessionData[key][stat]</p>
			<p class="sou ce-code">end</p>
			<p>With the player's data now able to be<a id="_idIndexMarker311"></a> easily changed, the following section will show you how to save this data when the player leaves the game.</p>
			<h3>Saving player data</h3>
			<p>Saving player data should<a id="_idIndexMarker312"></a> be rather familiar after learning how to load data. The function to save data will simply be called <strong class="sou ce-inline">save()</strong> and take a <strong class="bold">player</strong> instance as its argument. Like before, the key used to access the player's data table in <strong class="sou ce-inline">sessionData</strong> is the player's <strong class="sou ce-inline">UserId</strong>. Additionally, the key is used with the <strong class="sou ce-inline">SetAsync()</strong> method of the <strong class="sou ce-inline">GlobalDataStore</strong> instance under the <strong class="sou ce-inline">store</strong> variable to save a copy of that data table. <strong class="sou ce-inline">SetAsync()</strong> takes the key as its first argument and the data that needs to be saved as its second:</p>
			<p class="sou ce-code">dataMod.save = function(player)</p>
			<p class="sou ce-code">    local key = player.UserId</p>
			<p class="sou ce-code">    local data = dataMod.recursiveCopy(sessionData[key])</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    store:SetAsync(key, data)</p>
			<p class="sou ce-code">    print(player.Name.. "'s data has been saved!")</p>
			<p class="sou ce-code">end </p>
			<p>When the player leaves the game, their data table must be removed from <strong class="sou ce-inline">sessionData</strong>. If this were not to occur, your game would consistently have more memory taken up by each player <a id="_idIndexMarker313"></a>as they join the game, and their data would be loaded into the table but not removed. By adding the following <strong class="sou ce-inline">removeSessionData()</strong> function, which takes the player whose data should be removed as its argument, the player's <strong class="sou ce-inline">UserId</strong> can be used as a key to set the player's data table in <strong class="sou ce-inline">sessionData</strong> to nil:</p>
			<p class="sou ce-code">dataMod.removeSessionData = function(player)</p>
			<p class="sou ce-code">    local key = player.UserId</p>
			<p class="sou ce-code">    sessionData[key] = nil</p>
			<p class="sou ce-code">end</p>
			<p>Like using the <strong class="sou ce-inline">PlayerAdded</strong> event to call the <strong class="sou ce-inline">setupData</strong> function, we will be utilizing the <strong class="sou ce-inline">PlayerRemoving</strong> event to detect when a player leaves to save their data and additionally remove their data table from <strong class="sou ce-inline">sessionData</strong>. See that the event function calls both the <strong class="sou ce-inline">save()</strong> and <strong class="sou ce-inline">removeSessionData()</strong> functions of the module, passing its <strong class="bold">player</strong> instance argument as a parameter. Remember that calling functions from modules is yielding, so there is no worry of the player's data table being removed before it has a chance to be saved:</p>
			<p class="sou ce-code">playerService.PlayerRemoving:Connect(function(player)</p>
			<p class="sou ce-code">    dataMod.save(player)</p>
			<p class="sou ce-code">    dataMod.removeSessionData(player)</p>
			<p class="sou ce-code">end)</p>
			<p>The following section covering the creation of your own datastore system will focus on certain implementations<a id="_idIndexMarker314"></a> that will help to make sure your datastore behaves how you want it to, add additional functionality, and learn some more peripheral information about the nature of datastores.</p>
			<h3>Addressing throttling and edge cases</h3>
			<p>Roblox's <strong class="sou ce-inline">DatastoreService</strong> is notoriously finicky, with occasional data loss occurring in<a id="_idIndexMarker315"></a> even the most perfectly setup systems. To make your system<a id="_idIndexMarker316"></a> as perfect as possible, you can implement certain methods that will ensure a player keeps their data if some saving attempts fail.</p>
			<p>One of the most common<a id="_idIndexMarker317"></a> causes of data loss is when <strong class="bold">throttling</strong> occurs. Throttling is essentially what happens when your request to set or retrieve data from Roblox is denied by their servers. An efficient way to prevent this occurrence from damaging a player's data is to<a id="_idIndexMarker318"></a> introduce something called a <strong class="bold">pcall()</strong> (short for <strong class="bold">protected call</strong>) function. A <strong class="sou ce-inline">pcall()</strong> function is used to wrap code and return whether the code executed successfully and if not, what error was encountered. When loading and saving player data, we can wrap the <strong class="sou ce-inline">SetAsync()</strong> and <strong class="sou ce-inline">GetAsync()</strong> method calls with <strong class="sou ce-inline">pcall()</strong> functions and simply retry if the previous attempt to save or load data was unsuccessful. </p>
			<p>In the following code, we redefine both the <strong class="sou ce-inline">save()</strong> and <strong class="sou ce-inline">load()</strong> functions of the <strong class="sou ce-inline">Data</strong> module with versions that implement <strong class="sou ce-inline">pcall()</strong> functions. See that for both of the functions, we check whether the <strong class="sou ce-inline">success</strong> variable is <strong class="sou ce-inline">true</strong> and if not, we call the function again. This loop will continue until success occurs. For saving, we can just call the function but for loading, we do need to implement some recursive logic since something is being returned. As you can see, continued failures will keep calling the <strong class="sou ce-inline">load()</strong> function until there is success, returning the data to where the first retry attempt was made. Make sure to fully replace the two current functions in your module with this code:</p>
			<p class="sou ce-code">dataMod.save = function(player)</p>
			<p class="sou ce-code">    local key = player.UserId</p>
			<p class="sou ce-code">    local data = dataMod.recursiveCopy(sessionData[key])</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    local success, err = pcall(function()</p>
			<p class="sou ce-code">        store:SetAsync(key, data)</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    if success then</p>
			<p class="sou ce-code">        print(player.Name.. "'s data has been saved!")</p>
			<p class="sou ce-code">    else</p>
			<p class="sou ce-code">        dataMod.save(player)</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">dataMod.load = function(player)</p>
			<p class="sou ce-code">    local key = player.UserId</p>
			<p class="sou ce-code">    local data </p>
			<p class="sou ce-code">    local success, err = pcall(function()</p>
			<p class="sou ce-code">        data = store:GetAsync(key)</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    if not success then</p>
			<p class="sou ce-code">        data = dataMod.load(player)</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">    return data</p>
			<p class="sou ce-code">end</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can also record the number of retries your program has made with a differently formatted function and kick the player if a limit you set is reached in an effort to preserve their data, but that will not be necessary for this project. </p>
			<p>By creating an <a id="_idIndexMarker319"></a>autosave system, you can make sure a client's data saves<a id="_idIndexMarker320"></a> after every set period of time, lessening data loss if their data does not save when leaving the game. The following function uses a constant time defined in the <strong class="sou ce-inline">AUTOSAVE_INTERVAL</strong> variable, which should be put toward the top of your module.</p>
			<p>Using a <strong class="sou ce-inline">while</strong> loop, a generic <strong class="sou ce-inline">for</strong> loop iterates through the <strong class="sou ce-inline">sessionData</strong> table, obtaining the player from their <strong class="sou ce-inline">UserId</strong>, which is subsequently their data table key, by using the <strong class="sou ce-inline">GetPlayerByUserId()</strong> method of the <strong class="sou ce-inline">Players</strong> service. Once the player has been found, the <strong class="sou ce-inline">save()</strong> function of the module is called, using the player as a parameter. It is important that you do not make the value held by the <strong class="sou ce-inline">AUTOSAVE_INTERVAL</strong> too small, as saving too frequently may increase the risk of throttling:</p>
			<p class="sou ce-code">local AUTOSAVE_INTERVAL = 120</p>
			<p class="sou ce-code">local function autoSave()</p>
			<p class="sou ce-code">    while wait(AUTOSAVE_INTERVAL) do</p>
			<p class="sou ce-code">        print("Auto-saving data for all players")</p>
			<p class="sou ce-code">        for key, dataTable in pairs(sessionData) do</p>
			<p class="sou ce-code">            local player =                   playerService:GetPlayerByUserId(key)</p>
			<p class="sou ce-code">            dataMod.save(player)</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">spawn(autoSave) --Initialize autosave loop</p>
			<p>Another measure you can take to protect player data is by adding a <strong class="sou ce-inline">BindToClose()</strong> function into your <strong class="sou ce-inline">Data</strong> module. The <strong class="sou ce-inline">Close</strong> event of <strong class="sou ce-inline">game</strong> fires when a server instance shuts down <a id="_idIndexMarker321"></a>because all players have left or the game has been <a id="_idIndexMarker322"></a>manually shut down by the developer. When this occurs, the <strong class="sou ce-inline">PlayerRemoving</strong> event of the <strong class="sou ce-inline">Players</strong> service can be inconsistent in firing. The following function will not only make a request to save every player's data by way of the <strong class="sou ce-inline">dataMod.save()</strong> function but it will prevent the server from closing for up to thirty seconds until the save requests have been fulfilled:</p>
			<p class="sou ce-code">game:BindToClose(function()</p>
			<p class="sou ce-code">    for _, player in pairs(playerService:GetPlayers()) do</p>
			<p class="sou ce-code">        dataMod.save(player)</p>
			<p class="sou ce-code">        player:Kick("Shutting down game. All data saved.")</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end)</p>
			<p>With the datastore system now created, you are encouraged to add whatever stats you want to the <strong class="sou ce-inline">defaultData</strong> table and ensure that the system works by using the testing features of Studio. One way to do this is to, change your stats in the <strong class="sou ce-inline">PlayerAdded</strong> event function after your data has loaded, test, leave, and rejoin to make sure you have the stats you left the testing session with, rather than the values contained within the <strong class="sou ce-inline">defaultData</strong> table.</p>
			<p>The following section will introduce you to some physical mechanics that should be implemented into your Obby.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor108"></a>Managing collisions and player characters</h2>
			<p>Since players could <a id="_idIndexMarker323"></a>potentially be negatively affected by colliding with other players while navigating the stages of your Obby, you will want to introduce a<a id="_idIndexMarker324"></a> collision group so that collisions between players are not possible. To do this, you should create a<a id="_idIndexMarker325"></a> new module named <strong class="bold">Physics</strong>, parented to the <strong class="sou ce-inline">ServerHandler</strong> script like before. The services we will need to define are the <strong class="sou ce-inline">Players</strong> service and <strong class="sou ce-inline">PhysicsService</strong>, as shown in the following code:</p>
			<p class="sou ce-code">local playerService = game:GetService("Players")</p>
			<p class="sou ce-code">local physicsService = game:GetService("PhysicsService")</p>
			<p class="sou ce-code">local physicsMod = {}</p>
			<p class="sou ce-code">return physicsMod</p>
			<p>Next, we do not necessarily need to make any functions within the module for the base of the game, but you may want to make some later if you were to introduce your own systems. Like in <a href="B16623_04_Final_JC_ePub.xhtml.html#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Roblox Programming Scenarios</em>, we need to create a new collision group using a unique string identifier with the <strong class="sou ce-inline">CreateCollisionGroup()</strong> method of <strong class="sou ce-inline">PhysicsService</strong>. </p>
			<p>Following that, the <strong class="sou ce-inline">CollisionGroupSetCollidable()</strong> method of <strong class="sou ce-inline">PhysicsService</strong> is used to make <strong class="sou ce-inline">BasePart</strong> instances within the collision group not collide with each other. This allows us to make a <strong class="sou ce-inline">PlayerAdded</strong> event function, which creates a new <strong class="sou ce-inline">CharacterAdded</strong> event function for any client that connects to the game. </p>
			<p>A generic <strong class="sou ce-inline">for</strong> loop can then be used to iterate over the <strong class="sou ce-inline">BasePart</strong> instances of the player's character, which is conveniently passed as an argument of the <strong class="sou ce-inline">CharacterAdded</strong> event function. Once a <strong class="sou ce-inline">BasePart</strong> instance is found, it is added to the <strong class="sou ce-inline">Players</strong> collision group by way of the <strong class="sou ce-inline">SetPartCollisionGroup()</strong> method of <strong class="sou ce-inline">PhysicsService</strong>. Players will no longer be able to bump each other off the map or stand on top of each other to get to places they should not be able to as a result of the following code:</p>
			<p class="sou ce-code">physicsService:CreateCollisionGroup("Players")</p>
			<p class="sou ce-code">physicsService:CollisionGroupSetCollidable("Players",   "Players", false)</p>
			<p class="sou ce-code">playerService.PlayerAdded:Connect(function(player)</p>
			<p class="sou ce-code">    player.CharacterAdded:Connect(function(char)</p>
			<p class="sou ce-code">        for _, part in pairs(char:GetDescendants()) do</p>
			<p class="sou ce-code">            if part:IsA("BasePart") then</p>
			<p class="sou ce-code">                physicsService:SetPartCollisionGroup(part, "Players")</p>
			<p class="sou ce-code">            end</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">end)</p>
			<p>You should keep in<a id="_idIndexMarker326"></a> mind that collision groups can be used outside of necessary game behaviors. You can use them to make special stages that make use of collision groups for unique puzzle mechanics. For example, you can make <a id="_idIndexMarker327"></a>a stage where a player can pass through a wall without any resistance, but a box or ball cannot pass, sort of like some of the puzzle stages seen in the popular <strong class="bold">Portal</strong> video game series.</p>
			<p>In this section, you learned how to create a comprehensive datastore system that is easily editable and keeps the data of players as secure as possible. Additionally, by way of <strong class="sou ce-inline">PhysicsService</strong>, we made it so players cannot interfere with each other when completing Obby stages.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor109"></a>Making Obby stages</h1>
			<p>Now we get to the most<a id="_idIndexMarker328"></a> important part of developing an Obby: designing your stages! While building and designing your stages is up to you, this section will guide you on how to program various mechanics that can be implemented into your stages to make your game engaging and profitable. </p>
			<p>Let's begin by creating part behaviors.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor110"></a>Creating part behaviors</h2>
			<p>Once again, the modularization of this<a id="_idIndexMarker329"></a> system will be critical. Many new programmers who do not take advantage of modules attempt to use individual scripts to manipulate what is sometimes hundreds of parts. This almost immediately leads to headaches if any changes to these scripts need to be made as the code will need to be changed everywhere. </p>
			<p>By using a module, the code affecting these parts is isolated to a single location and can be edited easily. Our new module, which should be titled <strong class="sou ce-inline">PartFunctions</strong>, will only need to define a few services or modules since we are primarily working with methods from the <strong class="sou ce-inline">BasePart</strong> base class, as seen in the following code:</p>
			<p class="sou ce-code">local playerService = game:GetService("Players")</p>
			<p class="sou ce-code">local replicatedStorage =   game:GetService("ReplicatedStorage")</p>
			<p class="sou ce-code">local dataMod = require(script.Parent.Data)</p>
			<p class="sou ce-code">local partFunctionsMod = {}</p>
			<p class="sou ce-code">return partFunctionsMod</p>
			<p>For these following functions, we will be making use of the <strong class="sou ce-inline">Touched</strong> event of <strong class="sou ce-inline">BasePart</strong> instances. If you remember, <strong class="sou ce-inline">BasePart</strong> instances with a <strong class="sou ce-inline">Touched</strong> event return whatever other <strong class="sou ce-inline">BasePart</strong> instance they were hit by. </p>
			<p>To limit the amount of redundant code, we will make a helper function named <strong class="sou ce-inline">playerFromHit()</strong> that takes a single <strong class="sou ce-inline">BasePart</strong> instance as its argument and looks to see whether the part is a descendant of a player's character. If it is, both the player and the player's character are returned in a tuple format; otherwise, both values will be nil by default. </p>
			<p>Notice that the <strong class="sou ce-inline">FindFirstAncestorOfClass()</strong> method of instances will recursively search for an instance matching the specified class type until a matching instance is found or the game's <strong class="sou ce-inline">DataModel</strong> instance is reached; the <strong class="sou ce-inline">DataModel</strong> is the instance referenced with the <strong class="sou ce-inline">game</strong> keyword, it is at the top of the <strong class="bold">Roblox parent-child hierarchy</strong>. Regardless of whether the <strong class="sou ce-inline">Model</strong> instance is found or the value is nil, it is passed to the <strong class="sou ce-inline">GetPlayerFromCharacter()</strong> method of the <strong class="sou ce-inline">Players</strong> service. </p>
			<p>This method can take a <a id="_idIndexMarker330"></a>nil value or any instance as input but will return nil unless the instance passed to the method is the character model of a player currently connected to the game. If there is an associated player with the passed model, then the player is returned by the <strong class="sou ce-inline">playerFromHit()</strong> function, as visible in the following code:</p>
			<p class="sou ce-code">partFunctionsMod.playerFromHit = function(hit)</p>
			<p class="sou ce-code">    local char = hit:FindFirstAncestorOfClass("Model")</p>
			<p class="sou ce-code">    local player =         playerService:GetPlayerFromCharacter(char)</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    return player, char</p>
			<p class="sou ce-code">end</p>
			<p>As mentioned before, this helper function could be kept as a local function but having it as part of the module allows it to be used in other <strong class="bold">Scripts</strong> that require the module, which may be convenient for a more general behavior like this. The first function we will introduce to our <strong class="sou ce-inline">PartFunctions</strong> module, called <strong class="sou ce-inline">KillParts()</strong>, is for use with a simple kill part. This is used as an obstacle that a player must avoid when trying to complete an Obby stage. When a part with this <strong class="sou ce-inline">Touched</strong> event function linked to it is hit by a player's character, the player will instantly have the <strong class="sou ce-inline">Health</strong> property of the <strong class="sou ce-inline">Humanoid</strong> instance in their character set to <strong class="sou ce-inline">0</strong>, killing them. Humanoids exist in all Roblox characters and are used for controlling the behaviors of these character models.</p>
			<p>See that the <strong class="sou ce-inline">Touched</strong> event passes a hit part as expected, which can be used as a parameter of a call to the newly implemented <strong class="sou ce-inline">playerFromHit()</strong> method, returning both the player and character if the part is a descendant of a player's character model. </p>
			<p>Next, we use short-circuit logic, which was introduced in <a href="B16623_03_Final_JC_ePub.xhtml.html#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, Introduction to Roblox Lua. If the <strong class="sou ce-inline">player</strong> variable is nil, the conditional will end the evaluation since a requirement of the <strong class="sou ce-inline">and</strong> operator is not met. By ordering our conditions in this way, with the player first <a id="_idIndexMarker331"></a>and the Humanoid's <strong class="sou ce-inline">Health</strong> second, we avoid using multiple conditional statements or otherwise producing an error. If the character's Humanoid's <strong class="sou ce-inline">Health</strong> is greater than <strong class="sou ce-inline">0</strong>, it is set to <strong class="sou ce-inline">0</strong>, killing the player, as seen in this code block:</p>
			<p class="sou ce-code">partFunctionsMod.KillParts = function(part)</p>
			<p class="sou ce-code">    part.Touched:Connect(function(hit)</p>
			<p class="sou ce-code">        local player, char =              partFunctionsMod.playerFromHit(hit)</p>
			<p class="sou ce-code">        if player and char.Humanoid.Health &gt; 0 then</p>
			<p class="sou ce-code">            char.Humanoid.Health = 0</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">end</p>
			<p>While not all that important, the health check is implemented to reduce the number of times any lines of code need to be executed since the player does not need to be killed if already dead. This is a small optimization that may amount to something valuable if your game has many stages and players.</p>
			<p>The next function is named <strong class="sou ce-inline">DamageParts()</strong> and is used for when a part should only damage a player and not kill them instantly. You can place many of these throughout an Obby stage to increase the amount of suspense for the player as they try to preserve as much of their health as possible. This function is similar to <strong class="sou ce-inline">KillParts()</strong> but instead of killing the player, it subtracts a specified amount of damage from the player's current health, with the damage being obtained from an <strong class="sou ce-inline">IntValue</strong> in the part named <strong class="sou ce-inline">Damage</strong>. </p>
			<p>Additionally, we introduce something new, which is commonly referred to as a <strong class="sou ce-inline">debounce</strong>. A debounce is a value that prevents something from running until the value is reset. In the following example, we set the debounce from <strong class="sou ce-inline">false</strong> to <strong class="sou ce-inline">true</strong> when the player is damaged and implement a <strong class="sou ce-inline">delay()</strong> function, which resets the value after 0.1 seconds. </p>
			<p>A <strong class="sou ce-inline">delay()</strong> function is created similarly to a <strong class="sou ce-inline">spawn()</strong> function, but a time argument is used before defining the function. You may wonder why someone would use a <strong class="sou ce-inline">delay()</strong> function as opposed to a <strong class="sou ce-inline">wait()</strong> function, but a <strong class="sou ce-inline">delay()</strong> function has the advantage of not yielding any of the code following it, making it suitable for different use cases. </p>
			<p>Since the debounce value is<a id="_idIndexMarker332"></a> reset after 0.1 seconds pass, the player can only be damaged a maximum of 10 times per second. You will find, when making your own systems, that debounces are important for limiting input or other events from being spammed. Be aware that when using a debounce on the client, an exploiter can still change the debounce value, so do not use it as a replacement for good security if you are communicating with the server:</p>
			<p class="sou ce-code">partFunctionsMod.DamageParts = function(part)</p>
			<p class="sou ce-code">    local debounce = false</p>
			<p class="sou ce-code">    local damage = part.Damage.Value</p>
			<p class="sou ce-code">    part.Touched:Connect(function(hit)</p>
			<p class="sou ce-code">        local player, char =              partFunctionsMod.playerFromHit(hit)</p>
			<p class="sou ce-code">        if player and not debounce then</p>
			<p class="sou ce-code">            debounce = true</p>
			<p class="sou ce-code">            local hum = char.Humanoid</p>
			<p class="sou ce-code">            hum.Health = hum.Health - damage</p>
			<p class="sou ce-code">        </p>
			<p class="sou ce-code">            delay(0.1, function()</p>
			<p class="sou ce-code">                debounce = false</p>
			<p class="sou ce-code">            end)</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">end</p>
			<p>One of the stats included in the player's data is <strong class="bold">Stage</strong>, which can be used to save the last stage the player was on and position them whenever they re-join or respawn. The following function, <strong class="sou ce-inline">SpawnParts()</strong>, will be used with parts that should act as checkpoints, positioned at the beginning of each stage. These spawns should contain an <strong class="sou ce-inline">IntValue</strong> named <strong class="sou ce-inline">Stage</strong> and have the value within them be in increasing order. </p>
			<p>Like before, we identify <a id="_idIndexMarker333"></a>whether a player has been hit and then check whether the current checkpoint has a value one more than the player's current stage, to make sure they cannot accidentally go backward and lose progress or cheat and progress too far forward. If this condition is met, the player's <strong class="bold">Stage</strong> stat is updated to match the value of the spawn part they encountered:</p>
			<p class="sou ce-code">partFunctionsMod.SpawnParts = function(part)</p>
			<p class="sou ce-code">    local stage = part.Stage.Value</p>
			<p class="sou ce-code">    part.Touched:Connect(function(hit)</p>
			<p class="sou ce-code">        local player, char =              partFunctionsMod.playerFromHit(hit)</p>
			<p class="sou ce-code">        if player and dataMod.get(player, "Stage") ==              stage - 1 then</p>
			<p class="sou ce-code">            dataMod.set(player, "Stage", stage)</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">end</p>
			<p>While this works as expected, there is no notification that allows the client to feel like they have progressed unless they look at their <strong class="sou ce-inline">leaderstats</strong>. This will be addressed in the <em class="italic">Creating effects</em> section of this chapter where we will implement particles and sounds when a player touches a new spawn point</p>
			<p>Now that these functions have been made, you may have noticed that camel case was not used to declare them. This is because you must create <strong class="sou ce-inline">Folder</strong> instances in the <strong class="bold">Workspace</strong> named after each function that has been defined. This is done so that the following code in the <strong class="sou ce-inline">PartFunctions</strong> module can easily reference the part folders and call the function with the same name. </p>
			<p>Once the folders are <a id="_idIndexMarker334"></a>added to a table, nested <strong class="sou ce-inline">for</strong> loops are used to call the function with the same name as the folder, passing along each part within that folder. You must put this code at the end of your module as all of the functions must be defined before they can be called:</p>
			<p class="sou ce-code">local partGroups = {</p>
			<p class="sou ce-code">    workspace.KillParts;</p>
			<p class="sou ce-code">    workspace.DamageParts;</p>
			<p class="sou ce-code">    workspace.SpawnParts;</p>
			<p class="sou ce-code">}</p>
			<p class="sou ce-code">for _, group in pairs(partGroups) do</p>
			<p class="sou ce-code">    for _, part in pairs(group:GetChildren()) do</p>
			<p class="sou ce-code">        if part:IsA("BasePart") then</p>
			<p class="sou ce-code">            partFunctionsMod[group.Name](part)</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end</p>
			<p>While all of the Obby parts will now work as expected without any additional programming, we must still add functionality to the parts in the <strong class="sou ce-inline">SpawnParts</strong> folder, which currently only update the player's <strong class="bold">Stage</strong> stat. To accomplish this, we will create a new module called <strong class="sou ce-inline">Initialize</strong> under the <strong class="sou ce-inline">ServerHandler</strong> script, which will be a place to run more general tasks that are not specific to a particular system when the player spawns. </p>
			<p>You can see that the player's current stage is obtained from their data, but we need to introduce a new function to get the physical spawn point that corresponds to that number. To do this, we will<a id="_idIndexMarker335"></a> implement a function named <strong class="sou ce-inline">getStage()</strong> that takes a stage number as its argument. This function will use a generic <strong class="sou ce-inline">for</strong> loop to iterate over all parts within the <strong class="sou ce-inline">SpawnParts</strong> folder, returning a part if its <strong class="bold">Stage</strong> value matches the provided <strong class="sou ce-inline">stageNum</strong> argument. With the part returned to the main function, the <strong class="sou ce-inline">CFrame</strong> of the <strong class="sou ce-inline">PrimaryPart</strong> of the player's character is set to the <strong class="sou ce-inline">CFrame</strong> of the found spawn location with an offset so they do not move to the part's exact location, as seen in the following code:</p>
			<p class="sou ce-code">local playerService = game:GetService("Players")</p>
			<p class="sou ce-code">local dataMod = require(script.Parent.Data)</p>
			<p class="sou ce-code">local spawnParts = workspace.SpawnParts</p>
			<p class="sou ce-code">local initializeMod = {}</p>
			<p class="sou ce-code">local function getStage(stageNum)</p>
			<p class="sou ce-code">    for _, stagePart in pairs(spawnParts:GetChildren()) do</p>
			<p class="sou ce-code">        if stagePart.Stage.Value == stageNum then</p>
			<p class="sou ce-code">            return stagePart</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">playerService.PlayerAdded:Connect(function(player)</p>
			<p class="sou ce-code">    player.CharacterAdded:Connect(function(char)</p>
			<p class="sou ce-code">        local stageNum = dataMod.get(player, "Stage")</p>
			<p class="sou ce-code">        local spawnPoint = getStage(stageNum)</p>
			<p class="sou ce-code">        char:SetPrimaryPartCFrame(spawnPoint.CFrame *              CFrame.new(0,3,0))</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">end)</p>
			<p class="sou ce-code">return initializeMod</p>
			<p>Now that the main special<a id="_idIndexMarker336"></a> parts for your Obby have been created, the next step is to keep players engaged by finding multiple ways of rewarding them.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor111"></a>Creating rewards</h2>
			<p>While players may enjoy your<a id="_idIndexMarker337"></a> Obby for its challenge, theme, or unique puzzles, you can further engage your audience by adding rewards for reaching checkpoints or taking unnecessary risks in stages. In the player's data, there is a stat called <strong class="bold">Coins</strong>, which we can <a id="_idIndexMarker338"></a>manipulate to give players a currency they can redeem for in-game items.</p>
			<p>To change a player's <strong class="bold">Coins</strong> stat, we will create a new function named <strong class="sou ce-inline">RewardParts()</strong> in the <strong class="sou ce-inline">PartFunctions</strong> module; make sure that the function is put before the <strong class="sou ce-inline">for</strong> loop that applies functions to parts. Like before, you will need to add a folder with the corresponding name to the <strong class="sou ce-inline">partGroups</strong> table so that parts in the folder can be processed. </p>
			<p>The following function will first capture the number of coins that should be awarded from an <strong class="sou ce-inline">IntValue</strong> in the part named <strong class="sou ce-inline">Reward</strong>. Following this, we will make a unique code for the coin so that we can track which coins a player has collected and prevent them from claiming a coin more than once. </p>
			<p>In the <strong class="sou ce-inline">Touched</strong> event function, the player is acquired, and the function looks to see whether a folder of coin codes titled <strong class="sou ce-inline">CoinTags</strong> already exists in the player. If that folder does not exist, then the folder is created. Now that the folder has been created, we make sure no instances in the folder have the code as their name, indicating that the coin has not been collected before. If this check is passed, the reward amount is given to the player and a tag is added to the folder. </p>
			<p>You may have noticed<a id="_idIndexMarker339"></a> that the part is still visible and that there is nothing that really indicates you collected a coin; this will be addressed in the <em class="italic">Creating effects</em> section of this chapter. Keep in mind that if the player were to re-join the game, whether it is the same server or not, the coins will respawn on the stages. If this is not how you want your Obby to behave, you can make a constant name or code for coins and save the code in the player's data:</p>
			<p class="sou ce-code">local uniqueCode = 0</p>
			<p class="sou ce-code">partFunctionsMod.RewardParts = function(part)</p>
			<p class="sou ce-code">    local reward = part.Reward.Value</p>
			<p class="sou ce-code">    local code = uniqueCode</p>
			<p class="sou ce-code">    uniqueCode = uniqueCode + 1</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    part.Touched:Connect(function(hit)</p>
			<p class="sou ce-code">        local player =              partFunctionsMod.playerFromHit(hit)</p>
			<p class="sou ce-code">        if player then</p>
			<p class="sou ce-code">            local tagFolder =                    player:FindFirstChild("CoinTags")</p>
			<p class="sou ce-code">            if not tagFolder then</p>
			<p class="sou ce-code">                tagFolder = Instance.new("Folder")</p>
			<p class="sou ce-code">                tagFolder.Name = "CoinTags"</p>
			<p class="sou ce-code">                tagFolder.Parent = player</p>
			<p class="sou ce-code">            end</p>
			<p class="sou ce-code">            </p>
			<p class="sou ce-code">            if not tagFolder:FindFirstChild(code) then</p>
			<p class="sou ce-code">                dataMod.increment(player, "Coins",                         reward)</p>
			<p class="sou ce-code">                </p>
			<p class="sou ce-code">                local codeTag =                         Instance.new("BoolValue")</p>
			<p class="sou ce-code">                codeTag.Name = code</p>
			<p class="sou ce-code">                codeTag.Parent = tagFolder</p>
			<p class="sou ce-code">            end</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">end</p>
			<p>One way to make<a id="_idIndexMarker340"></a> players feel more engaged is to create and award them badges. In the case that you want to award badges when a part is touched, you could implement the following function. </p>
			<p>We will define this function as <strong class="sou ce-inline">BadgeParts()</strong> to work with our previously made part processing system and additionally define <strong class="sou ce-inline">BadgeService</strong> at the beginning of the module with the other services. The ID of the badge you want to be awarded should be the value of an <strong class="sou ce-inline">IntValue</strong> instance within the part named <strong class="sou ce-inline">BadgeId</strong>. Remember that the <strong class="sou ce-inline">BadgeParts</strong> folder will need to be defined and added to the <strong class="sou ce-inline">partGroups</strong> table. After the <strong class="sou ce-inline">BadgeID</strong> has been obtained, we check for a valid player and continue. </p>
			<p>By using the <strong class="sou ce-inline">UserHasBadgeAsync()</strong> method of <strong class="sou ce-inline">BadgeService</strong>, which takes a player's <strong class="sou ce-inline">UserId</strong> and a <strong class="sou ce-inline">BadgeId</strong>, we can check whether the player is already in possession of the badge so that a warning is not produced in the <strong class="bold">Output</strong> window saying that the badge has already been awarded to them. If you recall from <a href="B16623_02_Final_JC_ePub.xhtml.html#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Know Your Work Environment</em>, badges can only be awarded once to a player if they delete it from their inventory. </p>
			<p>After checking that the player does not own the badge, the badge is awarded to the player by using the <strong class="sou ce-inline">AwardBadge()</strong> method of <strong class="sou ce-inline">BadgeService</strong>, which similarly takes a player's <strong class="sou ce-inline">UserId</strong> and a <strong class="sou ce-inline">BadgeId</strong>, as seen<a id="_idIndexMarker341"></a> in the following code:</p>
			<p class="sou ce-code">local badgeService = game:GetService("BadgeService")</p>
			<p class="sou ce-code">partFunctionsMod.BadgeParts = function(part)</p>
			<p class="sou ce-code">    local badgeId = part.BadgeId.Value</p>
			<p class="sou ce-code">    part.Touched:Connect(function(hit)</p>
			<p class="sou ce-code">        local player =              partFunctionsMod.playerFromHit(hit)</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">        if player then</p>
			<p class="sou ce-code">            local key = player.UserId</p>
			<p class="sou ce-code">            local hasBadge =                   badgeService:UserHasBadgeAsync(key,                     badgeId)</p>
			<p class="sou ce-code">            if not hasBadge then</p>
			<p class="sou ce-code">                badgeService:AwardBadge(key, badgeId)</p>
			<p class="sou ce-code">            end</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">end</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor112"></a>Shops and purchases</h2>
			<p>Now that the stages of your Obby are functionally complete, you can begin to monetize it by introducing shops that make<a id="_idIndexMarker342"></a> use of in-game currency as well as Robux! Introducing an economy into your game will not only create a new way to engage your players but also make money with in-game purchases.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor113"></a>Robux premium purchases</h2>
			<p>To generate revenue from your<a id="_idIndexMarker343"></a> game, you must implement some Robux-only items that your players can purchase. As mentioned in <a href="B16623_01_Final_JC_ePub.xhtml.html#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Welcome to Roblox Development</em>, Roblox developers primarily make money from selling items in their games as well as from Premium Payouts. This section will show you how to make a dynamic sales system as well as some specific powerups for your Obby.</p>
			<p>For this system, we <a id="_idIndexMarker344"></a>will be introducing a new module called <strong class="bold">Monetization</strong>, parented to the <strong class="sou ce-inline">ServerHandler</strong> script. This module will define two services we have not worked with before, those being <strong class="sou ce-inline">InsertService</strong> and <strong class="sou ce-inline">MarketplaceService</strong>. </p>
			<p><strong class="sou ce-inline">InsertService</strong> is used primarily to load assets from the website from an identifying <strong class="sou ce-inline">assetId</strong>. An asset's <strong class="sou ce-inline">assetId</strong> is typically the numbers seen in the URL of an item on the Roblox website. </p>
			<p><strong class="sou ce-inline">MarketplaceService</strong> is used to manage Roblox purchases, including processing purchase data to comply with Roblox regulations as well as awarding players once they have purchased an item from your game. </p>
			<p>The module will contain the following code to start:</p>
			<p class="sou ce-code">local playerService = game:GetService("Players")</p>
			<p class="sou ce-code">local dataService = game:GetService("DataStoreService")</p>
			<p class="sou ce-code">local insertService = game:GetService("InsertService")</p>
			<p class="sou ce-code">local marketService = game:GetService("MarketplaceService")</p>
			<p class="sou ce-code">local dataMod = require(script.Parent.Data)</p>
			<p class="sou ce-code">local monetizationMod = {}</p>
			<p class="sou ce-code">return monetizationMod</p>
			<p>The first function we will introduce to the <strong class="sou ce-inline">Monetization</strong> module will be called <strong class="sou ce-inline">insertItem()</strong>. This function <a id="_idIndexMarker345"></a>will be used to load and insert <strong class="bold">Gears</strong> from the website using <strong class="sou ce-inline">InsertService</strong> and parent it to the <strong class="sou ce-inline">Backpack</strong> instance of the desired player. By using the <strong class="sou ce-inline">LoadAsset()</strong> method of <strong class="sou ce-inline">InsertService</strong>, the asset corresponding to the passed ID will be loaded into the game. Assets inserted with this service will be parented to a model for<a id="_idIndexMarker346"></a> organization. This means that our item must be taken out of the model and the model removed from the game using the <strong class="sou ce-inline">Destroy()</strong> method of instances. </p>
			<p>The <strong class="sou ce-inline">Destroy()</strong> method will completely remove any instance from your game and, like the <strong class="sou ce-inline">Clone()</strong> method, it cannot be used with certain instances. Once our <strong class="sou ce-inline">tool</strong> is indexed, it is parented to the player's <strong class="sou ce-inline">Backpack</strong> instance:</p>
			<p class="sou ce-code">monetizationMod.insertTool = function(player, assetId)</p>
			<p class="sou ce-code">    local asset = insertService:LoadAsset(assetId)</p>
			<p class="sou ce-code">    local tool = asset:FindFirstChildOfClass("Tool")</p>
			<p class="sou ce-code">    tool.Parent = player.Backpack</p>
			<p class="sou ce-code">    asset:Destroy()</p>
			<p class="sou ce-code">end</p>
			<p>With the <strong class="sou ce-inline">insertTool()</strong> function now created, we need to write the code that will appropriately call it. The following code example adds functions to <strong class="sou ce-inline">monetizationMod</strong> using a <strong class="sou ce-inline">gamepassId</strong> or developer <strong class="sou ce-inline">productId</strong> as the function's index. This format is important as it will allow us to easily call a corresponding function when a purchase is made, using the ID of the item purchased. </p>
			<p>Keep in mind that you will have to upload your own gamepasses to the game from the <strong class="bold">Create</strong> page and replace the zeroes in the indexes with the numbers from the gamepass's URL. Additionally, we include one currency developer product that can be purchased multiple times by the player:</p>
			<p class="sou ce-code">monetizationMod[000000] = function(player)</p>
			<p class="sou ce-code">    --Speed coil</p>
			<p class="sou ce-code">    monetizationMod.insertTool(player, 99119158)</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">monetizationMod[000000] = function(player)</p>
			<p class="sou ce-code">    --Gravity coil</p>
			<p class="sou ce-code">    monetizationMod.insertTool(player, 16688968)</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">monetizationMod[000000] = function(player)</p>
			<p class="sou ce-code">    --Radio</p>
			<p class="sou ce-code">    monetizationMod.insertTool(player, 212641536)</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">monetizationMod[000000] = function(player)</p>
			<p class="sou ce-code">    --100 Coins</p>
			<p class="sou ce-code">    dataMod.increment(player, "Coins", 100)</p>
			<p class="sou ce-code">end</p>
			<p>When prompting gamepasses, we use the <strong class="sou ce-inline">PromptGamePassPurchaseFinished</strong> event of <strong class="sou ce-inline">MarketplaceService</strong> to detect when the player has finished interacting with the prompt. The event passes along as arguments to your function: the player who was prompted, the ID of the <a id="_idIndexMarker347"></a>prompt sent to them, and whether the player bought the item that was prompted to them. If the player did purchase what they were prompted, we can simply call the already defined function that has an index in the module matching the ID passed by the event. </p>
			<p>Note that we also introduce a new service called <strong class="sou ce-inline">CollectionService</strong>. <strong class="sou ce-inline">CollectionService</strong> is used to add tags to instances as well as check for them. The <strong class="sou ce-inline">AddTag()</strong> method of the service takes an instance and a string as its two arguments. You can see that a tag is added <a id="_idIndexMarker348"></a>to the player with its value as the ID of the gamepass purchased; this will be important later in this section:</p>
			<p class="sou ce-code">local collectionService =   game:GetService("CollectionService")</p>
			<p class="sou ce-code">marketService.PromptGamePassPurchaseFinished:</p>
			<p class="sou ce-code"> Connect(function(player, gamePassId, wasPurchased)</p>
			<p class="sou ce-code">    if wasPurchased then</p>
			<p class="sou ce-code">        collectionService:AddTag(player, gamePassId)</p>
			<p class="sou ce-code">        monetizationMod[gamePassId](player)</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end)</p>
			<p>For developer products, Roblox has not made the process as streamlined. As before, the reason our previous example uses a <strong class="sou ce-inline">gamepassId</strong> as the function's index is so that we can make a behavior happen when processing a purchase. For a dev product purchase to correctly process so that you may receive the Robux from a sale, Roblox requires that you utilize a <strong class="sou ce-inline">ProcessReceipt</strong> event function. </p>
			<p>This event is part of <strong class="sou ce-inline">MarketplaceService</strong> and is fired whenever a dev product purchase is made within your game. For these purchases to be recorded, you must make a datastore called <strong class="sou ce-inline">PurchaseHistory</strong>, with the best practice being that you record the player's <strong class="sou ce-inline">UserId</strong> and what they purchased. </p>
			<p>The string holding both parts of this data is then used as the key to save a value of <strong class="sou ce-inline">true</strong> in the datastore. Lastly and most importantly, the function returns the <strong class="sou ce-inline">PurchaseGranted</strong> option from the <strong class="sou ce-inline">ProductPurchaseDecision</strong> enumeration. This is the part that tells Roblox the purchase was successful but does not falsely report a successful purchase. </p>
			<p>For our following function, the only time a purchase is unsuccessful is when the player no longer exists, meaning they left the game before the purchase could process, in which case, we return the <strong class="sou ce-inline">NotProcessedYet</strong> option. The following function should be put into the module without alteration. You should also take note of the <strong class="sou ce-inline">PromptProductPurchaseFinished</strong> event function. This event is fired whenever a developer product prompt is closed, much like the <strong class="sou ce-inline">PromptGamePassPurchaseFinished</strong> event for gamepasses. </p>
			<p>This function calls the function in <a id="_idIndexMarker349"></a>the module with the corresponding ID of the item being purchased, allowing you to define behavior for when products are purchased just like gamepasses. You should add the following code to your module without alteration unless you are aware of what you are doing:</p>
			<p class="sou ce-code">local PurchaseHistory =   dataService:GetDataStore("PurchaseHistory")</p>
			<p class="sou ce-code">function marketService.ProcessReceipt(receiptInfo)</p>
			<p class="sou ce-code">    local playerProductKey = receiptInfo.PlayerId .. ":"         .. receiptInfo.PurchaseId</p>
			<p class="sou ce-code">    if PurchaseHistory:GetAsync(playerProductKey) then</p>
			<p class="sou ce-code">        return              Enum.ProductPurchaseDecision.PurchaseGranted </p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">     local player =       playerService:GetPlayerByUserId(receiptInfo.PlayerId)</p>
			<p class="sou ce-code">    if not player then</p>
			<p class="sou ce-code">        return             Enum.ProductPurchaseDecision.NotProcessedYet</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    PurchaseHistory:SetAsync(playerProductKey, true)    </p>
			<p class="sou ce-code">    return Enum.ProductPurchaseDecision.PurchaseGranted</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">marketService.PromptProductPurchaseFinished:</p>
			<p class="sou ce-code">  Connect(function(playerId, productId, wasPurchased)</p>
			<p class="sou ce-code">    if wasPurchased then</p>
			<p class="sou ce-code">        local player =              playerService:GetPlayerByUserId(playerId)</p>
			<p class="sou ce-code">        monetizationMod[productId](player)</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end)</p>
			<p>To learn more about why<a id="_idIndexMarker350"></a> this function must be implemented into your game, you can read the API reference covering it on the developer website with the following link: <a href="https://developer.roblox.com/en-us/api-reference/callback/MarketplaceService/ProcessReceipt">https://developer.roblox.com/en-us/api-reference/callback/MarketplaceService/ProcessReceipt</a></p>
			<p>Now that players have been given tools, it is important that you add a new function call within the <strong class="sou ce-inline">CharacterAdded</strong> event function of the <strong class="sou ce-inline">Initialize</strong> module. This function, named <strong class="sou ce-inline">givePremiumTools()</strong>, will look to see whether the player owns any of the gamepass tools and will add them to the player's backpack if they do. </p>
			<p>By utilizing the <strong class="sou ce-inline">UserOwnsGamePassAsync()</strong> method of <strong class="sou ce-inline">MarketplaceService</strong>, we can see whether a player owns a gamepass by providing a <strong class="sou ce-inline">UserId</strong> and <strong class="sou ce-inline">gamepassId</strong>. This method functions differently than you might expect. In 2018, this function replaced the now deprecated <strong class="sou ce-inline">UserHasPass()</strong> method, which yielded for a measurable amount of time, so that it could report whether a user did, in fact, own the specified gamepass. </p>
			<p>The new method caches the result from calling the function, meaning that the function will return the same result for the whole game session. Because of this, if a player were to purchase a gamepass while in a game and the new method was called, it would still say that they do not own the gamepass. </p>
			<p>To address this problem, we will be using temporary tags made in the <strong class="sou ce-inline">PromptGamePassPurchaseFinished</strong> event function as well as the <strong class="sou ce-inline">UserOwnsGamePassAsync()</strong> method to determine whether to give a player tools when they respawn. </p>
			<p>Notice that we have a table of gamepass IDs, which a generic <strong class="sou ce-inline">for</strong> loop then iterates over, calling the associated <a id="_idIndexMarker351"></a>function in the <strong class="sou ce-inline">Monetization</strong> module if the player owns the gamepass. The code to grant players their premium tools is as follows: </p>
			<p class="sou ce-code">local collectionService =   game:GetService("CollectionService")</p>
			<p class="sou ce-code">local marketService = game:GetService("MarketplaceService")</p>
			<p class="sou ce-code">local monetization = require(script.Parent.Monetization)</p>
			<p class="sou ce-code">local toolPasses = {000000, 000000, 000000}</p>
			<p class="sou ce-code">--Call this function in the CharacterAdded event function ---of</p>
			<p class="sou ce-code">--the Initialize module to award gamepass tools</p>
			<p class="sou ce-code">initializeMod.givePremiumTools = function(player)</p>
			<p class="sou ce-code">    for _, ID in pairs(toolPasses) do</p>
			<p class="sou ce-code">        local key = player.UserId</p>
			<p class="sou ce-code">        local ownsPass =              marketService:UserOwnsGamePassAsync(key, ID)</p>
			<p class="sou ce-code">        local hasTag = collectionService:HasTag(player,              ID)</p>
			<p class="sou ce-code">        if hasTag or ownsPass then</p>
			<p class="sou ce-code">            monetization[ID](player)</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end</p>
			<p>Now that processing purchases has been done, we will introduce a new function into the <strong class="sou ce-inline">PartFunctions</strong> module. This function will be called <strong class="sou ce-inline">PurchaseParts()</strong>, and you will need to introduce a new folder into the <strong class="bold">Workspace</strong> of the same name and add it to the <strong class="sou ce-inline">partGroups</strong> table. The purpose of this function is to prompt both gamepasses and developer products to a<a id="_idIndexMarker352"></a> player when they touch a part. A typical purchase prompt will look like the interface seen in <em class="italic">Figure 5.2</em>: </p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="https://learning.oreilly.com/library/view/coding-roblox-games/9781800561991/image/Figure_5.02_B16623.jpg" alt="Figure 5.2 – This is the standard interface players see when prompted to make a purchase
" width="305" height="179">
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – This is the standard interface players see when prompted to make a purchase</p>
			<p>After creating the header for the <strong class="sou ce-inline">PurchaseParts()</strong> function, we create two variables that correspond to two physical values named <strong class="sou ce-inline">PromptId</strong> and <strong class="sou ce-inline">IsProduct</strong> within the part. The <strong class="sou ce-inline">promptId</strong> variable holds the ID of the gamepass or dev product that you want to be prompted when the part is touched. The <strong class="sou ce-inline">isProduct</strong> variable is a Boolean value that determines whether what you are prompting is a gamepass or developer product. </p>
			<p>This must be specified, as the function used to prompt a purchase changes depending on the type of purchase. Once those two values are assigned to the variables, we set up an if-else case based on the purchase type. If the purchase type is a developer product, then we use the <strong class="sou ce-inline">PromptPurchase()</strong> method of <strong class="sou ce-inline">MarketplaceService</strong>, passing along the player that hit the part and <strong class="sou ce-inline">promptId</strong>. </p>
			<p>If the purchasable item is a gamepass, then we use the <strong class="sou ce-inline">PromptGamePassPurchase()</strong> method of <strong class="sou ce-inline">MarketplaceService</strong>, once again passing along both the player and <strong class="sou ce-inline">promptId</strong>. The following function will automatically prompt the gamepass or <a id="_idIndexMarker353"></a>product based on the values within the part: </p>
			<p class="sou ce-code">local marketService = game:GetService("MarketplaceService")</p>
			<p class="sou ce-code">partFunctionsMod.PurchaseParts = function(part)</p>
			<p class="sou ce-code">    local promptId = part.PromptId.Value</p>
			<p class="sou ce-code">    local isProduct = part.IsProduct.Value</p>
			<p class="sou ce-code">    part.Touched:Connect(function(hit)</p>
			<p class="sou ce-code">        local player =              partFunctionsMod.playerFromHit(hit)</p>
			<p class="sou ce-code">        if player then</p>
			<p class="sou ce-code">            if isProduct then</p>
			<p class="sou ce-code">                marketService:PromptProductPurchase(player,                  promptId)</p>
			<p class="sou ce-code">            else</p>
			<p class="sou ce-code">                marketService:PromptGamePassPurchase(player,                  promptId)</p>
			<p class="sou ce-code">            end</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">end</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor114"></a>Making in-game currency shops</h2>
			<p>Now that players with <a id="_idIndexMarker354"></a>Robux can make purchases within your game, you need to create something everyone can take advantage of by making a shop system that uses the freely attainable <strong class="bold">Coins</strong> currency created earlier.</p>
			<p>For demonstration, we will make one item, a <strong class="sou ce-inline">Tool</strong> instance, that can be purchased using <strong class="bold">Coins</strong>. To create your Tool, simply add a new <strong class="sou ce-inline">Tool</strong> into the <strong class="bold">Workspace</strong> and add a part named <strong class="sou ce-inline">Handle</strong> to it. This <strong class="sou ce-inline">tool</strong> will be named <strong class="sou ce-inline">Spring Potion</strong>; you should store this <strong class="sou ce-inline">tool</strong> and any others that you make under a new folder in <strong class="sou ce-inline">ReplicatedStorage</strong> named <strong class="sou ce-inline">ShopItems</strong>. This <strong class="sou ce-inline">Spring Potion</strong> is designed to only be used once and grant the player that <em class="italic">drinks</em> it thirty seconds of higher jumping ability. </p>
			<p>Keep in mind that if the player dies, they will not be awarded this tool back. First, add a <strong class="bold">LocalScript</strong> instance into the <strong class="sou ce-inline">Tool</strong>; it can be titled whatever you want but something like <strong class="sou ce-inline">ToolHandler</strong> would work well. Next, we must then index the player, their character, the tool itself, and the player's mouse. Notice that we also create three variables that hold information about whether the tool is equipped, whether the player has already used the tool, and the value that the <strong class="sou ce-inline">JumpPower</strong> property of the <strong class="sou ce-inline">Humanoid</strong> of the player's character should be set to. </p>
			<p>By using the <strong class="sou ce-inline">Equipped</strong> and <strong class="sou ce-inline">Unequipped</strong> events of <strong class="sou ce-inline">Tool</strong> instances, we can create two functions that change the <strong class="sou ce-inline">equipped</strong> variable to record the correct state of the tool. By using the <strong class="sou ce-inline">Button1Down</strong> event of the mouse, we can detect when the player makes a click. If the <strong class="sou ce-inline">Tool</strong> is equipped and a click is detected, then the <strong class="sou ce-inline">JumpPower</strong> property of the Humanoid in the player's character will be increased from its default value of <strong class="sou ce-inline">50</strong> to the value under the <strong class="sou ce-inline">JUMP_POWER</strong> variable, which is <strong class="sou ce-inline">90</strong>. Using a <strong class="sou ce-inline">delay()</strong> function, the program waits thirty seconds before setting the player's <strong class="sou ce-inline">JumpPower</strong> property back to its default value and destroying the tool. The code of the <strong class="sou ce-inline">ToolHandler</strong> is as follows:</p>
			<p class="sou ce-code">local playerService = game:GetService("Players")</p>
			<p class="sou ce-code">local player = playerService.LocalPlayer</p>
			<p class="sou ce-code">local char = player.Character or   player.CharacterAdded:Wait()</p>
			<p class="sou ce-code">local tool = script.Parent</p>
			<p class="sou ce-code">local mouse = player:GetMouse()</p>
			<p class="sou ce-code">local equipped</p>
			<p class="sou ce-code">local clicked = false</p>
			<p class="sou ce-code">local JUMP_POWER = 90</p>
			<p class="sou ce-code">tool.Equipped:Connect(function()</p>
			<p class="sou ce-code">    equipped = true</p>
			<p class="sou ce-code">end)</p>
			<p class="sou ce-code">tool.Unequipped:Connect(function()</p>
			<p class="sou ce-code">    equipped = false</p>
			<p class="sou ce-code">end)</p>
			<p class="sou ce-code">mouse.Button1Down:Connect(function()</p>
			<p class="sou ce-code">    if equipped and not clicked then</p>
			<p class="sou ce-code">        clicked = true</p>
			<p class="sou ce-code">        char.Humanoid.JumpPower = JUMP_POWER</p>
			<p class="sou ce-code">        delay(30, function()</p>
			<p class="sou ce-code">            char.Humanoid.JumpPower = 50</p>
			<p class="sou ce-code">            tool:Destroy()</p>
			<p class="sou ce-code">        end)</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end)</p>
			<p>With an item to give the player now created, we will return to the <strong class="sou ce-inline">PartFunctions</strong> module and introduce a new part folder and associated function both titled <strong class="sou ce-inline">ShopParts</strong>. Remember that you will need to create a new folder in the <strong class="bold">Workspace</strong> for these parts and add the indexed folder to the <strong class="sou ce-inline">partGroups</strong> table for functionality to be applied to them. </p>
			<p>First, we must create a table of items<a id="_idIndexMarker355"></a> that use the name of the associated <strong class="sou ce-inline">Tool</strong> as indexes and a table holding the price and other information you wish to add about the <strong class="sou ce-inline">Tool</strong> as a value. Like the <strong class="sou ce-inline">defaultData</strong> table, you can alternatively store this information in a module for further organization. Since <strong class="sou ce-inline">ReplicatedStorage</strong> is not yet defined in the <strong class="sou ce-inline">PartFunctions</strong> module, you will want to make a variable for it. You should now use the same format as before to create the new <strong class="sou ce-inline">ShopParts()</strong> function.</p>
			<p>In the <strong class="sou ce-inline">Touched</strong> event function, the name of the item that the player wants to purchase is taken from a <strong class="sou ce-inline">StringValue</strong> instance within the part called <strong class="sou ce-inline">ItemName</strong>; the name of the item is then used to index the tool's information from the <strong class="sou ce-inline">items</strong> table. Once the player that touched the part has been acquired, we ensure that they have enough money to make the purchase, using the price of the item from the tool's information table and the <strong class="sou ce-inline">get()</strong> method of the <strong class="sou ce-inline">Data</strong> module. </p>
			<p>If the player has enough currency to make the purchase, then the price is subtracted from their current amount of coins using the <strong class="sou ce-inline">increment()</strong> method of the <strong class="sou ce-inline">Data</strong> module. After indexing the <strong class="sou ce-inline">ShopItems</strong> folder made previously, we duplicate the <strong class="sou ce-inline">Tool</strong> by using the <strong class="sou ce-inline">Clone()</strong> method of instances and parent it to the player's backpack. The <strong class="sou ce-inline">Clone()</strong> method creates an exact copy of the provided instance regarding properties; the cloned item will not be parented anywhere, such as a new instance. </p>
			<p>You should be aware that not every type of instance can be cloned, particularly important ones such as services— trying to do so will result in an error. As mentioned in <a href="B16623_04_Final_JC_ePub.xhtml.html#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Roblox Programming Scenarios</em>, the <strong class="bold">LocalScript</strong> in the <strong class="sou ce-inline">Tool</strong> instance will now be a descendant of the player's <strong class="sou ce-inline">Backpack</strong> instance, somewhere it can be executed, meaning that the <strong class="sou ce-inline">tool </strong>instance's program will now work as expected without any additional input from elsewhere:</p>
			<p class="sou ce-code">local items = {</p>
			<p class="sou ce-code">    ["Spring Potion"] = {</p>
			<p class="sou ce-code">        Price = 5;    </p>
			<p class="sou ce-code">    } ;</p>
			<p class="sou ce-code">}</p>
			<p class="sou ce-code">local replicatedStorage =   game:GetService("ReplicatedStorage")</p>
			<p class="sou ce-code">partFunctionsMod.ShopParts = function(part)</p>
			<p class="sou ce-code">    local itemName = part.ItemName.Value</p>
			<p class="sou ce-code">    local item = items[itemName]</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    part.Touched:Connect(function(hit)</p>
			<p class="sou ce-code">        local player =              partFunctionsMod.playerFromHit(hit)</p>
			<p class="sou ce-code">        if player and dataMod.get(player, "Coins") &gt;=              item.Price then</p>
			<p class="sou ce-code">            dataMod.increment(player, "Coins", -                   item.Price)</p>
			<p class="sou ce-code">            local shopFolder =                   replicatedStorage.ShopItems</p>
			<p class="sou ce-code">            local tool =                 shopFolder:FindFirstChild(itemName):Clone()</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">            tool.Parent = player.Backpack</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">end</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor115"></a>Preventing exploits</h2>
			<p>Though this Obby does not have<a id="_idIndexMarker356"></a> much to be exploited, the best security practices have still been used. Whenever possible, data was acquired from the server as opposed to letting a client return that needed information. Additionally, by tracking a player's collected coins on the server, there is no way that the client can exploit and make a request for more coins. </p>
			<p>In the following chapter, you will be working with systems that must receive information from the client, and, in turn, you will need to employ sanity checks and will gain more practice with security overall. For the time being, you may want to come up with your own function that deletes any <strong class="sou ce-inline">BodyMover</strong> instances that the client adds to their character's <strong class="sou ce-inline">PrimaryPart</strong> to prevent exploiters from flying or otherwise cheating to pass stages. </p>
			<p>With these additions, players can now purchase items in your game with Robux or with the in-game currency you award them. You are also more aware now of what is good security and how we have actively been implementing it so far. In the following sections, you will create the <em class="italic">frontend</em> of your game.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor116"></a>Setting up the frontend</h1>
			<p>Your game is now functionally<a id="_idIndexMarker357"></a> complete with monetization implemented. The <em class="italic">frontend</em> of a project refers to the part of the game that players see and interact with the most. The following steps are to beautify your stages, make your Obby come to life with effects and movement, and provide visual and auditory indicators to the client to let them know when something has occurred.</p>
			<p>Let's start by seeing how to create effects for your Obby.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor117"></a>Creating effects</h2>
			<p>When creating effects, you want to <a id="_idIndexMarker358"></a>mostly be operating on the client. This is because we want most of these effects to only appear locally for the sake of performance and to negate replication, meaning that if you want a sound to play when you collect a coin, you should be the only one hearing that sound. </p>
			<p>To do this, you should create a new script under <strong class="sou ce-inline">StarterPlayerScripts</strong> titled <strong class="sou ce-inline">LocalHandler</strong> that contains the same code as the <strong class="sou ce-inline">ServerHandler</strong> script. The structure of systems going forward will be the same, working in modules and organizing code based on the system. Our first step to adding effects to our stages will be to create a new module in the <strong class="sou ce-inline">ClientHandler</strong> script titled <strong class="sou ce-inline">Effects</strong>. You will need to define <strong class="sou ce-inline">ReplicatedStorage</strong> because we will want to make use of server-to-client communication by way of <strong class="bold">RemoteEvent</strong> instances:</p>
			<p class="sou ce-code">local replicatedStorage =   game:GetService("ReplicatedStorage")</p>
			<p class="sou ce-code">local effectsMod = {}</p>
			<p class="sou ce-code">return effectsMod</p>
			<p>With the module setup, we will want to introduce some helper functions for our effects. Our first function will help us to work with sounds. Sound design for an Obby is not the most important aspect but some things you may want to include are a music loop as well as some sound effects for when a player activates a part. </p>
			<p>While the music loop can simply be a <strong class="sou ce-inline">Sound</strong> instance in the <strong class="bold">Workspace</strong> with its <strong class="sou ce-inline">Playing</strong> and <strong class="sou ce-inline">Looped</strong> properties set to <strong class="sou ce-inline">true</strong>, making something happen on activation will require a little bit more programming. In the following example, the code will allow for a <strong class="sou ce-inline">Sound</strong> instance within the provided part to be played. </p>
			<p>A particular place where this may be used well is with the <strong class="sou ce-inline">RewardParts</strong> folder, so that the player may associate a certain sound with when they receive a reward. For the following code, we use the <strong class="sou ce-inline">FindFirstChildOfClass()</strong> method, which is inherited by all instances, to find a <strong class="sou ce-inline">Sound</strong> instance of any name that is parented to the part. If the sound has been found, then <strong class="sou ce-inline">Sound</strong> is returned and the <strong class="sou ce-inline">Play()</strong> method of the <strong class="sou ce-inline">Sound</strong> is called, playing the sound where only the client can hear it, as the call has been made from a module being executed by the client:</p>
			<p class="sou ce-code">local function playSound(part)    </p>
			<p class="sou ce-code">    local sound = part:FindFirstChildOfClass("Sound")</p>
			<p class="sou ce-code">    if sound then</p>
			<p class="sou ce-code">        sound:Play()</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    return sound</p>
			<p class="sou ce-code">end</p>
			<p>Similar to the ability<a id="_idIndexMarker359"></a> to find and play <strong class="sou ce-inline">Sound</strong> instances, we will want to introduce a function that can emit particles if a <strong class="sou ce-inline">ParticleEmitter</strong> instance is found within the part. Particles were introduced in <a href="B16623_04_Final_JC_ePub.xhtml.html#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Roblox Programming Scenarios</em>, and are an easy way to beautify your game and catch the eye of your players. For the following function, after finding an existent <strong class="sou ce-inline">ParticleEmitter</strong> instance, we use the <strong class="sou ce-inline">Emit()</strong> method, which takes several particles to be emitted. </p>
			<p>Be aware that the <strong class="sou ce-inline">ParticleEmitter</strong> instance in your part should be disabled by default when doing this. Moreover, the <strong class="sou ce-inline">Emit()</strong> method will produce these particles all at once so if you wanted to simply turn on the emitter and turn it off again after some time has passed, you could alternatively set the <strong class="sou ce-inline">Enabled</strong> property of <strong class="sou ce-inline">ParticleEmitter</strong> to <strong class="sou ce-inline">true</strong> and implement a <strong class="sou ce-inline">delay()</strong> function to disable it again:</p>
			<p class="sou ce-code">local function emitParticles(part, amount)</p>
			<p class="sou ce-code">    local emitter =         part:FindFirstChildOfClass("ParticleEmitter")</p>
			<p class="sou ce-code">    if emitter then</p>
			<p class="sou ce-code">        emitter:Emit(amount)</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">    return emitter</p>
			<p class="sou ce-code">end</p>
			<p>Now, like in the <strong class="sou ce-inline">PartFunctions</strong> module, we will make functions that correspond to a folder name so that they can be easily called. In the <strong class="sou ce-inline">PartFunctions</strong> module, in each part function that you want to add a sound or particle to, you should insert the line that is denoted by <em class="italic">server</em> after all checks have been passed. </p>
			<p>Keep in mind that you will also need a new <strong class="bold">RemoteEvent</strong> instance in <strong class="sou ce-inline">ReplicatedStorage</strong> named <strong class="sou ce-inline">Effect</strong> so that the server can send a signal to the client. This line will send a signal to the client, passing along the part that has been hit so that the client does not need to <a id="_idIndexMarker360"></a>do separate and unnecessary hit detection for every special part in the game. Once the signal is sent, it will be detected in the client-side <strong class="sou ce-inline">Effects</strong> module. </p>
			<p>By making an <strong class="sou ce-inline">OnClientEvent</strong> event function, the folder name of the part's group is obtained from its parent, calling the function with the associated name in the <strong class="sou ce-inline">Effects</strong> module. The functions in the module will be able to use our previously defined helper functions by passing along the part. For parts parented to both the <strong class="sou ce-inline">RewardParts</strong> and <strong class="sou ce-inline">SpawnParts</strong> folders, we check for both <strong class="sou ce-inline">ParticleEmitter</strong> and <strong class="sou ce-inline">Sound</strong> instances using the <strong class="sou ce-inline">emitParticles()</strong> and <strong class="sou ce-inline">playSound()</strong> functions. </p>
			<p>Remember that you are not required to include those instances and the function will still work whether they are present or not. For checkpoints in the <strong class="sou ce-inline">SpawnParts</strong> folder, we additionally change the material to neon, changing it back to smooth plastic a second later by way of a <strong class="sou ce-inline">delay()</strong> function:</p>
			<p class="sou ce-code">--server</p>
			<p class="sou ce-code">--place this in a part function after all checks are made</p>
			<p class="sou ce-code">replicatedStorage.Effect:FireClient(player, part)</p>
			<p class="sou ce-code">--client</p>
			<p class="sou ce-code">replicatedStorage.Effect.OnClientEvent:Connect(function(par   t)</p>
			<p class="sou ce-code">    local folderName = part.Parent.Name</p>
			<p class="sou ce-code">    effectsMod[folderName](part)</p>
			<p class="sou ce-code">end)</p>
			<p class="sou ce-code">effectsMod.RewardParts = function(part)</p>
			<p class="sou ce-code">    part.Transparency = 1</p>
			<p class="sou ce-code">    playSound(part)</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">effectsMod.SpawnParts = function(part)</p>
			<p class="sou ce-code">    playSound(part)</p>
			<p class="sou ce-code">    emitParticles(part, 50)</p>
			<p class="sou ce-code">    part.Material = Enum.Material.Neon</p>
			<p class="sou ce-code">    </p>
			<p class="sou ce-code">    delay(1, function()</p>
			<p class="sou ce-code">        part.Material = Enum.Material.SmoothPlastic</p>
			<p class="sou ce-code">    end)</p>
			<p class="sou ce-code">end</p>
			<p>Another type of effect that can be added to breathe more life into your Obby is part movement. While <a id="_idIndexMarker361"></a>movement can be done on the server, this generally is not good practice as the server refreshes slower and a client may not have a perfect connection to it, resulting in slow and choppy effects. To accomplish this, we will be making a table of parts in the <strong class="sou ce-inline">Effects</strong> module so that parts from any group can be rotated if they contain a value. </p>
			<p>To rotate the parts, we will be using a special loop by way of <strong class="sou ce-inline">RunService</strong>. <strong class="sou ce-inline">RunService</strong> is used to create loops that run at speeds shorter than a <strong class="sou ce-inline">wait()</strong> function can achieve. The <strong class="sou ce-inline">RenderStepped</strong> event is an event only available when using <strong class="sou ce-inline">RunService</strong> on the client and fires each time a frame is rendered. The event passes along a delta, the amount of time between each frame, meaning that if a player were getting 60 frames per second, <strong class="sou ce-inline">dt</strong> would have a value of 1/60. </p>
			<p>After acquiring the folder associated with the part, we look to see whether the part contains a <strong class="sou ce-inline">Vector3Value</strong> instance named <strong class="sou ce-inline">Rotate</strong>. If the value exists, then the part is added to a table, in which all parts that should be rotated are contained. The fact this value holds a <strong class="sou ce-inline">Vector3</strong> means<a id="_idIndexMarker362"></a> that you can give parts custom rotation velocities. As you will see, this value should be the speed you want the part to rotate at in degrees per second. </p>
			<p>The <strong class="sou ce-inline">RenderStepped</strong> event function fires each frame, iterating over all parts by using a generic <strong class="sou ce-inline">for</strong> loop. For each part, the <strong class="sou ce-inline">Vector3Value</strong> instance is found and its value is assigned to a variable called <strong class="sou ce-inline">rot</strong>. This vector is then multiplied by the scalar held in <strong class="sou ce-inline">dt</strong> to convert each component from its original number into a degrees per second format. This new vector is then converted into radians by using another vector-scalar multiplication so that the value may be used with a <strong class="sou ce-inline">CFrame</strong> manipulation of the part. </p>
			<p>Lastly, we construct a new <strong class="sou ce-inline">CFrame.Angles()</strong> using the components of the new vector, multiplying it by the parts of the current <strong class="sou ce-inline">CFrame</strong> to achieve rotation:</p>
			<p class="sou ce-code">local runService = game:GetService("RunService")</p>
			<p class="sou ce-code">local rotParts = {}</p>
			<p class="sou ce-code">local partGroups = {</p>
			<p class="sou ce-code">    workspace.KillParts;</p>
			<p class="sou ce-code">    workspace.DamageParts;</p>
			<p class="sou ce-code">    workspace.SpawnParts;</p>
			<p class="sou ce-code">    workspace.RewardParts;</p>
			<p class="sou ce-code">    workspace.PurchaseParts;</p>
			<p class="sou ce-code">    workspace.BadgeParts;</p>
			<p class="sou ce-code">    workspace.ShopParts;</p>
			<p class="sou ce-code">}</p>
			<p class="sou ce-code">for _, group in pairs(partGroups) do</p>
			<p class="sou ce-code">    for _, part in pairs(group:GetChildren()) do</p>
			<p class="sou ce-code">        if part:IsA("BasePart") then</p>
			<p class="sou ce-code">            if part:FindFirstChild("Rotate") then</p>
			<p class="sou ce-code">                table.insert(rotParts, part)</p>
			<p class="sou ce-code">            end</p>
			<p class="sou ce-code">        end</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end</p>
			<p class="sou ce-code">runService.RenderStepped:Connect(function(dt)</p>
			<p class="sou ce-code">    for _, part in pairs(rotParts) do</p>
			<p class="sou ce-code">        local rot = part.Rotate.Value</p>
			<p class="sou ce-code">        rot = rot * dt</p>
			<p class="sou ce-code">        rot = rot * ((2 * math.pi) / 360)</p>
			<p class="sou ce-code">        rot = CFrame.Angles(rot.X, rot.Y, rot.Z)</p>
			<p class="sou ce-code">        part.CFrame = part.CFrame * rot</p>
			<p class="sou ce-code">    end</p>
			<p class="sou ce-code">end)</p>
			<p>You may also find that <a id="_idIndexMarker363"></a>by combining <strong class="sou ce-inline">RunService</strong> with other loops, you can make more effects and mechanics using moving parts including elevators, moving platforms for players to jump between, and other obstacles.</p>
			<p>Lastly, lighting is an effect not to overlook. Lighting that is obnoxiously bright or oversaturated is something that could turn away your audience. Many Obbys make the mistake of drastically increasing saturation and brightness to make their stages look more kid-friendly or cartoony but this oftentimes leads to an annoying atmosphere for almost any player. While <a id="_idIndexMarker364"></a>decisions on lighting are ultimately up to you, make sure your map is easy to look at and that you can clearly see the entire stage you are currently on.</p>
			<p>Your game is now more interactive and beautified, which will increase how much you engage the players of your game. The following sections will discuss the steps of publishing your Obby and what we will do moving forward.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor118"></a>Testing and publication</h1>
			<p>Now that your game has been<a id="_idIndexMarker365"></a> completed on both the frontend and backend, it is important that you test your stages to make sure that they are doable <a id="_idIndexMarker366"></a>and that all of the special parts within them are functioning as you intended. In the case that you implemented functionality of your own, you should be particularly sure that your new system works. Make sure that your purchases are processing correctly and that you always have the items you purchased to avoid any complaints from players that do not receive what they paid for. </p>
			<p>The best way to look for errors is to press <em class="italic">Shift</em> + <em class="italic">F9</em> while testing to bring up the <strong class="bold">Developer Console</strong>. This console will allow you to look for output, warnings, and errors on both the server and client when in game, as seen in <em class="italic">Figure 5.3</em>. Keep in mind that only those with permissions to edit the game will have access to the server-side command bar:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="https://learning.oreilly.com/library/view/coding-roblox-games/9781800561991/image/Figure_5.03_B16623.jpg" alt="Figure 5.3 – The Developer Console serves as a window for output while playing your game
" width="995" height="368">
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – The Developer Console serves as a window for output while playing your game</p>
			<p>After testing by yourself, it is a great practice to get feedback from your friends and see whether they find any issues <a id="_idIndexMarker367"></a>you were not able to, or whether they have any general comments that you want to consider. If you are ready to release your game, you may find it beneficial to start with a small number of sponsors or ads so that <a id="_idIndexMarker368"></a>you can get more feedback from the often all-too-honest public and see what changes they suggest or the further bugs they find; when it comes to finding problems within your game, there is no such thing as too much testing.</p>
			<p>Once your testing concludes and your sponsors have begun running, you have officially released one of your first games! There is no better feeling than the mixture of happiness, relief, and sometimes anxiety of publishing a game. The best thing to do is to let the game be and monitor its performance. If you have somewhere that players can leave feedback, be it Discord, direct messages, or on the Group Wall if the game is hosted by a group, see what players have to say and what is worth addressing.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor119"></a>Summary</h1>
			<p>You have now finished creating what may be one of your first full Roblox games. From this chapter, you have learned how to manage players and their data and make systems that add functionality behaviors to your game as a whole, as well as implement engagement techniques to better attract and keep your audience. Going forward you will make another game example, which will use some of the systems from this chapter as well as many new ones so that you may implement more complex mechanics into your future games.</p>
			<p>In the following chapter, you will learn how to create a <strong class="bold">Battle Royale</strong> themed game. Battle royale games are currently extremely popular, being the concept used in <strong class="bold">Fortnite</strong>, <strong class="bold">PUBG</strong>, <strong class="bold">COD: Warzone</strong>, and more. A game of this type will grant you more experience working from the client and subsequently implementing more security practices, as you will be guided to create weapons, work with the user interface, and generally use more client-to-server communication.</p>
		</div>
	</div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="B16623_04_Final_JC_ePub.xhtml.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">Chapter 4: Roblox Programming Scenarios</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="B16623_06_Final_JC_ePub.xhtml.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">Chapter 6: Creating a Battle Royale Game</div>
        </a>
    
  
  </div>


        
    </section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag">
        
        

        
          <p>You have 6 days left in your trial, Michaelschiner. Subscribe today. <a href="https://learning.oreilly.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
        
        

      </div>

    
    



        
      </div>
      
        

<footer class="pagefoot t-pagefoot">
  <a href="B16623_05_Final_JC_ePub.xhtml.html#" class="icon-up" onclick="window.Appcues.track('JumpTop_HeronBook')"><div class="visuallyhidden">Back to top</div></a>
  <ul class='js-footer-nav'>
  
    
    <li><a href="https://learning.oreilly.com/public/support/">Support</a></li>
    
    <li><a href="https://learning.oreilly.com/accounts/logout/">Sign Out</a></li>
    
  
  
  </ul>
  <span class="copyright">&#169; 2021 <a href="https://learning.oreilly.com/" target="_blank">O'Reilly Media, Inc</a>.</span>
  
    
    <a href="https://www.oreilly.com/terms/">Terms of Service</a> 
     / 
    
    <a href="https://learning.oreilly.com/privacy">Privacy Policy</a> 
    
    
  
</footer>

      
    
    <script src="https://learning.oreilly.com/jsi18n/web/" charset="utf-8"></script>
    <script src="https://learning.oreilly.com/library/jsi18n/appcache/" charset="utf-8"></script>
  </body>
</html>
